(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../../../../../../../node_modules/leaflet/dist/leaflet-src.js
  var require_leaflet_src = __commonJS({
    "../../../../../../../node_modules/leaflet/dist/leaflet-src.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.leaflet = {}));
      })(exports, function(exports2) {
        "use strict";
        var version = "1.9.4";
        function extend(dest) {
          var i, j, len, src;
          for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
              dest[i] = src[i];
            }
          }
          return dest;
        }
        var create$2 = Object.create || function() {
          function F() {
          }
          return function(proto) {
            F.prototype = proto;
            return new F();
          };
        }();
        function bind(fn, obj) {
          var slice2 = Array.prototype.slice;
          if (fn.bind) {
            return fn.bind.apply(fn, slice2.call(arguments, 1));
          }
          var args = slice2.call(arguments, 2);
          return function() {
            return fn.apply(obj, args.length ? args.concat(slice2.call(arguments)) : arguments);
          };
        }
        var lastId = 0;
        function stamp(obj) {
          if (!("_leaflet_id" in obj)) {
            obj["_leaflet_id"] = ++lastId;
          }
          return obj._leaflet_id;
        }
        function throttle(fn, time, context) {
          var lock, args, wrapperFn, later;
          later = function() {
            lock = false;
            if (args) {
              wrapperFn.apply(context, args);
              args = false;
            }
          };
          wrapperFn = function() {
            if (lock) {
              args = arguments;
            } else {
              fn.apply(context, arguments);
              setTimeout(later, time);
              lock = true;
            }
          };
          return wrapperFn;
        }
        function wrapNum(x2, range, includeMax) {
          var max = range[1], min = range[0], d = max - min;
          return x2 === max && includeMax ? x2 : ((x2 - min) % d + d) % d + min;
        }
        function falseFn() {
          return false;
        }
        function formatNum(num, precision) {
          if (precision === false) {
            return num;
          }
          var pow2 = Math.pow(10, precision === void 0 ? 6 : precision);
          return Math.round(num * pow2) / pow2;
        }
        function trim(str) {
          return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
        }
        function splitWords(str) {
          return trim(str).split(/\s+/);
        }
        function setOptions(obj, options) {
          if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
            obj.options = obj.options ? create$2(obj.options) : {};
          }
          for (var i in options) {
            obj.options[i] = options[i];
          }
          return obj.options;
        }
        function getParamString(obj, existingUrl, uppercase) {
          var params = [];
          for (var i in obj) {
            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
          }
          return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        }
        var templateRe = /\{ *([\w_ -]+) *\}/g;
        function template(str, data) {
          return str.replace(templateRe, function(str2, key) {
            var value = data[key];
            if (value === void 0) {
              throw new Error("No value provided for variable " + str2);
            } else if (typeof value === "function") {
              value = value(data);
            }
            return value;
          });
        }
        var isArray = Array.isArray || function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        function indexOf(array2, el) {
          for (var i = 0; i < array2.length; i++) {
            if (array2[i] === el) {
              return i;
            }
          }
          return -1;
        }
        var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function getPrefixed(name) {
          return window["webkit" + name] || window["moz" + name] || window["ms" + name];
        }
        var lastTime = 0;
        function timeoutDefer(fn) {
          var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
          lastTime = time + timeToCall;
          return window.setTimeout(fn, timeToCall);
        }
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
          window.clearTimeout(id);
        };
        function requestAnimFrame(fn, context, immediate) {
          if (immediate && requestFn === timeoutDefer) {
            fn.call(context);
          } else {
            return requestFn.call(window, bind(fn, context));
          }
        }
        function cancelAnimFrame(id) {
          if (id) {
            cancelFn.call(window, id);
          }
        }
        var Util = {
          __proto__: null,
          extend,
          create: create$2,
          bind,
          get lastId() {
            return lastId;
          },
          stamp,
          throttle,
          wrapNum,
          falseFn,
          formatNum,
          trim,
          splitWords,
          setOptions,
          getParamString,
          template,
          isArray,
          indexOf,
          emptyImageUrl,
          requestFn,
          cancelFn,
          requestAnimFrame,
          cancelAnimFrame
        };
        function Class() {
        }
        Class.extend = function(props) {
          var NewClass = function() {
            setOptions(this);
            if (this.initialize) {
              this.initialize.apply(this, arguments);
            }
            this.callInitHooks();
          };
          var parentProto = NewClass.__super__ = this.prototype;
          var proto = create$2(parentProto);
          proto.constructor = NewClass;
          NewClass.prototype = proto;
          for (var i in this) {
            if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
              NewClass[i] = this[i];
            }
          }
          if (props.statics) {
            extend(NewClass, props.statics);
          }
          if (props.includes) {
            checkDeprecatedMixinEvents(props.includes);
            extend.apply(null, [proto].concat(props.includes));
          }
          extend(proto, props);
          delete proto.statics;
          delete proto.includes;
          if (proto.options) {
            proto.options = parentProto.options ? create$2(parentProto.options) : {};
            extend(proto.options, props.options);
          }
          proto._initHooks = [];
          proto.callInitHooks = function() {
            if (this._initHooksCalled) {
              return;
            }
            if (parentProto.callInitHooks) {
              parentProto.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
              proto._initHooks[i2].call(this);
            }
          };
          return NewClass;
        };
        Class.include = function(props) {
          var parentOptions = this.prototype.options;
          extend(this.prototype, props);
          if (props.options) {
            this.prototype.options = parentOptions;
            this.mergeOptions(props.options);
          }
          return this;
        };
        Class.mergeOptions = function(options) {
          extend(this.prototype.options, options);
          return this;
        };
        Class.addInitHook = function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          var init = typeof fn === "function" ? fn : function() {
            this[fn].apply(this, args);
          };
          this.prototype._initHooks = this.prototype._initHooks || [];
          this.prototype._initHooks.push(init);
          return this;
        };
        function checkDeprecatedMixinEvents(includes) {
          if (typeof L === "undefined" || !L || !L.Mixin) {
            return;
          }
          includes = isArray(includes) ? includes : [includes];
          for (var i = 0; i < includes.length; i++) {
            if (includes[i] === L.Mixin.Events) {
              console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
            }
          }
        }
        var Events = {
          /* @method on(type: String, fn: Function, context?: Object): this
           * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
           *
           * @alternative
           * @method on(eventMap: Object): this
           * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
           */
          on: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              for (var i = 0, len = types.length; i < len; i++) {
                this._on(types[i], fn, context);
              }
            }
            return this;
          },
          /* @method off(type: String, fn?: Function, context?: Object): this
           * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
           *
           * @alternative
           * @method off(eventMap: Object): this
           * Removes a set of type/listener pairs.
           *
           * @alternative
           * @method off: this
           * Removes all listeners to all events on the object. This includes implicitly attached events.
           */
          off: function(types, fn, context) {
            if (!arguments.length) {
              delete this._events;
            } else if (typeof types === "object") {
              for (var type in types) {
                this._off(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              var removeAll = arguments.length === 1;
              for (var i = 0, len = types.length; i < len; i++) {
                if (removeAll) {
                  this._off(types[i]);
                } else {
                  this._off(types[i], fn, context);
                }
              }
            }
            return this;
          },
          // attach listener (without syntactic sugar now)
          _on: function(type, fn, context, _once) {
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            if (this._listens(type, fn, context) !== false) {
              return;
            }
            if (context === this) {
              context = void 0;
            }
            var newListener = { fn, ctx: context };
            if (_once) {
              newListener.once = true;
            }
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push(newListener);
          },
          _off: function(type, fn, context) {
            var listeners, i, len;
            if (!this._events) {
              return;
            }
            listeners = this._events[type];
            if (!listeners) {
              return;
            }
            if (arguments.length === 1) {
              if (this._firingCount) {
                for (i = 0, len = listeners.length; i < len; i++) {
                  listeners[i].fn = falseFn;
                }
              }
              delete this._events[type];
              return;
            }
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            var index2 = this._listens(type, fn, context);
            if (index2 !== false) {
              var listener = listeners[index2];
              if (this._firingCount) {
                listener.fn = falseFn;
                this._events[type] = listeners = listeners.slice();
              }
              listeners.splice(index2, 1);
            }
          },
          // @method fire(type: String, data?: Object, propagate?: Boolean): this
          // Fires an event of the specified type. You can optionally provide a data
          // object — the first argument of the listener function will contain its
          // properties. The event can optionally be propagated to event parents.
          fire: function(type, data, propagate) {
            if (!this.listens(type, propagate)) {
              return this;
            }
            var event = extend({}, data, {
              type,
              target: this,
              sourceTarget: data && data.sourceTarget || this
            });
            if (this._events) {
              var listeners = this._events[type];
              if (listeners) {
                this._firingCount = this._firingCount + 1 || 1;
                for (var i = 0, len = listeners.length; i < len; i++) {
                  var l = listeners[i];
                  var fn = l.fn;
                  if (l.once) {
                    this.off(type, fn, l.ctx);
                  }
                  fn.call(l.ctx || this, event);
                }
                this._firingCount--;
              }
            }
            if (propagate) {
              this._propagateEvent(event);
            }
            return this;
          },
          // @method listens(type: String, propagate?: Boolean): Boolean
          // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
          // Returns `true` if a particular event type has any listeners attached to it.
          // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
          listens: function(type, fn, context, propagate) {
            if (typeof type !== "string") {
              console.warn('"string" type argument expected');
            }
            var _fn = fn;
            if (typeof fn !== "function") {
              propagate = !!fn;
              _fn = void 0;
              context = void 0;
            }
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) {
              if (this._listens(type, _fn, context) !== false) {
                return true;
              }
            }
            if (propagate) {
              for (var id in this._eventParents) {
                if (this._eventParents[id].listens(type, fn, context, propagate)) {
                  return true;
                }
              }
            }
            return false;
          },
          // returns the index (number) or false
          _listens: function(type, fn, context) {
            if (!this._events) {
              return false;
            }
            var listeners = this._events[type] || [];
            if (!fn) {
              return !!listeners.length;
            }
            if (context === this) {
              context = void 0;
            }
            for (var i = 0, len = listeners.length; i < len; i++) {
              if (listeners[i].fn === fn && listeners[i].ctx === context) {
                return i;
              }
            }
            return false;
          },
          // @method once(…): this
          // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
          once: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn, true);
              }
            } else {
              types = splitWords(types);
              for (var i = 0, len = types.length; i < len; i++) {
                this._on(types[i], fn, context, true);
              }
            }
            return this;
          },
          // @method addEventParent(obj: Evented): this
          // Adds an event parent - an `Evented` that will receive propagated events
          addEventParent: function(obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[stamp(obj)] = obj;
            return this;
          },
          // @method removeEventParent(obj: Evented): this
          // Removes an event parent, so it will stop receiving propagated events
          removeEventParent: function(obj) {
            if (this._eventParents) {
              delete this._eventParents[stamp(obj)];
            }
            return this;
          },
          _propagateEvent: function(e) {
            for (var id in this._eventParents) {
              this._eventParents[id].fire(e.type, extend({
                layer: e.target,
                propagatedFrom: e.target
              }, e), true);
            }
          }
        };
        Events.addEventListener = Events.on;
        Events.removeEventListener = Events.clearAllEventListeners = Events.off;
        Events.addOneTimeEventListener = Events.once;
        Events.fireEvent = Events.fire;
        Events.hasEventListeners = Events.listens;
        var Evented = Class.extend(Events);
        function Point(x2, y2, round2) {
          this.x = round2 ? Math.round(x2) : x2;
          this.y = round2 ? Math.round(y2) : y2;
        }
        var trunc = Math.trunc || function(v) {
          return v > 0 ? Math.floor(v) : Math.ceil(v);
        };
        Point.prototype = {
          // @method clone(): Point
          // Returns a copy of the current point.
          clone: function() {
            return new Point(this.x, this.y);
          },
          // @method add(otherPoint: Point): Point
          // Returns the result of addition of the current and the given points.
          add: function(point2) {
            return this.clone()._add(toPoint(point2));
          },
          _add: function(point2) {
            this.x += point2.x;
            this.y += point2.y;
            return this;
          },
          // @method subtract(otherPoint: Point): Point
          // Returns the result of subtraction of the given point from the current.
          subtract: function(point2) {
            return this.clone()._subtract(toPoint(point2));
          },
          _subtract: function(point2) {
            this.x -= point2.x;
            this.y -= point2.y;
            return this;
          },
          // @method divideBy(num: Number): Point
          // Returns the result of division of the current point by the given number.
          divideBy: function(num) {
            return this.clone()._divideBy(num);
          },
          _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
          },
          // @method multiplyBy(num: Number): Point
          // Returns the result of multiplication of the current point by the given number.
          multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
          },
          _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
          },
          // @method scaleBy(scale: Point): Point
          // Multiply each coordinate of the current point by each coordinate of
          // `scale`. In linear algebra terms, multiply the point by the
          // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
          // defined by `scale`.
          scaleBy: function(point2) {
            return new Point(this.x * point2.x, this.y * point2.y);
          },
          // @method unscaleBy(scale: Point): Point
          // Inverse of `scaleBy`. Divide each coordinate of the current point by
          // each coordinate of `scale`.
          unscaleBy: function(point2) {
            return new Point(this.x / point2.x, this.y / point2.y);
          },
          // @method round(): Point
          // Returns a copy of the current point with rounded coordinates.
          round: function() {
            return this.clone()._round();
          },
          _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
          },
          // @method floor(): Point
          // Returns a copy of the current point with floored coordinates (rounded down).
          floor: function() {
            return this.clone()._floor();
          },
          _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
          },
          // @method ceil(): Point
          // Returns a copy of the current point with ceiled coordinates (rounded up).
          ceil: function() {
            return this.clone()._ceil();
          },
          _ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
          },
          // @method trunc(): Point
          // Returns a copy of the current point with truncated coordinates (rounded towards zero).
          trunc: function() {
            return this.clone()._trunc();
          },
          _trunc: function() {
            this.x = trunc(this.x);
            this.y = trunc(this.y);
            return this;
          },
          // @method distanceTo(otherPoint: Point): Number
          // Returns the cartesian distance between the current and the given points.
          distanceTo: function(point2) {
            point2 = toPoint(point2);
            var x2 = point2.x - this.x, y2 = point2.y - this.y;
            return Math.sqrt(x2 * x2 + y2 * y2);
          },
          // @method equals(otherPoint: Point): Boolean
          // Returns `true` if the given point has the same coordinates.
          equals: function(point2) {
            point2 = toPoint(point2);
            return point2.x === this.x && point2.y === this.y;
          },
          // @method contains(otherPoint: Point): Boolean
          // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
          contains: function(point2) {
            point2 = toPoint(point2);
            return Math.abs(point2.x) <= Math.abs(this.x) && Math.abs(point2.y) <= Math.abs(this.y);
          },
          // @method toString(): String
          // Returns a string representation of the point for debugging purposes.
          toString: function() {
            return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
          }
        };
        function toPoint(x2, y2, round2) {
          if (x2 instanceof Point) {
            return x2;
          }
          if (isArray(x2)) {
            return new Point(x2[0], x2[1]);
          }
          if (x2 === void 0 || x2 === null) {
            return x2;
          }
          if (typeof x2 === "object" && "x" in x2 && "y" in x2) {
            return new Point(x2.x, x2.y);
          }
          return new Point(x2, y2, round2);
        }
        function Bounds(a, b) {
          if (!a) {
            return;
          }
          var points = b ? [a, b] : a;
          for (var i = 0, len = points.length; i < len; i++) {
            this.extend(points[i]);
          }
        }
        Bounds.prototype = {
          // @method extend(point: Point): this
          // Extends the bounds to contain the given point.
          // @alternative
          // @method extend(otherBounds: Bounds): this
          // Extend the bounds to contain the given bounds
          extend: function(obj) {
            var min2, max2;
            if (!obj) {
              return this;
            }
            if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
              min2 = max2 = toPoint(obj);
            } else {
              obj = toBounds(obj);
              min2 = obj.min;
              max2 = obj.max;
              if (!min2 || !max2) {
                return this;
              }
            }
            if (!this.min && !this.max) {
              this.min = min2.clone();
              this.max = max2.clone();
            } else {
              this.min.x = Math.min(min2.x, this.min.x);
              this.max.x = Math.max(max2.x, this.max.x);
              this.min.y = Math.min(min2.y, this.min.y);
              this.max.y = Math.max(max2.y, this.max.y);
            }
            return this;
          },
          // @method getCenter(round?: Boolean): Point
          // Returns the center point of the bounds.
          getCenter: function(round2) {
            return toPoint(
              (this.min.x + this.max.x) / 2,
              (this.min.y + this.max.y) / 2,
              round2
            );
          },
          // @method getBottomLeft(): Point
          // Returns the bottom-left point of the bounds.
          getBottomLeft: function() {
            return toPoint(this.min.x, this.max.y);
          },
          // @method getTopRight(): Point
          // Returns the top-right point of the bounds.
          getTopRight: function() {
            return toPoint(this.max.x, this.min.y);
          },
          // @method getTopLeft(): Point
          // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
          getTopLeft: function() {
            return this.min;
          },
          // @method getBottomRight(): Point
          // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
          getBottomRight: function() {
            return this.max;
          },
          // @method getSize(): Point
          // Returns the size of the given bounds
          getSize: function() {
            return this.max.subtract(this.min);
          },
          // @method contains(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle contains the given one.
          // @alternative
          // @method contains(point: Point): Boolean
          // Returns `true` if the rectangle contains the given point.
          contains: function(obj) {
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof Point) {
              obj = toPoint(obj);
            } else {
              obj = toBounds(obj);
            }
            if (obj instanceof Bounds) {
              min = obj.min;
              max = obj.max;
            } else {
              min = max = obj;
            }
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
          },
          // @method intersects(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle intersects the given bounds. Two bounds
          // intersect if they have at least one point in common.
          intersects: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
          },
          // @method overlaps(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle overlaps the given bounds. Two bounds
          // overlap if their intersection is an area.
          overlaps: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
            return xOverlaps && yOverlaps;
          },
          // @method isValid(): Boolean
          // Returns `true` if the bounds are properly initialized.
          isValid: function() {
            return !!(this.min && this.max);
          },
          // @method pad(bufferRatio: Number): Bounds
          // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
          // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
          // Negative values will retract the bounds.
          pad: function(bufferRatio) {
            var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
            return toBounds(
              toPoint(min.x - heightBuffer, min.y - widthBuffer),
              toPoint(max.x + heightBuffer, max.y + widthBuffer)
            );
          },
          // @method equals(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle is equivalent to the given bounds.
          equals: function(bounds) {
            if (!bounds) {
              return false;
            }
            bounds = toBounds(bounds);
            return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
          }
        };
        function toBounds(a, b) {
          if (!a || a instanceof Bounds) {
            return a;
          }
          return new Bounds(a, b);
        }
        function LatLngBounds(corner1, corner2) {
          if (!corner1) {
            return;
          }
          var latlngs = corner2 ? [corner1, corner2] : corner1;
          for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
          }
        }
        LatLngBounds.prototype = {
          // @method extend(latlng: LatLng): this
          // Extend the bounds to contain the given point
          // @alternative
          // @method extend(otherBounds: LatLngBounds): this
          // Extend the bounds to contain the given bounds
          extend: function(obj) {
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLng) {
              sw2 = obj;
              ne2 = obj;
            } else if (obj instanceof LatLngBounds) {
              sw2 = obj._southWest;
              ne2 = obj._northEast;
              if (!sw2 || !ne2) {
                return this;
              }
            } else {
              return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
            }
            if (!sw && !ne) {
              this._southWest = new LatLng(sw2.lat, sw2.lng);
              this._northEast = new LatLng(ne2.lat, ne2.lng);
            } else {
              sw.lat = Math.min(sw2.lat, sw.lat);
              sw.lng = Math.min(sw2.lng, sw.lng);
              ne.lat = Math.max(ne2.lat, ne.lat);
              ne.lng = Math.max(ne2.lng, ne.lng);
            }
            return this;
          },
          // @method pad(bufferRatio: Number): LatLngBounds
          // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
          // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
          // Negative values will retract the bounds.
          pad: function(bufferRatio) {
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new LatLngBounds(
              new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
              new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
            );
          },
          // @method getCenter(): LatLng
          // Returns the center point of the bounds.
          getCenter: function() {
            return new LatLng(
              (this._southWest.lat + this._northEast.lat) / 2,
              (this._southWest.lng + this._northEast.lng) / 2
            );
          },
          // @method getSouthWest(): LatLng
          // Returns the south-west point of the bounds.
          getSouthWest: function() {
            return this._southWest;
          },
          // @method getNorthEast(): LatLng
          // Returns the north-east point of the bounds.
          getNorthEast: function() {
            return this._northEast;
          },
          // @method getNorthWest(): LatLng
          // Returns the north-west point of the bounds.
          getNorthWest: function() {
            return new LatLng(this.getNorth(), this.getWest());
          },
          // @method getSouthEast(): LatLng
          // Returns the south-east point of the bounds.
          getSouthEast: function() {
            return new LatLng(this.getSouth(), this.getEast());
          },
          // @method getWest(): Number
          // Returns the west longitude of the bounds
          getWest: function() {
            return this._southWest.lng;
          },
          // @method getSouth(): Number
          // Returns the south latitude of the bounds
          getSouth: function() {
            return this._southWest.lat;
          },
          // @method getEast(): Number
          // Returns the east longitude of the bounds
          getEast: function() {
            return this._northEast.lng;
          },
          // @method getNorth(): Number
          // Returns the north latitude of the bounds
          getNorth: function() {
            return this._northEast.lat;
          },
          // @method contains(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle contains the given one.
          // @alternative
          // @method contains (latlng: LatLng): Boolean
          // Returns `true` if the rectangle contains the given point.
          contains: function(obj) {
            if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
              obj = toLatLng(obj);
            } else {
              obj = toLatLngBounds(obj);
            }
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLngBounds) {
              sw2 = obj.getSouthWest();
              ne2 = obj.getNorthEast();
            } else {
              sw2 = ne2 = obj;
            }
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
          },
          // @method intersects(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
          intersects: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
          },
          // @method overlaps(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
          overlaps: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
            return latOverlaps && lngOverlaps;
          },
          // @method toBBoxString(): String
          // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
          toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
          },
          // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
          // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
          equals: function(bounds, maxMargin) {
            if (!bounds) {
              return false;
            }
            bounds = toLatLngBounds(bounds);
            return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
          },
          // @method isValid(): Boolean
          // Returns `true` if the bounds are properly initialized.
          isValid: function() {
            return !!(this._southWest && this._northEast);
          }
        };
        function toLatLngBounds(a, b) {
          if (a instanceof LatLngBounds) {
            return a;
          }
          return new LatLngBounds(a, b);
        }
        function LatLng(lat, lng, alt) {
          if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
          }
          this.lat = +lat;
          this.lng = +lng;
          if (alt !== void 0) {
            this.alt = +alt;
          }
        }
        LatLng.prototype = {
          // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
          // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
          equals: function(obj, maxMargin) {
            if (!obj) {
              return false;
            }
            obj = toLatLng(obj);
            var margin = Math.max(
              Math.abs(this.lat - obj.lat),
              Math.abs(this.lng - obj.lng)
            );
            return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
          },
          // @method toString(): String
          // Returns a string representation of the point (for debugging purposes).
          toString: function(precision) {
            return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
          },
          // @method distanceTo(otherLatLng: LatLng): Number
          // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
          distanceTo: function(other) {
            return Earth.distance(this, toLatLng(other));
          },
          // @method wrap(): LatLng
          // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
          wrap: function() {
            return Earth.wrapLatLng(this);
          },
          // @method toBounds(sizeInMeters: Number): LatLngBounds
          // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
          toBounds: function(sizeInMeters) {
            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
            return toLatLngBounds(
              [this.lat - latAccuracy, this.lng - lngAccuracy],
              [this.lat + latAccuracy, this.lng + lngAccuracy]
            );
          },
          clone: function() {
            return new LatLng(this.lat, this.lng, this.alt);
          }
        };
        function toLatLng(a, b, c) {
          if (a instanceof LatLng) {
            return a;
          }
          if (isArray(a) && typeof a[0] !== "object") {
            if (a.length === 3) {
              return new LatLng(a[0], a[1], a[2]);
            }
            if (a.length === 2) {
              return new LatLng(a[0], a[1]);
            }
            return null;
          }
          if (a === void 0 || a === null) {
            return a;
          }
          if (typeof a === "object" && "lat" in a) {
            return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
          }
          if (b === void 0) {
            return null;
          }
          return new LatLng(a, b, c);
        }
        var CRS = {
          // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
          // Projects geographical coordinates into pixel coordinates for a given zoom.
          latLngToPoint: function(latlng, zoom2) {
            var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
            return this.transformation._transform(projectedPoint, scale2);
          },
          // @method pointToLatLng(point: Point, zoom: Number): LatLng
          // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
          // zoom into geographical coordinates.
          pointToLatLng: function(point2, zoom2) {
            var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point2, scale2);
            return this.projection.unproject(untransformedPoint);
          },
          // @method project(latlng: LatLng): Point
          // Projects geographical coordinates into coordinates in units accepted for
          // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
          project: function(latlng) {
            return this.projection.project(latlng);
          },
          // @method unproject(point: Point): LatLng
          // Given a projected coordinate returns the corresponding LatLng.
          // The inverse of `project`.
          unproject: function(point2) {
            return this.projection.unproject(point2);
          },
          // @method scale(zoom: Number): Number
          // Returns the scale used when transforming projected coordinates into
          // pixel coordinates for a particular zoom. For example, it returns
          // `256 * 2^zoom` for Mercator-based CRS.
          scale: function(zoom2) {
            return 256 * Math.pow(2, zoom2);
          },
          // @method zoom(scale: Number): Number
          // Inverse of `scale()`, returns the zoom level corresponding to a scale
          // factor of `scale`.
          zoom: function(scale2) {
            return Math.log(scale2 / 256) / Math.LN2;
          },
          // @method getProjectedBounds(zoom: Number): Bounds
          // Returns the projection's bounds scaled and transformed for the provided `zoom`.
          getProjectedBounds: function(zoom2) {
            if (this.infinite) {
              return null;
            }
            var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
            return new Bounds(min, max);
          },
          // @method distance(latlng1: LatLng, latlng2: LatLng): Number
          // Returns the distance between two geographical coordinates.
          // @property code: String
          // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
          //
          // @property wrapLng: Number[]
          // An array of two numbers defining whether the longitude (horizontal) coordinate
          // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
          // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
          //
          // @property wrapLat: Number[]
          // Like `wrapLng`, but for the latitude (vertical) axis.
          // wrapLng: [min, max],
          // wrapLat: [min, max],
          // @property infinite: Boolean
          // If true, the coordinate space will be unbounded (infinite in both axes)
          infinite: false,
          // @method wrapLatLng(latlng: LatLng): LatLng
          // Returns a `LatLng` where lat and lng has been wrapped according to the
          // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
          wrapLatLng: function(latlng) {
            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
            return new LatLng(lat, lng, alt);
          },
          // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
          // Returns a `LatLngBounds` with the same size as the given one, ensuring
          // that its center is within the CRS's bounds.
          // Only accepts actual `L.LatLngBounds` instances, not arrays.
          wrapLatLngBounds: function(bounds) {
            var center2 = bounds.getCenter(), newCenter = this.wrapLatLng(center2), latShift = center2.lat - newCenter.lat, lngShift = center2.lng - newCenter.lng;
            if (latShift === 0 && lngShift === 0) {
              return bounds;
            }
            var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
            return new LatLngBounds(newSw, newNe);
          }
        };
        var Earth = extend({}, CRS, {
          wrapLng: [-180, 180],
          // Mean Earth Radius, as recommended for use by
          // the International Union of Geodesy and Geophysics,
          // see https://rosettacode.org/wiki/Haversine_formula
          R: 6371e3,
          // distance between two geographical points using spherical law of cosines approximation
          distance: function(latlng1, latlng2) {
            var rad2 = Math.PI / 180, lat1 = latlng1.lat * rad2, lat2 = latlng2.lat * rad2, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad2 / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad2 / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return this.R * c;
          }
        });
        var earthRadius2 = 6378137;
        var SphericalMercator = {
          R: earthRadius2,
          MAX_LATITUDE: 85.0511287798,
          project: function(latlng) {
            var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin2 = Math.sin(lat * d);
            return new Point(
              this.R * latlng.lng * d,
              this.R * Math.log((1 + sin2) / (1 - sin2)) / 2
            );
          },
          unproject: function(point2) {
            var d = 180 / Math.PI;
            return new LatLng(
              (2 * Math.atan(Math.exp(point2.y / this.R)) - Math.PI / 2) * d,
              point2.x * d / this.R
            );
          },
          bounds: function() {
            var d = earthRadius2 * Math.PI;
            return new Bounds([-d, -d], [d, d]);
          }()
        };
        function Transformation(a, b, c, d) {
          if (isArray(a)) {
            this._a = a[0];
            this._b = a[1];
            this._c = a[2];
            this._d = a[3];
            return;
          }
          this._a = a;
          this._b = b;
          this._c = c;
          this._d = d;
        }
        Transformation.prototype = {
          // @method transform(point: Point, scale?: Number): Point
          // Returns a transformed point, optionally multiplied by the given scale.
          // Only accepts actual `L.Point` instances, not arrays.
          transform: function(point2, scale2) {
            return this._transform(point2.clone(), scale2);
          },
          // destructive transform (faster)
          _transform: function(point2, scale2) {
            scale2 = scale2 || 1;
            point2.x = scale2 * (this._a * point2.x + this._b);
            point2.y = scale2 * (this._c * point2.y + this._d);
            return point2;
          },
          // @method untransform(point: Point, scale?: Number): Point
          // Returns the reverse transformation of the given point, optionally divided
          // by the given scale. Only accepts actual `L.Point` instances, not arrays.
          untransform: function(point2, scale2) {
            scale2 = scale2 || 1;
            return new Point(
              (point2.x / scale2 - this._b) / this._a,
              (point2.y / scale2 - this._d) / this._c
            );
          }
        };
        function toTransformation(a, b, c, d) {
          return new Transformation(a, b, c, d);
        }
        var EPSG3857 = extend({}, Earth, {
          code: "EPSG:3857",
          projection: SphericalMercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG900913 = extend({}, EPSG3857, {
          code: "EPSG:900913"
        });
        function svgCreate(name) {
          return document.createElementNS("http://www.w3.org/2000/svg", name);
        }
        function pointsToPath(rings, closed) {
          var str = "", i, j, len, len2, points, p;
          for (i = 0, len = rings.length; i < len; i++) {
            points = rings[i];
            for (j = 0, len2 = points.length; j < len2; j++) {
              p = points[j];
              str += (j ? "L" : "M") + p.x + " " + p.y;
            }
            str += closed ? Browser.svg ? "z" : "x" : "";
          }
          return str || "M0 0";
        }
        var style = document.documentElement.style;
        var ie = "ActiveXObject" in window;
        var ielt9 = ie && !document.addEventListener;
        var edge = "msLaunchUri" in navigator && !("documentMode" in document);
        var webkit = userAgentContains("webkit");
        var android = userAgentContains("android");
        var android23 = userAgentContains("android 2") || userAgentContains("android 3");
        var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
        var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
        var opera = !!window.opera;
        var chrome = !edge && userAgentContains("chrome");
        var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
        var safari = !chrome && userAgentContains("safari");
        var phantom = userAgentContains("phantom");
        var opera12 = "OTransition" in style;
        var win = navigator.platform.indexOf("Win") === 0;
        var ie3d = ie && "transition" in style;
        var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
        var gecko3d = "MozPerspective" in style;
        var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
        var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
        var mobileWebkit = mobile && webkit;
        var mobileWebkit3d = mobile && webkit3d;
        var msPointer = !window.PointerEvent && window.MSPointerEvent;
        var pointer = !!(window.PointerEvent || msPointer);
        var touchNative = "ontouchstart" in window || !!window.TouchEvent;
        var touch = !window.L_NO_TOUCH && (touchNative || pointer);
        var mobileOpera = mobile && opera;
        var mobileGecko = mobile && gecko;
        var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
        var passiveEvents = function() {
          var supportsPassiveOption = false;
          try {
            var opts = Object.defineProperty({}, "passive", {
              get: function() {
                supportsPassiveOption = true;
              }
            });
            window.addEventListener("testPassiveEventSupport", falseFn, opts);
            window.removeEventListener("testPassiveEventSupport", falseFn, opts);
          } catch (e) {
          }
          return supportsPassiveOption;
        }();
        var canvas$1 = function() {
          return !!document.createElement("canvas").getContext;
        }();
        var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
        var inlineSvg = !!svg$1 && function() {
          var div = document.createElement("div");
          div.innerHTML = "<svg/>";
          return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
        }();
        var vml = !svg$1 && function() {
          try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
          } catch (e) {
            return false;
          }
        }();
        var mac = navigator.platform.indexOf("Mac") === 0;
        var linux = navigator.platform.indexOf("Linux") === 0;
        function userAgentContains(str) {
          return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
        }
        var Browser = {
          ie,
          ielt9,
          edge,
          webkit,
          android,
          android23,
          androidStock,
          opera,
          chrome,
          gecko,
          safari,
          phantom,
          opera12,
          win,
          ie3d,
          webkit3d,
          gecko3d,
          any3d,
          mobile,
          mobileWebkit,
          mobileWebkit3d,
          msPointer,
          pointer,
          touch,
          touchNative,
          mobileOpera,
          mobileGecko,
          retina,
          passiveEvents,
          canvas: canvas$1,
          svg: svg$1,
          vml,
          inlineSvg,
          mac,
          linux
        };
        var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
        var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
        var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
        var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
        var pEvent = {
          touchstart: POINTER_DOWN,
          touchmove: POINTER_MOVE,
          touchend: POINTER_UP,
          touchcancel: POINTER_CANCEL
        };
        var handle = {
          touchstart: _onPointerStart,
          touchmove: _handlePointer,
          touchend: _handlePointer,
          touchcancel: _handlePointer
        };
        var _pointers = {};
        var _pointerDocListener = false;
        function addPointerListener(obj, type, handler) {
          if (type === "touchstart") {
            _addPointerDocListener();
          }
          if (!handle[type]) {
            console.warn("wrong event specified:", type);
            return falseFn;
          }
          handler = handle[type].bind(this, handler);
          obj.addEventListener(pEvent[type], handler, false);
          return handler;
        }
        function removePointerListener(obj, type, handler) {
          if (!pEvent[type]) {
            console.warn("wrong event specified:", type);
            return;
          }
          obj.removeEventListener(pEvent[type], handler, false);
        }
        function _globalPointerDown(e) {
          _pointers[e.pointerId] = e;
        }
        function _globalPointerMove(e) {
          if (_pointers[e.pointerId]) {
            _pointers[e.pointerId] = e;
          }
        }
        function _globalPointerUp(e) {
          delete _pointers[e.pointerId];
        }
        function _addPointerDocListener() {
          if (!_pointerDocListener) {
            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
            document.addEventListener(POINTER_UP, _globalPointerUp, true);
            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
            _pointerDocListener = true;
          }
        }
        function _handlePointer(handler, e) {
          if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
            return;
          }
          e.touches = [];
          for (var i in _pointers) {
            e.touches.push(_pointers[i]);
          }
          e.changedTouches = [e];
          handler(e);
        }
        function _onPointerStart(handler, e) {
          if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
            preventDefault(e);
          }
          _handlePointer(handler, e);
        }
        function makeDblclick(event) {
          var newEvent = {}, prop, i;
          for (i in event) {
            prop = event[i];
            newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
          }
          event = newEvent;
          newEvent.type = "dblclick";
          newEvent.detail = 2;
          newEvent.isTrusted = false;
          newEvent._simulated = true;
          return newEvent;
        }
        var delay = 200;
        function addDoubleTapListener(obj, handler) {
          obj.addEventListener("dblclick", handler);
          var last = 0, detail;
          function simDblclick(e) {
            if (e.detail !== 1) {
              detail = e.detail;
              return;
            }
            if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
              return;
            }
            var path = getPropagationPath(e);
            if (path.some(function(el) {
              return el instanceof HTMLLabelElement && el.attributes.for;
            }) && !path.some(function(el) {
              return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
            })) {
              return;
            }
            var now = Date.now();
            if (now - last <= delay) {
              detail++;
              if (detail === 2) {
                handler(makeDblclick(e));
              }
            } else {
              detail = 1;
            }
            last = now;
          }
          obj.addEventListener("click", simDblclick);
          return {
            dblclick: handler,
            simDblclick
          };
        }
        function removeDoubleTapListener(obj, handlers) {
          obj.removeEventListener("dblclick", handlers.dblclick);
          obj.removeEventListener("click", handlers.simDblclick);
        }
        var TRANSFORM = testProp(
          ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
        );
        var TRANSITION = testProp(
          ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
        );
        var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
        function get(id) {
          return typeof id === "string" ? document.getElementById(id) : id;
        }
        function getStyle(el, style2) {
          var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
          if ((!value || value === "auto") && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style2] : null;
          }
          return value === "auto" ? null : value;
        }
        function create$1(tagName, className, container) {
          var el = document.createElement(tagName);
          el.className = className || "";
          if (container) {
            container.appendChild(el);
          }
          return el;
        }
        function remove(el) {
          var parent = el.parentNode;
          if (parent) {
            parent.removeChild(el);
          }
        }
        function empty(el) {
          while (el.firstChild) {
            el.removeChild(el.firstChild);
          }
        }
        function toFront(el) {
          var parent = el.parentNode;
          if (parent && parent.lastChild !== el) {
            parent.appendChild(el);
          }
        }
        function toBack(el) {
          var parent = el.parentNode;
          if (parent && parent.firstChild !== el) {
            parent.insertBefore(el, parent.firstChild);
          }
        }
        function hasClass(el, name) {
          if (el.classList !== void 0) {
            return el.classList.contains(name);
          }
          var className = getClass(el);
          return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        }
        function addClass(el, name) {
          if (el.classList !== void 0) {
            var classes = splitWords(name);
            for (var i = 0, len = classes.length; i < len; i++) {
              el.classList.add(classes[i]);
            }
          } else if (!hasClass(el, name)) {
            var className = getClass(el);
            setClass(el, (className ? className + " " : "") + name);
          }
        }
        function removeClass(el, name) {
          if (el.classList !== void 0) {
            el.classList.remove(name);
          } else {
            setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
          }
        }
        function setClass(el, name) {
          if (el.className.baseVal === void 0) {
            el.className = name;
          } else {
            el.className.baseVal = name;
          }
        }
        function getClass(el) {
          if (el.correspondingElement) {
            el = el.correspondingElement;
          }
          return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
        }
        function setOpacity(el, value) {
          if ("opacity" in el.style) {
            el.style.opacity = value;
          } else if ("filter" in el.style) {
            _setOpacityIE(el, value);
          }
        }
        function _setOpacityIE(el, value) {
          var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
          try {
            filter = el.filters.item(filterName);
          } catch (e) {
            if (value === 1) {
              return;
            }
          }
          value = Math.round(value * 100);
          if (filter) {
            filter.Enabled = value !== 100;
            filter.Opacity = value;
          } else {
            el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
          }
        }
        function testProp(props) {
          var style2 = document.documentElement.style;
          for (var i = 0; i < props.length; i++) {
            if (props[i] in style2) {
              return props[i];
            }
          }
          return false;
        }
        function setTransform(el, offset, scale2) {
          var pos = offset || new Point(0, 0);
          el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
        }
        function setPosition(el, point2) {
          el._leaflet_pos = point2;
          if (Browser.any3d) {
            setTransform(el, point2);
          } else {
            el.style.left = point2.x + "px";
            el.style.top = point2.y + "px";
          }
        }
        function getPosition(el) {
          return el._leaflet_pos || new Point(0, 0);
        }
        var disableTextSelection;
        var enableTextSelection;
        var _userSelect;
        if ("onselectstart" in document) {
          disableTextSelection = function() {
            on(window, "selectstart", preventDefault);
          };
          enableTextSelection = function() {
            off(window, "selectstart", preventDefault);
          };
        } else {
          var userSelectProperty = testProp(
            ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
          );
          disableTextSelection = function() {
            if (userSelectProperty) {
              var style2 = document.documentElement.style;
              _userSelect = style2[userSelectProperty];
              style2[userSelectProperty] = "none";
            }
          };
          enableTextSelection = function() {
            if (userSelectProperty) {
              document.documentElement.style[userSelectProperty] = _userSelect;
              _userSelect = void 0;
            }
          };
        }
        function disableImageDrag() {
          on(window, "dragstart", preventDefault);
        }
        function enableImageDrag() {
          off(window, "dragstart", preventDefault);
        }
        var _outlineElement, _outlineStyle;
        function preventOutline(element) {
          while (element.tabIndex === -1) {
            element = element.parentNode;
          }
          if (!element.style) {
            return;
          }
          restoreOutline();
          _outlineElement = element;
          _outlineStyle = element.style.outlineStyle;
          element.style.outlineStyle = "none";
          on(window, "keydown", restoreOutline);
        }
        function restoreOutline() {
          if (!_outlineElement) {
            return;
          }
          _outlineElement.style.outlineStyle = _outlineStyle;
          _outlineElement = void 0;
          _outlineStyle = void 0;
          off(window, "keydown", restoreOutline);
        }
        function getSizedParentNode(element) {
          do {
            element = element.parentNode;
          } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
          return element;
        }
        function getScale(element) {
          var rect = element.getBoundingClientRect();
          return {
            x: rect.width / element.offsetWidth || 1,
            y: rect.height / element.offsetHeight || 1,
            boundingClientRect: rect
          };
        }
        var DomUtil = {
          __proto__: null,
          TRANSFORM,
          TRANSITION,
          TRANSITION_END,
          get,
          getStyle,
          create: create$1,
          remove,
          empty,
          toFront,
          toBack,
          hasClass,
          addClass,
          removeClass,
          setClass,
          getClass,
          setOpacity,
          testProp,
          setTransform,
          setPosition,
          getPosition,
          get disableTextSelection() {
            return disableTextSelection;
          },
          get enableTextSelection() {
            return enableTextSelection;
          },
          disableImageDrag,
          enableImageDrag,
          preventOutline,
          restoreOutline,
          getSizedParentNode,
          getScale
        };
        function on(obj, types, fn, context) {
          if (types && typeof types === "object") {
            for (var type in types) {
              addOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              addOne(obj, types[i], fn, context);
            }
          }
          return this;
        }
        var eventsKey = "_leaflet_events";
        function off(obj, types, fn, context) {
          if (arguments.length === 1) {
            batchRemove(obj);
            delete obj[eventsKey];
          } else if (types && typeof types === "object") {
            for (var type in types) {
              removeOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            if (arguments.length === 2) {
              batchRemove(obj, function(type2) {
                return indexOf(types, type2) !== -1;
              });
            } else {
              for (var i = 0, len = types.length; i < len; i++) {
                removeOne(obj, types[i], fn, context);
              }
            }
          }
          return this;
        }
        function batchRemove(obj, filterFn) {
          for (var id in obj[eventsKey]) {
            var type = id.split(/\d/)[0];
            if (!filterFn || filterFn(type)) {
              removeOne(obj, type, null, null, id);
            }
          }
        }
        var mouseSubst = {
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          wheel: !("onwheel" in window) && "mousewheel"
        };
        function addOne(obj, type, fn, context) {
          var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
          if (obj[eventsKey] && obj[eventsKey][id]) {
            return this;
          }
          var handler = function(e) {
            return fn.call(context || obj, e || window.event);
          };
          var originalHandler = handler;
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            handler = addPointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            handler = addDoubleTapListener(obj, handler);
          } else if ("addEventListener" in obj) {
            if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
              obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
            } else if (type === "mouseenter" || type === "mouseleave") {
              handler = function(e) {
                e = e || window.event;
                if (isExternalTarget(obj, e)) {
                  originalHandler(e);
                }
              };
              obj.addEventListener(mouseSubst[type], handler, false);
            } else {
              obj.addEventListener(type, originalHandler, false);
            }
          } else {
            obj.attachEvent("on" + type, handler);
          }
          obj[eventsKey] = obj[eventsKey] || {};
          obj[eventsKey][id] = handler;
        }
        function removeOne(obj, type, fn, context, id) {
          id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
          var handler = obj[eventsKey] && obj[eventsKey][id];
          if (!handler) {
            return this;
          }
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            removePointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            removeDoubleTapListener(obj, handler);
          } else if ("removeEventListener" in obj) {
            obj.removeEventListener(mouseSubst[type] || type, handler, false);
          } else {
            obj.detachEvent("on" + type, handler);
          }
          obj[eventsKey][id] = null;
        }
        function stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else if (e.originalEvent) {
            e.originalEvent._stopped = true;
          } else {
            e.cancelBubble = true;
          }
          return this;
        }
        function disableScrollPropagation(el) {
          addOne(el, "wheel", stopPropagation);
          return this;
        }
        function disableClickPropagation(el) {
          on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
          el["_leaflet_disable_click"] = true;
          return this;
        }
        function preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
          return this;
        }
        function stop(e) {
          preventDefault(e);
          stopPropagation(e);
          return this;
        }
        function getPropagationPath(ev) {
          if (ev.composedPath) {
            return ev.composedPath();
          }
          var path = [];
          var el = ev.target;
          while (el) {
            path.push(el);
            el = el.parentNode;
          }
          return path;
        }
        function getMousePosition(e, container) {
          if (!container) {
            return new Point(e.clientX, e.clientY);
          }
          var scale2 = getScale(container), offset = scale2.boundingClientRect;
          return new Point(
            // offset.left/top values are in page scale (like clientX/Y),
            // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
            (e.clientX - offset.left) / scale2.x - container.clientLeft,
            (e.clientY - offset.top) / scale2.y - container.clientTop
          );
        }
        var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
        function getWheelDelta(e) {
          return Browser.edge ? e.wheelDeltaY / 2 : (
            // Don't trust window-geometry-based delta
            e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : (
              // Pixels
              e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : (
                // Lines
                e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : (
                  // Pages
                  e.deltaX || e.deltaZ ? 0 : (
                    // Skip horizontal/depth wheel events
                    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : (
                      // Legacy IE pixels
                      e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : (
                        // Legacy Moz lines
                        e.detail ? e.detail / -32765 * 60 : (
                          // Legacy Moz pages
                          0
                        )
                      )
                    )
                  )
                )
              )
            )
          );
        }
        function isExternalTarget(el, e) {
          var related = e.relatedTarget;
          if (!related) {
            return true;
          }
          try {
            while (related && related !== el) {
              related = related.parentNode;
            }
          } catch (err) {
            return false;
          }
          return related !== el;
        }
        var DomEvent = {
          __proto__: null,
          on,
          off,
          stopPropagation,
          disableScrollPropagation,
          disableClickPropagation,
          preventDefault,
          stop,
          getPropagationPath,
          getMousePosition,
          getWheelDelta,
          isExternalTarget,
          addListener: on,
          removeListener: off
        };
        var PosAnimation = Evented.extend({
          // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
          // Run an animation of a given element to a new position, optionally setting
          // duration in seconds (`0.25` by default) and easing linearity factor (3rd
          // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
          // `0.5` by default).
          run: function(el, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
            this._startPos = getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +/* @__PURE__ */ new Date();
            this.fire("start");
            this._animate();
          },
          // @method stop()
          // Stops the animation (if currently running).
          stop: function() {
            if (!this._inProgress) {
              return;
            }
            this._step(true);
            this._complete();
          },
          _animate: function() {
            this._animId = requestAnimFrame(this._animate, this);
            this._step();
          },
          _step: function(round2) {
            var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
            if (elapsed < duration) {
              this._runFrame(this._easeOut(elapsed / duration), round2);
            } else {
              this._runFrame(1);
              this._complete();
            }
          },
          _runFrame: function(progress, round2) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round2) {
              pos._round();
            }
            setPosition(this._el, pos);
            this.fire("step");
          },
          _complete: function() {
            cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
          },
          _easeOut: function(t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
          }
        });
        var Map2 = Evented.extend({
          options: {
            // @section Map State Options
            // @option crs: CRS = L.CRS.EPSG3857
            // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
            // sure what it means.
            crs: EPSG3857,
            // @option center: LatLng = undefined
            // Initial geographic center of the map
            center: void 0,
            // @option zoom: Number = undefined
            // Initial map zoom level
            zoom: void 0,
            // @option minZoom: Number = *
            // Minimum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the lowest of their `minZoom` options will be used instead.
            minZoom: void 0,
            // @option maxZoom: Number = *
            // Maximum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the highest of their `maxZoom` options will be used instead.
            maxZoom: void 0,
            // @option layers: Layer[] = []
            // Array of layers that will be added to the map initially
            layers: [],
            // @option maxBounds: LatLngBounds = null
            // When this option is set, the map restricts the view to the given
            // geographical bounds, bouncing the user back if the user tries to pan
            // outside the view. To set the restriction dynamically, use
            // [`setMaxBounds`](#map-setmaxbounds) method.
            maxBounds: void 0,
            // @option renderer: Renderer = *
            // The default method for drawing vector layers on the map. `L.SVG`
            // or `L.Canvas` by default depending on browser support.
            renderer: void 0,
            // @section Animation Options
            // @option zoomAnimation: Boolean = true
            // Whether the map zoom animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            zoomAnimation: true,
            // @option zoomAnimationThreshold: Number = 4
            // Won't animate zoom if the zoom difference exceeds this value.
            zoomAnimationThreshold: 4,
            // @option fadeAnimation: Boolean = true
            // Whether the tile fade animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            fadeAnimation: true,
            // @option markerZoomAnimation: Boolean = true
            // Whether markers animate their zoom with the zoom animation, if disabled
            // they will disappear for the length of the animation. By default it's
            // enabled in all browsers that support CSS3 Transitions except Android.
            markerZoomAnimation: true,
            // @option transform3DLimit: Number = 2^23
            // Defines the maximum size of a CSS translation transform. The default
            // value should not be changed unless a web browser positions layers in
            // the wrong place after doing a large `panBy`.
            transform3DLimit: 8388608,
            // Precision limit of a 32-bit float
            // @section Interaction Options
            // @option zoomSnap: Number = 1
            // Forces the map's zoom level to always be a multiple of this, particularly
            // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
            // By default, the zoom level snaps to the nearest integer; lower values
            // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
            // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
            zoomSnap: 1,
            // @option zoomDelta: Number = 1
            // Controls how much the map's zoom level will change after a
            // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
            // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
            // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
            zoomDelta: 1,
            // @option trackResize: Boolean = true
            // Whether the map automatically handles browser window resize to update itself.
            trackResize: true
          },
          initialize: function(id, options) {
            options = setOptions(this, options);
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;
            this._initContainer(id);
            this._initLayout();
            this._onResize = bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) {
              this.setMaxBounds(options.maxBounds);
            }
            if (options.zoom !== void 0) {
              this._zoom = this._limitZoom(options.zoom);
            }
            if (options.center && options.zoom !== void 0) {
              this.setView(toLatLng(options.center), options.zoom, { reset: true });
            }
            this.callInitHooks();
            this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
            if (this._zoomAnimated) {
              this._createAnimProxy();
              on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
            }
            this._addLayers(this.options.layers);
          },
          // @section Methods for modifying map state
          // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
          // Sets the view of the map (geographical center and zoom) with the given
          // animation options.
          setView: function(center2, zoom2, options) {
            zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
            center2 = this._limitCenter(toLatLng(center2), zoom2, this.options.maxBounds);
            options = options || {};
            this._stop();
            if (this._loaded && !options.reset && options !== true) {
              if (options.animate !== void 0) {
                options.zoom = extend({ animate: options.animate }, options.zoom);
                options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
              }
              var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center2, zoom2, options.zoom) : this._tryAnimatedPan(center2, options.pan);
              if (moved) {
                clearTimeout(this._sizeTimer);
                return this;
              }
            }
            this._resetView(center2, zoom2, options.pan && options.pan.noMoveStart);
            return this;
          },
          // @method setZoom(zoom: Number, options?: Zoom/pan options): this
          // Sets the zoom of the map.
          setZoom: function(zoom2, options) {
            if (!this._loaded) {
              this._zoom = zoom2;
              return this;
            }
            return this.setView(this.getCenter(), zoom2, { zoom: options });
          },
          // @method zoomIn(delta?: Number, options?: Zoom options): this
          // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
          zoomIn: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
          },
          // @method zoomOut(delta?: Number, options?: Zoom options): this
          // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
          zoomOut: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
          },
          // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
          // Zooms the map while keeping a specified geographical point on the map
          // stationary (e.g. used internally for scroll zoom and double-click zoom).
          // @alternative
          // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
          // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
          setZoomAround: function(latlng, zoom2, options) {
            var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom2, { zoom: options });
          },
          _getBoundsCenterZoom: function(bounds, options) {
            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
            zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
            if (zoom2 === Infinity) {
              return {
                center: bounds.getCenter(),
                zoom: zoom2
              };
            }
            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center2 = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
            return {
              center: center2,
              zoom: zoom2
            };
          },
          // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
          // Sets a map view that contains the given geographical bounds with the
          // maximum zoom level possible.
          fitBounds: function(bounds, options) {
            bounds = toLatLngBounds(bounds);
            if (!bounds.isValid()) {
              throw new Error("Bounds are not valid.");
            }
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.setView(target.center, target.zoom, options);
          },
          // @method fitWorld(options?: fitBounds options): this
          // Sets a map view that mostly contains the whole world with the maximum
          // zoom level possible.
          fitWorld: function(options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
          },
          // @method panTo(latlng: LatLng, options?: Pan options): this
          // Pans the map to a given center.
          panTo: function(center2, options) {
            return this.setView(center2, this._zoom, { pan: options });
          },
          // @method panBy(offset: Point, options?: Pan options): this
          // Pans the map by a given number of pixels (animated).
          panBy: function(offset, options) {
            offset = toPoint(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) {
              return this.fire("moveend");
            }
            if (options.animate !== true && !this.getSize().contains(offset)) {
              this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
              return this;
            }
            if (!this._panAnim) {
              this._panAnim = new PosAnimation();
              this._panAnim.on({
                "step": this._onPanTransitionStep,
                "end": this._onPanTransitionEnd
              }, this);
            }
            if (!options.noMoveStart) {
              this.fire("movestart");
            }
            if (options.animate !== false) {
              addClass(this._mapPane, "leaflet-pan-anim");
              var newPos = this._getMapPanePos().subtract(offset).round();
              this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
              this._rawPanBy(offset);
              this.fire("move").fire("moveend");
            }
            return this;
          },
          // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
          // Sets the view of the map (geographical center and zoom) performing a smooth
          // pan-zoom animation.
          flyTo: function(targetCenter, targetZoom, options) {
            options = options || {};
            if (options.animate === false || !Browser.any3d) {
              return this.setView(targetCenter, targetZoom, options);
            }
            this._stop();
            var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
            targetCenter = toLatLng(targetCenter);
            targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
            function r(i) {
              var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
              var log2 = sq < 1e-9 ? -18 : Math.log(sq);
              return log2;
            }
            function sinh(n) {
              return (Math.exp(n) - Math.exp(-n)) / 2;
            }
            function cosh(n) {
              return (Math.exp(n) + Math.exp(-n)) / 2;
            }
            function tanh(n) {
              return sinh(n) / cosh(n);
            }
            var r0 = r(0);
            function w(s) {
              return w0 * (cosh(r0) / cosh(r0 + rho * s));
            }
            function u(s) {
              return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
            }
            function easeOut(t) {
              return 1 - Math.pow(1 - t, 1.5);
            }
            var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
            function frame() {
              var t = (Date.now() - start) / duration, s = easeOut(t) * S;
              if (t <= 1) {
                this._flyToFrame = requestAnimFrame(frame, this);
                this._move(
                  this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
                  this.getScaleZoom(w0 / w(s), startZoom),
                  { flyTo: true }
                );
              } else {
                this._move(targetCenter, targetZoom)._moveEnd(true);
              }
            }
            this._moveStart(true, options.noMoveStart);
            frame.call(this);
            return this;
          },
          // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
          // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
          // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
          flyToBounds: function(bounds, options) {
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.flyTo(target.center, target.zoom, options);
          },
          // @method setMaxBounds(bounds: LatLngBounds): this
          // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
          setMaxBounds: function(bounds) {
            bounds = toLatLngBounds(bounds);
            if (this.listens("moveend", this._panInsideMaxBounds)) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (!bounds.isValid()) {
              this.options.maxBounds = null;
              return this;
            }
            this.options.maxBounds = bounds;
            if (this._loaded) {
              this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds);
          },
          // @method setMinZoom(zoom: Number): this
          // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
          setMinZoom: function(zoom2) {
            var oldZoom = this.options.minZoom;
            this.options.minZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() < this.options.minZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          // @method setMaxZoom(zoom: Number): this
          // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
          setMaxZoom: function(zoom2) {
            var oldZoom = this.options.maxZoom;
            this.options.maxZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() > this.options.maxZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
          // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
          panInsideBounds: function(bounds, options) {
            this._enforcingBounds = true;
            var center2 = this.getCenter(), newCenter = this._limitCenter(center2, this._zoom, toLatLngBounds(bounds));
            if (!center2.equals(newCenter)) {
              this.panTo(newCenter, options);
            }
            this._enforcingBounds = false;
            return this;
          },
          // @method panInside(latlng: LatLng, options?: padding options): this
          // Pans the map the minimum amount to make the `latlng` visible. Use
          // padding options to fit the display to more restricted bounds.
          // If `latlng` is already within the (optionally padded) display bounds,
          // the map will not be panned.
          panInside: function(latlng, options) {
            options = options || {};
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
            if (!paddedBounds.contains(pixelPoint)) {
              this._enforcingBounds = true;
              var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
              var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
              pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
              pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
              this.panTo(this.unproject(pixelCenter), options);
              this._enforcingBounds = false;
            }
            return this;
          },
          // @method invalidateSize(options: Zoom/pan options): this
          // Checks if the map container size changed and updates the map if so —
          // call it after you've changed the map size dynamically, also animating
          // pan by default. If `options.pan` is `false`, panning will not occur.
          // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
          // that it doesn't happen often even if the method is called many
          // times in a row.
          // @alternative
          // @method invalidateSize(animate: Boolean): this
          // Checks if the map container size changed and updates the map if so —
          // call it after you've changed the map size dynamically, also animating
          // pan by default.
          invalidateSize: function(options) {
            if (!this._loaded) {
              return this;
            }
            options = extend({
              animate: false,
              pan: true
            }, options === true ? { animate: true } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
              return this;
            }
            if (options.animate && options.pan) {
              this.panBy(offset);
            } else {
              if (options.pan) {
                this._rawPanBy(offset);
              }
              this.fire("move");
              if (options.debounceMoveend) {
                clearTimeout(this._sizeTimer);
                this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
              } else {
                this.fire("moveend");
              }
            }
            return this.fire("resize", {
              oldSize,
              newSize
            });
          },
          // @section Methods for modifying map state
          // @method stop(): this
          // Stops the currently running `panTo` or `flyTo` animation, if any.
          stop: function() {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
              this.fire("viewreset");
            }
            return this._stop();
          },
          // @section Geolocation methods
          // @method locate(options?: Locate options): this
          // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
          // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
          // and optionally sets the map view to the user's location with respect to
          // detection accuracy (or to the world view if geolocation failed).
          // Note that, if your page doesn't use HTTPS, this method will fail in
          // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
          // See `Locate options` for more details.
          locate: function(options) {
            options = this._locateOptions = extend({
              timeout: 1e4,
              watch: false
              // setView: false
              // maxZoom: <Number>
              // maximumAge: 0
              // enableHighAccuracy: false
            }, options);
            if (!("geolocation" in navigator)) {
              this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
              });
              return this;
            }
            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
            if (options.watch) {
              this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
              navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
          },
          // @method stopLocate(): this
          // Stops watching location previously initiated by `map.locate({watch: true})`
          // and aborts resetting the map view if map.locate was called with
          // `{setView: true}`.
          stopLocate: function() {
            if (navigator.geolocation && navigator.geolocation.clearWatch) {
              navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
              this._locateOptions.setView = false;
            }
            return this;
          },
          _handleGeolocationError: function(error) {
            if (!this._container._leaflet_id) {
              return;
            }
            var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
              this.fitWorld();
            }
            this.fire("locationerror", {
              code: c,
              message: "Geolocation error: " + message + "."
            });
          },
          _handleGeolocationResponse: function(pos) {
            if (!this._container._leaflet_id) {
              return;
            }
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
            if (options.setView) {
              var zoom2 = this.getBoundsZoom(bounds);
              this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
            }
            var data = {
              latlng,
              bounds,
              timestamp: pos.timestamp
            };
            for (var i in pos.coords) {
              if (typeof pos.coords[i] === "number") {
                data[i] = pos.coords[i];
              }
            }
            this.fire("locationfound", data);
          },
          // TODO Appropriate docs section?
          // @section Other Methods
          // @method addHandler(name: String, HandlerClass: Function): this
          // Adds a new `Handler` to the map, given its name and constructor function.
          addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
              return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
              handler.enable();
            }
            return this;
          },
          // @method remove(): this
          // Destroys the map and clears all related event listeners.
          remove: function() {
            this._initEvents(true);
            if (this.options.maxBounds) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (this._containerId !== this._container._leaflet_id) {
              throw new Error("Map container is being reused by another instance");
            }
            try {
              delete this._container._leaflet_id;
              delete this._containerId;
            } catch (e) {
              this._container._leaflet_id = void 0;
              this._containerId = void 0;
            }
            if (this._locationWatchId !== void 0) {
              this.stopLocate();
            }
            this._stop();
            remove(this._mapPane);
            if (this._clearControlPos) {
              this._clearControlPos();
            }
            if (this._resizeRequest) {
              cancelAnimFrame(this._resizeRequest);
              this._resizeRequest = null;
            }
            this._clearHandlers();
            if (this._loaded) {
              this.fire("unload");
            }
            var i;
            for (i in this._layers) {
              this._layers[i].remove();
            }
            for (i in this._panes) {
              remove(this._panes[i]);
            }
            this._layers = [];
            this._panes = [];
            delete this._mapPane;
            delete this._renderer;
            return this;
          },
          // @section Other Methods
          // @method createPane(name: String, container?: HTMLElement): HTMLElement
          // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
          // then returns it. The pane is created as a child of `container`, or
          // as a child of the main map pane if not set.
          createPane: function(name, container) {
            var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
            if (name) {
              this._panes[name] = pane;
            }
            return pane;
          },
          // @section Methods for Getting Map State
          // @method getCenter(): LatLng
          // Returns the geographical center of the map view
          getCenter: function() {
            this._checkIfLoaded();
            if (this._lastCenter && !this._moved()) {
              return this._lastCenter.clone();
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
          },
          // @method getZoom(): Number
          // Returns the current zoom level of the map view
          getZoom: function() {
            return this._zoom;
          },
          // @method getBounds(): LatLngBounds
          // Returns the geographical bounds visible in the current map view
          getBounds: function() {
            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
            return new LatLngBounds(sw, ne);
          },
          // @method getMinZoom(): Number
          // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
          getMinZoom: function() {
            return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
          },
          // @method getMaxZoom(): Number
          // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
          getMaxZoom: function() {
            return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
          },
          // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
          // Returns the maximum zoom level on which the given bounds fit to the map
          // view in its entirety. If `inside` (optional) is set to `true`, the method
          // instead returns the minimum zoom level on which the map view fits into
          // the given bounds in its entirety.
          getBoundsZoom: function(bounds, inside, padding) {
            bounds = toLatLngBounds(bounds);
            padding = toPoint(padding || [0, 0]);
            var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
            zoom2 = this.getScaleZoom(scale2, zoom2);
            if (snap) {
              zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
              zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          // @method getSize(): Point
          // Returns the current size of the map container (in pixels).
          getSize: function() {
            if (!this._size || this._sizeChanged) {
              this._size = new Point(
                this._container.clientWidth || 0,
                this._container.clientHeight || 0
              );
              this._sizeChanged = false;
            }
            return this._size.clone();
          },
          // @method getPixelBounds(): Bounds
          // Returns the bounds of the current map view in projected pixel
          // coordinates (sometimes useful in layer and overlay implementations).
          getPixelBounds: function(center2, zoom2) {
            var topLeftPoint = this._getTopLeftPoint(center2, zoom2);
            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
          },
          // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
          // the map pane? "left point of the map layer" can be confusing, specially
          // since there can be negative offsets.
          // @method getPixelOrigin(): Point
          // Returns the projected pixel coordinates of the top left point of
          // the map layer (useful in custom layer and overlay implementations).
          getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._pixelOrigin;
          },
          // @method getPixelWorldBounds(zoom?: Number): Bounds
          // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
          // If `zoom` is omitted, the map's current zoom level is used.
          getPixelWorldBounds: function(zoom2) {
            return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
          },
          // @section Other Methods
          // @method getPane(pane: String|HTMLElement): HTMLElement
          // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
          getPane: function(pane) {
            return typeof pane === "string" ? this._panes[pane] : pane;
          },
          // @method getPanes(): Object
          // Returns a plain object containing the names of all [panes](#map-pane) as keys and
          // the panes as values.
          getPanes: function() {
            return this._panes;
          },
          // @method getContainer: HTMLElement
          // Returns the HTML element that contains the map.
          getContainer: function() {
            return this._container;
          },
          // @section Conversion Methods
          // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
          // Returns the scale factor to be applied to a map transition from zoom level
          // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
          getZoomScale: function(toZoom, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
          },
          // @method getScaleZoom(scale: Number, fromZoom: Number): Number
          // Returns the zoom level that the map would end up at, if it is at `fromZoom`
          // level and everything is scaled by a factor of `scale`. Inverse of
          // [`getZoomScale`](#map-getZoomScale).
          getScaleZoom: function(scale2, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
            return isNaN(zoom2) ? Infinity : zoom2;
          },
          // @method project(latlng: LatLng, zoom: Number): Point
          // Projects a geographical coordinate `LatLng` according to the projection
          // of the map's CRS, then scales it according to `zoom` and the CRS's
          // `Transformation`. The result is pixel coordinate relative to
          // the CRS origin.
          project: function(latlng, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
          },
          // @method unproject(point: Point, zoom: Number): LatLng
          // Inverse of [`project`](#map-project).
          unproject: function(point2, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.pointToLatLng(toPoint(point2), zoom2);
          },
          // @method layerPointToLatLng(point: Point): LatLng
          // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
          // returns the corresponding geographical coordinate (for the current zoom level).
          layerPointToLatLng: function(point2) {
            var projectedPoint = toPoint(point2).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
          },
          // @method latLngToLayerPoint(latlng: LatLng): Point
          // Given a geographical coordinate, returns the corresponding pixel coordinate
          // relative to the [origin pixel](#map-getpixelorigin).
          latLngToLayerPoint: function(latlng) {
            var projectedPoint = this.project(toLatLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
          },
          // @method wrapLatLng(latlng: LatLng): LatLng
          // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
          // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
          // CRS's bounds.
          // By default this means longitude is wrapped around the dateline so its
          // value is between -180 and +180 degrees.
          wrapLatLng: function(latlng) {
            return this.options.crs.wrapLatLng(toLatLng(latlng));
          },
          // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
          // Returns a `LatLngBounds` with the same size as the given one, ensuring that
          // its center is within the CRS's bounds.
          // By default this means the center longitude is wrapped around the dateline so its
          // value is between -180 and +180 degrees, and the majority of the bounds
          // overlaps the CRS's bounds.
          wrapLatLngBounds: function(latlng) {
            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
          },
          // @method distance(latlng1: LatLng, latlng2: LatLng): Number
          // Returns the distance between two geographical coordinates according to
          // the map's CRS. By default this measures distance in meters.
          distance: function(latlng1, latlng2) {
            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
          },
          // @method containerPointToLayerPoint(point: Point): Point
          // Given a pixel coordinate relative to the map container, returns the corresponding
          // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
          containerPointToLayerPoint: function(point2) {
            return toPoint(point2).subtract(this._getMapPanePos());
          },
          // @method layerPointToContainerPoint(point: Point): Point
          // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
          // returns the corresponding pixel coordinate relative to the map container.
          layerPointToContainerPoint: function(point2) {
            return toPoint(point2).add(this._getMapPanePos());
          },
          // @method containerPointToLatLng(point: Point): LatLng
          // Given a pixel coordinate relative to the map container, returns
          // the corresponding geographical coordinate (for the current zoom level).
          containerPointToLatLng: function(point2) {
            var layerPoint = this.containerPointToLayerPoint(toPoint(point2));
            return this.layerPointToLatLng(layerPoint);
          },
          // @method latLngToContainerPoint(latlng: LatLng): Point
          // Given a geographical coordinate, returns the corresponding pixel coordinate
          // relative to the map container.
          latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
          },
          // @method mouseEventToContainerPoint(ev: MouseEvent): Point
          // Given a MouseEvent object, returns the pixel coordinate relative to the
          // map container where the event took place.
          mouseEventToContainerPoint: function(e) {
            return getMousePosition(e, this._container);
          },
          // @method mouseEventToLayerPoint(ev: MouseEvent): Point
          // Given a MouseEvent object, returns the pixel coordinate relative to
          // the [origin pixel](#map-getpixelorigin) where the event took place.
          mouseEventToLayerPoint: function(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
          },
          // @method mouseEventToLatLng(ev: MouseEvent): LatLng
          // Given a MouseEvent object, returns geographical coordinate where the
          // event took place.
          mouseEventToLatLng: function(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
          },
          // map initialization methods
          _initContainer: function(id) {
            var container = this._container = get(id);
            if (!container) {
              throw new Error("Map container not found.");
            } else if (container._leaflet_id) {
              throw new Error("Map container is already initialized.");
            }
            on(container, "scroll", this._onScroll, this);
            this._containerId = stamp(container);
          },
          _initLayout: function() {
            var container = this._container;
            this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
            addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var position = getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
              container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
              this._initControlPos();
            }
          },
          _initPanes: function() {
            var panes = this._panes = {};
            this._paneRenderers = {};
            this._mapPane = this.createPane("mapPane", this._container);
            setPosition(this._mapPane, new Point(0, 0));
            this.createPane("tilePane");
            this.createPane("overlayPane");
            this.createPane("shadowPane");
            this.createPane("markerPane");
            this.createPane("tooltipPane");
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
              addClass(panes.markerPane, "leaflet-zoom-hide");
              addClass(panes.shadowPane, "leaflet-zoom-hide");
            }
          },
          // private methods that modify map state
          // @section Map state change events
          _resetView: function(center2, zoom2, noMoveStart) {
            setPosition(this._mapPane, new Point(0, 0));
            var loading = !this._loaded;
            this._loaded = true;
            zoom2 = this._limitZoom(zoom2);
            this.fire("viewprereset");
            var zoomChanged = this._zoom !== zoom2;
            this._moveStart(zoomChanged, noMoveStart)._move(center2, zoom2)._moveEnd(zoomChanged);
            this.fire("viewreset");
            if (loading) {
              this.fire("load");
            }
          },
          _moveStart: function(zoomChanged, noMoveStart) {
            if (zoomChanged) {
              this.fire("zoomstart");
            }
            if (!noMoveStart) {
              this.fire("movestart");
            }
            return this;
          },
          _move: function(center2, zoom2, data, supressEvent) {
            if (zoom2 === void 0) {
              zoom2 = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom2;
            this._zoom = zoom2;
            this._lastCenter = center2;
            this._pixelOrigin = this._getNewPixelOrigin(center2);
            if (!supressEvent) {
              if (zoomChanged || data && data.pinch) {
                this.fire("zoom", data);
              }
              this.fire("move", data);
            } else if (data && data.pinch) {
              this.fire("zoom", data);
            }
            return this;
          },
          _moveEnd: function(zoomChanged) {
            if (zoomChanged) {
              this.fire("zoomend");
            }
            return this.fire("moveend");
          },
          _stop: function() {
            cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
              this._panAnim.stop();
            }
            return this;
          },
          _rawPanBy: function(offset) {
            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
          },
          _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
          },
          _panInsideMaxBounds: function() {
            if (!this._enforcingBounds) {
              this.panInsideBounds(this.options.maxBounds);
            }
          },
          _checkIfLoaded: function() {
            if (!this._loaded) {
              throw new Error("Set map center and zoom first.");
            }
          },
          // DOM event handling
          // @section Interaction events
          _initEvents: function(remove2) {
            this._targets = {};
            this._targets[stamp(this._container)] = this;
            var onOff = remove2 ? off : on;
            onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
            if (this.options.trackResize) {
              onOff(window, "resize", this._onResize, this);
            }
            if (Browser.any3d && this.options.transform3DLimit) {
              (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
            }
          },
          _onResize: function() {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = requestAnimFrame(
              function() {
                this.invalidateSize({ debounceMoveend: true });
              },
              this
            );
          },
          _onScroll: function() {
            this._container.scrollTop = 0;
            this._container.scrollLeft = 0;
          },
          _onMoveEnd: function() {
            var pos = this._getMapPanePos();
            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
              this._resetView(this.getCenter(), this.getZoom());
            }
          },
          _findEventTargets: function(e, type) {
            var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
            while (src) {
              target = this._targets[stamp(src)];
              if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
                dragging = true;
                break;
              }
              if (target && target.listens(type, true)) {
                if (isHover && !isExternalTarget(src, e)) {
                  break;
                }
                targets.push(target);
                if (isHover) {
                  break;
                }
              }
              if (src === this._container) {
                break;
              }
              src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
              targets = [this];
            }
            return targets;
          },
          _isClickDisabled: function(el) {
            while (el && el !== this._container) {
              if (el["_leaflet_disable_click"]) {
                return true;
              }
              el = el.parentNode;
            }
          },
          _handleDOMEvent: function(e) {
            var el = e.target || e.srcElement;
            if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
              return;
            }
            var type = e.type;
            if (type === "mousedown") {
              preventOutline(el);
            }
            this._fireDOMEvent(e, type);
          },
          _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
          _fireDOMEvent: function(e, type, canvasTargets) {
            if (e.type === "click") {
              var synth = extend({}, e);
              synth.type = "preclick";
              this._fireDOMEvent(synth, synth.type, canvasTargets);
            }
            var targets = this._findEventTargets(e, type);
            if (canvasTargets) {
              var filtered = [];
              for (var i = 0; i < canvasTargets.length; i++) {
                if (canvasTargets[i].listens(type, true)) {
                  filtered.push(canvasTargets[i]);
                }
              }
              targets = filtered.concat(targets);
            }
            if (!targets.length) {
              return;
            }
            if (type === "contextmenu") {
              preventDefault(e);
            }
            var target = targets[0];
            var data = {
              originalEvent: e
            };
            if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
              var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
              data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
              data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
              data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
            }
            for (i = 0; i < targets.length; i++) {
              targets[i].fire(type, data, true);
              if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
                return;
              }
            }
          },
          _draggableMoved: function(obj) {
            obj = obj.dragging && obj.dragging.enabled() ? obj : this;
            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
          },
          _clearHandlers: function() {
            for (var i = 0, len = this._handlers.length; i < len; i++) {
              this._handlers[i].disable();
            }
          },
          // @section Other Methods
          // @method whenReady(fn: Function, context?: Object): this
          // Runs the given function `fn` when the map gets initialized with
          // a view (center and zoom) and at least one layer, or immediately
          // if it's already initialized, optionally passing a function context.
          whenReady: function(callback, context) {
            if (this._loaded) {
              callback.call(context || this, { target: this });
            } else {
              this.on("load", callback, context);
            }
            return this;
          },
          // private methods for getting map state
          _getMapPanePos: function() {
            return getPosition(this._mapPane) || new Point(0, 0);
          },
          _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
          },
          _getTopLeftPoint: function(center2, zoom2) {
            var pixelOrigin = center2 && zoom2 !== void 0 ? this._getNewPixelOrigin(center2, zoom2) : this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
          },
          _getNewPixelOrigin: function(center2, zoom2) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center2, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
          },
          _latLngToNewLayerPoint: function(latlng, zoom2, center2) {
            var topLeft = this._getNewPixelOrigin(center2, zoom2);
            return this.project(latlng, zoom2)._subtract(topLeft);
          },
          _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center2) {
            var topLeft = this._getNewPixelOrigin(center2, zoom2);
            return toBounds([
              this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
            ]);
          },
          // layer point of the current center
          _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
          },
          // offset of the specified place to the current center in pixels
          _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
          },
          // adjust center for view to get inside bounds
          _limitCenter: function(center2, zoom2, bounds) {
            if (!bounds) {
              return center2;
            }
            var centerPoint = this.project(center2, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
            if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
              return center2;
            }
            return this.unproject(centerPoint.add(offset), zoom2);
          },
          // adjust offset for view to get inside bounds
          _limitOffset: function(offset, bounds) {
            if (!bounds) {
              return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds));
          },
          // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
          _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
            var projectedMaxBounds = toBounds(
              this.project(maxBounds.getNorthEast(), zoom2),
              this.project(maxBounds.getSouthWest(), zoom2)
            ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
            return new Point(dx, dy);
          },
          _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
          },
          _limitZoom: function(zoom2) {
            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
            if (snap) {
              zoom2 = Math.round(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          _onPanTransitionStep: function() {
            this.fire("move");
          },
          _onPanTransitionEnd: function() {
            removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
          },
          _tryAnimatedPan: function(center2, options) {
            var offset = this._getCenterOffset(center2)._trunc();
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
              return false;
            }
            this.panBy(offset, options);
            return true;
          },
          _createAnimProxy: function() {
            var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(proxy);
            this.on("zoomanim", function(e) {
              var prop = TRANSFORM, transform = this._proxy.style[prop];
              setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
              if (transform === this._proxy.style[prop] && this._animatingZoom) {
                this._onZoomTransitionEnd();
              }
            }, this);
            this.on("load moveend", this._animMoveEnd, this);
            this._on("unload", this._destroyAnimProxy, this);
          },
          _destroyAnimProxy: function() {
            remove(this._proxy);
            this.off("load moveend", this._animMoveEnd, this);
            delete this._proxy;
          },
          _animMoveEnd: function() {
            var c = this.getCenter(), z = this.getZoom();
            setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
          },
          _catchTransitionEnd: function(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
              this._onZoomTransitionEnd();
            }
          },
          _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
          },
          _tryAnimatedZoom: function(center2, zoom2, options) {
            if (this._animatingZoom) {
              return true;
            }
            options = options || {};
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
              return false;
            }
            var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center2)._divideBy(1 - 1 / scale2);
            if (options.animate !== true && !this.getSize().contains(offset)) {
              return false;
            }
            requestAnimFrame(function() {
              this._moveStart(true, options.noMoveStart || false)._animateZoom(center2, zoom2, true);
            }, this);
            return true;
          },
          _animateZoom: function(center2, zoom2, startAnim, noUpdate) {
            if (!this._mapPane) {
              return;
            }
            if (startAnim) {
              this._animatingZoom = true;
              this._animateToCenter = center2;
              this._animateToZoom = zoom2;
              addClass(this._mapPane, "leaflet-zoom-anim");
            }
            this.fire("zoomanim", {
              center: center2,
              zoom: zoom2,
              noUpdate
            });
            if (!this._tempFireZoomEvent) {
              this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
            }
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            setTimeout(bind(this._onZoomTransitionEnd, this), 250);
          },
          _onZoomTransitionEnd: function() {
            if (!this._animatingZoom) {
              return;
            }
            if (this._mapPane) {
              removeClass(this._mapPane, "leaflet-zoom-anim");
            }
            this._animatingZoom = false;
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            if (this._tempFireZoomEvent) {
              this.fire("zoom");
            }
            delete this._tempFireZoomEvent;
            this.fire("move");
            this._moveEnd(true);
          }
        });
        function createMap(id, options) {
          return new Map2(id, options);
        }
        var Control = Class.extend({
          // @section
          // @aka Control Options
          options: {
            // @option position: String = 'topright'
            // The position of the control (one of the map corners). Possible values are `'topleft'`,
            // `'topright'`, `'bottomleft'` or `'bottomright'`
            position: "topright"
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          /* @section
           * Classes extending L.Control will inherit the following methods:
           *
           * @method getPosition: string
           * Returns the position of the control.
           */
          getPosition: function() {
            return this.options.position;
          },
          // @method setPosition(position: string): this
          // Sets the position of the control.
          setPosition: function(position) {
            var map3 = this._map;
            if (map3) {
              map3.removeControl(this);
            }
            this.options.position = position;
            if (map3) {
              map3.addControl(this);
            }
            return this;
          },
          // @method getContainer: HTMLElement
          // Returns the HTMLElement that contains the control.
          getContainer: function() {
            return this._container;
          },
          // @method addTo(map: Map): this
          // Adds the control to the given map.
          addTo: function(map3) {
            this.remove();
            this._map = map3;
            var container = this._container = this.onAdd(map3), pos = this.getPosition(), corner = map3._controlCorners[pos];
            addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
              corner.insertBefore(container, corner.firstChild);
            } else {
              corner.appendChild(container);
            }
            this._map.on("unload", this.remove, this);
            return this;
          },
          // @method remove: this
          // Removes the control from the map it is currently active on.
          remove: function() {
            if (!this._map) {
              return this;
            }
            remove(this._container);
            if (this.onRemove) {
              this.onRemove(this._map);
            }
            this._map.off("unload", this.remove, this);
            this._map = null;
            return this;
          },
          _refocusOnMap: function(e) {
            if (this._map && e && e.screenX > 0 && e.screenY > 0) {
              this._map.getContainer().focus();
            }
          }
        });
        var control = function(options) {
          return new Control(options);
        };
        Map2.include({
          // @method addControl(control: Control): this
          // Adds the given control to the map
          addControl: function(control2) {
            control2.addTo(this);
            return this;
          },
          // @method removeControl(control: Control): this
          // Removes the given control from the map
          removeControl: function(control2) {
            control2.remove();
            return this;
          },
          _initControlPos: function() {
            var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
            function createCorner(vSide, hSide) {
              var className = l + vSide + " " + l + hSide;
              corners[vSide + hSide] = create$1("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
          },
          _clearControlPos: function() {
            for (var i in this._controlCorners) {
              remove(this._controlCorners[i]);
            }
            remove(this._controlContainer);
            delete this._controlCorners;
            delete this._controlContainer;
          }
        });
        var Layers = Control.extend({
          // @section
          // @aka Control.Layers options
          options: {
            // @option collapsed: Boolean = true
            // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
            collapsed: true,
            position: "topright",
            // @option autoZIndex: Boolean = true
            // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
            autoZIndex: true,
            // @option hideSingleBase: Boolean = false
            // If `true`, the base layers in the control will be hidden when there is only one.
            hideSingleBase: false,
            // @option sortLayers: Boolean = false
            // Whether to sort the layers. When `false`, layers will keep the order
            // in which they were added to the control.
            sortLayers: false,
            // @option sortFunction: Function = *
            // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
            // that will be used for sorting the layers, when `sortLayers` is `true`.
            // The function receives both the `L.Layer` instances and their names, as in
            // `sortFunction(layerA, layerB, nameA, nameB)`.
            // By default, it sorts layers alphabetically by their name.
            sortFunction: function(layerA, layerB, nameA, nameB) {
              return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
            }
          },
          initialize: function(baseLayers, overlays, options) {
            setOptions(this, options);
            this._layerControlInputs = [];
            this._layers = [];
            this._lastZIndex = 0;
            this._handlingClick = false;
            this._preventClick = false;
            for (var i in baseLayers) {
              this._addLayer(baseLayers[i], i);
            }
            for (i in overlays) {
              this._addLayer(overlays[i], i, true);
            }
          },
          onAdd: function(map3) {
            this._initLayout();
            this._update();
            this._map = map3;
            map3.on("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.on("add remove", this._onLayerChange, this);
            }
            return this._container;
          },
          addTo: function(map3) {
            Control.prototype.addTo.call(this, map3);
            return this._expandIfNotCollapsed();
          },
          onRemove: function() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.off("add remove", this._onLayerChange, this);
            }
          },
          // @method addBaseLayer(layer: Layer, name: String): this
          // Adds a base layer (radio button entry) with the given name to the control.
          addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            return this._map ? this._update() : this;
          },
          // @method addOverlay(layer: Layer, name: String): this
          // Adds an overlay (checkbox entry) with the given name to the control.
          addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            return this._map ? this._update() : this;
          },
          // @method removeLayer(layer: Layer): this
          // Remove the given layer from the control.
          removeLayer: function(layer) {
            layer.off("add remove", this._onLayerChange, this);
            var obj = this._getLayer(stamp(layer));
            if (obj) {
              this._layers.splice(this._layers.indexOf(obj), 1);
            }
            return this._map ? this._update() : this;
          },
          // @method expand(): this
          // Expand the control container if collapsed.
          expand: function() {
            addClass(this._container, "leaflet-control-layers-expanded");
            this._section.style.height = null;
            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            if (acceptableHeight < this._section.clientHeight) {
              addClass(this._section, "leaflet-control-layers-scrollbar");
              this._section.style.height = acceptableHeight + "px";
            } else {
              removeClass(this._section, "leaflet-control-layers-scrollbar");
            }
            this._checkDisabledLayers();
            return this;
          },
          // @method collapse(): this
          // Collapse the control container if expanded.
          collapse: function() {
            removeClass(this._container, "leaflet-control-layers-expanded");
            return this;
          },
          _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
            container.setAttribute("aria-haspopup", true);
            disableClickPropagation(container);
            disableScrollPropagation(container);
            var section = this._section = create$1("section", className + "-list");
            if (collapsed) {
              this._map.on("click", this.collapse, this);
              on(container, {
                mouseenter: this._expandSafely,
                mouseleave: this.collapse
              }, this);
            }
            var link2 = this._layersLink = create$1("a", className + "-toggle", container);
            link2.href = "#";
            link2.title = "Layers";
            link2.setAttribute("role", "button");
            on(link2, {
              keydown: function(e) {
                if (e.keyCode === 13) {
                  this._expandSafely();
                }
              },
              // Certain screen readers intercept the key event and instead send a click event
              click: function(e) {
                preventDefault(e);
                this._expandSafely();
              }
            }, this);
            if (!collapsed) {
              this.expand();
            }
            this._baseLayersList = create$1("div", className + "-base", section);
            this._separator = create$1("div", className + "-separator", section);
            this._overlaysList = create$1("div", className + "-overlays", section);
            container.appendChild(section);
          },
          _getLayer: function(id) {
            for (var i = 0; i < this._layers.length; i++) {
              if (this._layers[i] && stamp(this._layers[i].layer) === id) {
                return this._layers[i];
              }
            }
          },
          _addLayer: function(layer, name, overlay) {
            if (this._map) {
              layer.on("add remove", this._onLayerChange, this);
            }
            this._layers.push({
              layer,
              name,
              overlay
            });
            if (this.options.sortLayers) {
              this._layers.sort(bind(function(a, b) {
                return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
              }, this));
            }
            if (this.options.autoZIndex && layer.setZIndex) {
              this._lastZIndex++;
              layer.setZIndex(this._lastZIndex);
            }
            this._expandIfNotCollapsed();
          },
          _update: function() {
            if (!this._container) {
              return this;
            }
            empty(this._baseLayersList);
            empty(this._overlaysList);
            this._layerControlInputs = [];
            var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
            for (i = 0; i < this._layers.length; i++) {
              obj = this._layers[i];
              this._addItem(obj);
              overlaysPresent = overlaysPresent || obj.overlay;
              baseLayersPresent = baseLayersPresent || !obj.overlay;
              baseLayersCount += !obj.overlay ? 1 : 0;
            }
            if (this.options.hideSingleBase) {
              baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
              this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
            return this;
          },
          _onLayerChange: function(e) {
            if (!this._handlingClick) {
              this._update();
            }
            var obj = this._getLayer(stamp(e.target));
            var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
            if (type) {
              this._map.fire(type, obj);
            }
          },
          // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
          _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
          },
          _addItem: function(obj) {
            var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
            if (obj.overlay) {
              input = document.createElement("input");
              input.type = "checkbox";
              input.className = "leaflet-control-layers-selector";
              input.defaultChecked = checked;
            } else {
              input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
            }
            this._layerControlInputs.push(input);
            input.layerId = stamp(obj.layer);
            on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            var holder = document.createElement("span");
            label.appendChild(holder);
            holder.appendChild(input);
            holder.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            this._checkDisabledLayers();
            return label;
          },
          _onInputClick: function() {
            if (this._preventClick) {
              return;
            }
            var inputs = this._layerControlInputs, input, layer;
            var addedLayers = [], removedLayers = [];
            this._handlingClick = true;
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              if (input.checked) {
                addedLayers.push(layer);
              } else if (!input.checked) {
                removedLayers.push(layer);
              }
            }
            for (i = 0; i < removedLayers.length; i++) {
              if (this._map.hasLayer(removedLayers[i])) {
                this._map.removeLayer(removedLayers[i]);
              }
            }
            for (i = 0; i < addedLayers.length; i++) {
              if (!this._map.hasLayer(addedLayers[i])) {
                this._map.addLayer(addedLayers[i]);
              }
            }
            this._handlingClick = false;
            this._refocusOnMap();
          },
          _checkDisabledLayers: function() {
            var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
            }
          },
          _expandIfNotCollapsed: function() {
            if (this._map && !this.options.collapsed) {
              this.expand();
            }
            return this;
          },
          _expandSafely: function() {
            var section = this._section;
            this._preventClick = true;
            on(section, "click", preventDefault);
            this.expand();
            var that = this;
            setTimeout(function() {
              off(section, "click", preventDefault);
              that._preventClick = false;
            });
          }
        });
        var layers2 = function(baseLayers, overlays, options) {
          return new Layers(baseLayers, overlays, options);
        };
        var Zoom = Control.extend({
          // @section
          // @aka Control.Zoom options
          options: {
            position: "topleft",
            // @option zoomInText: String = '<span aria-hidden="true">+</span>'
            // The text set on the 'zoom in' button.
            zoomInText: '<span aria-hidden="true">+</span>',
            // @option zoomInTitle: String = 'Zoom in'
            // The title set on the 'zoom in' button.
            zoomInTitle: "Zoom in",
            // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
            // The text set on the 'zoom out' button.
            zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
            // @option zoomOutTitle: String = 'Zoom out'
            // The title set on the 'zoom out' button.
            zoomOutTitle: "Zoom out"
          },
          onAdd: function(map3) {
            var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
            this._zoomInButton = this._createButton(
              options.zoomInText,
              options.zoomInTitle,
              zoomName + "-in",
              container,
              this._zoomIn
            );
            this._zoomOutButton = this._createButton(
              options.zoomOutText,
              options.zoomOutTitle,
              zoomName + "-out",
              container,
              this._zoomOut
            );
            this._updateDisabled();
            map3.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
          },
          onRemove: function(map3) {
            map3.off("zoomend zoomlevelschange", this._updateDisabled, this);
          },
          disable: function() {
            this._disabled = true;
            this._updateDisabled();
            return this;
          },
          enable: function() {
            this._disabled = false;
            this._updateDisabled();
            return this;
          },
          _zoomIn: function(e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
              this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _zoomOut: function(e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
              this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _createButton: function(html, title, className, container, fn) {
            var link2 = create$1("a", className, container);
            link2.innerHTML = html;
            link2.href = "#";
            link2.title = title;
            link2.setAttribute("role", "button");
            link2.setAttribute("aria-label", title);
            disableClickPropagation(link2);
            on(link2, "click", stop);
            on(link2, "click", fn, this);
            on(link2, "click", this._refocusOnMap, this);
            return link2;
          },
          _updateDisabled: function() {
            var map3 = this._map, className = "leaflet-disabled";
            removeClass(this._zoomInButton, className);
            removeClass(this._zoomOutButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "false");
            this._zoomOutButton.setAttribute("aria-disabled", "false");
            if (this._disabled || map3._zoom === map3.getMinZoom()) {
              addClass(this._zoomOutButton, className);
              this._zoomOutButton.setAttribute("aria-disabled", "true");
            }
            if (this._disabled || map3._zoom === map3.getMaxZoom()) {
              addClass(this._zoomInButton, className);
              this._zoomInButton.setAttribute("aria-disabled", "true");
            }
          }
        });
        Map2.mergeOptions({
          zoomControl: true
        });
        Map2.addInitHook(function() {
          if (this.options.zoomControl) {
            this.zoomControl = new Zoom();
            this.addControl(this.zoomControl);
          }
        });
        var zoom = function(options) {
          return new Zoom(options);
        };
        var Scale = Control.extend({
          // @section
          // @aka Control.Scale options
          options: {
            position: "bottomleft",
            // @option maxWidth: Number = 100
            // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
            maxWidth: 100,
            // @option metric: Boolean = True
            // Whether to show the metric scale line (m/km).
            metric: true,
            // @option imperial: Boolean = True
            // Whether to show the imperial scale line (mi/ft).
            imperial: true
            // @option updateWhenIdle: Boolean = false
            // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
          },
          onAdd: function(map3) {
            var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
            this._addScales(options, className + "-line", container);
            map3.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map3.whenReady(this._update, this);
            return container;
          },
          onRemove: function(map3) {
            map3.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
          },
          _addScales: function(options, className, container) {
            if (options.metric) {
              this._mScale = create$1("div", className, container);
            }
            if (options.imperial) {
              this._iScale = create$1("div", className, container);
            }
          },
          _update: function() {
            var map3 = this._map, y2 = map3.getSize().y / 2;
            var maxMeters = map3.distance(
              map3.containerPointToLatLng([0, y2]),
              map3.containerPointToLatLng([this.options.maxWidth, y2])
            );
            this._updateScales(maxMeters);
          },
          _updateScales: function(maxMeters) {
            if (this.options.metric && maxMeters) {
              this._updateMetric(maxMeters);
            }
            if (this.options.imperial && maxMeters) {
              this._updateImperial(maxMeters);
            }
          },
          _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
            this._updateScale(this._mScale, label, meters / maxMeters);
          },
          _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
            if (maxFeet > 5280) {
              maxMiles = maxFeet / 5280;
              miles = this._getRoundNum(maxMiles);
              this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
            } else {
              feet = this._getRoundNum(maxFeet);
              this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
            }
          },
          _updateScale: function(scale2, text, ratio) {
            scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
            scale2.innerHTML = text;
          },
          _getRoundNum: function(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
            return pow10 * d;
          }
        });
        var scale = function(options) {
          return new Scale(options);
        };
        var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
        var Attribution = Control.extend({
          // @section
          // @aka Control.Attribution options
          options: {
            position: "bottomright",
            // @option prefix: String|false = 'Leaflet'
            // The HTML text shown before the attributions. Pass `false` to disable.
            prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
          },
          initialize: function(options) {
            setOptions(this, options);
            this._attributions = {};
          },
          onAdd: function(map3) {
            map3.attributionControl = this;
            this._container = create$1("div", "leaflet-control-attribution");
            disableClickPropagation(this._container);
            for (var i in map3._layers) {
              if (map3._layers[i].getAttribution) {
                this.addAttribution(map3._layers[i].getAttribution());
              }
            }
            this._update();
            map3.on("layeradd", this._addAttribution, this);
            return this._container;
          },
          onRemove: function(map3) {
            map3.off("layeradd", this._addAttribution, this);
          },
          _addAttribution: function(ev) {
            if (ev.layer.getAttribution) {
              this.addAttribution(ev.layer.getAttribution());
              ev.layer.once("remove", function() {
                this.removeAttribution(ev.layer.getAttribution());
              }, this);
            }
          },
          // @method setPrefix(prefix: String|false): this
          // The HTML text shown before the attributions. Pass `false` to disable.
          setPrefix: function(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
          },
          // @method addAttribution(text: String): this
          // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
          addAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (!this._attributions[text]) {
              this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
          },
          // @method removeAttribution(text: String): this
          // Removes an attribution text.
          removeAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (this._attributions[text]) {
              this._attributions[text]--;
              this._update();
            }
            return this;
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            var attribs = [];
            for (var i in this._attributions) {
              if (this._attributions[i]) {
                attribs.push(i);
              }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
              prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
              prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
          }
        });
        Map2.mergeOptions({
          attributionControl: true
        });
        Map2.addInitHook(function() {
          if (this.options.attributionControl) {
            new Attribution().addTo(this);
          }
        });
        var attribution = function(options) {
          return new Attribution(options);
        };
        Control.Layers = Layers;
        Control.Zoom = Zoom;
        Control.Scale = Scale;
        Control.Attribution = Attribution;
        control.layers = layers2;
        control.zoom = zoom;
        control.scale = scale;
        control.attribution = attribution;
        var Handler = Class.extend({
          initialize: function(map3) {
            this._map = map3;
          },
          // @method enable(): this
          // Enables the handler
          enable: function() {
            if (this._enabled) {
              return this;
            }
            this._enabled = true;
            this.addHooks();
            return this;
          },
          // @method disable(): this
          // Disables the handler
          disable: function() {
            if (!this._enabled) {
              return this;
            }
            this._enabled = false;
            this.removeHooks();
            return this;
          },
          // @method enabled(): Boolean
          // Returns `true` if the handler is enabled
          enabled: function() {
            return !!this._enabled;
          }
          // @section Extension methods
          // Classes inheriting from `Handler` must implement the two following methods:
          // @method addHooks()
          // Called when the handler is enabled, should add event hooks.
          // @method removeHooks()
          // Called when the handler is disabled, should remove the event hooks added previously.
        });
        Handler.addTo = function(map3, name) {
          map3.addHandler(name, this);
          return this;
        };
        var Mixin = { Events };
        var START = Browser.touch ? "touchstart mousedown" : "mousedown";
        var Draggable = Evented.extend({
          options: {
            // @section
            // @aka Draggable options
            // @option clickTolerance: Number = 3
            // The max number of pixels a user can shift the mouse pointer during a click
            // for it to be considered a valid click (as opposed to a mouse drag).
            clickTolerance: 3
          },
          // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
          // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
          initialize: function(element, dragStartTarget, preventOutline2, options) {
            setOptions(this, options);
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
            this._preventOutline = preventOutline2;
          },
          // @method enable()
          // Enables the dragging ability
          enable: function() {
            if (this._enabled) {
              return;
            }
            on(this._dragStartTarget, START, this._onDown, this);
            this._enabled = true;
          },
          // @method disable()
          // Disables the dragging ability
          disable: function() {
            if (!this._enabled) {
              return;
            }
            if (Draggable._dragging === this) {
              this.finishDrag(true);
            }
            off(this._dragStartTarget, START, this._onDown, this);
            this._enabled = false;
            this._moved = false;
          },
          _onDown: function(e) {
            if (!this._enabled) {
              return;
            }
            this._moved = false;
            if (hasClass(this._element, "leaflet-zoom-anim")) {
              return;
            }
            if (e.touches && e.touches.length !== 1) {
              if (Draggable._dragging === this) {
                this.finishDrag();
              }
              return;
            }
            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
              return;
            }
            Draggable._dragging = this;
            if (this._preventOutline) {
              preventOutline(this._element);
            }
            disableImageDrag();
            disableTextSelection();
            if (this._moving) {
              return;
            }
            this.fire("down");
            var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point(first.clientX, first.clientY);
            this._startPos = getPosition(this._element);
            this._parentScale = getScale(sizedParent);
            var mouseevent = e.type === "mousedown";
            on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
            on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
          },
          _onMove: function(e) {
            if (!this._enabled) {
              return;
            }
            if (e.touches && e.touches.length > 1) {
              this._moved = true;
              return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
            if (!offset.x && !offset.y) {
              return;
            }
            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
              return;
            }
            offset.x /= this._parentScale.x;
            offset.y /= this._parentScale.y;
            preventDefault(e);
            if (!this._moved) {
              this.fire("dragstart");
              this._moved = true;
              addClass(document.body, "leaflet-dragging");
              this._lastTarget = e.target || e.srcElement;
              if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
                this._lastTarget = this._lastTarget.correspondingUseElement;
              }
              addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            this._lastEvent = e;
            this._updatePosition();
          },
          _updatePosition: function() {
            var e = { originalEvent: this._lastEvent };
            this.fire("predrag", e);
            setPosition(this._element, this._newPos);
            this.fire("drag", e);
          },
          _onUp: function() {
            if (!this._enabled) {
              return;
            }
            this.finishDrag();
          },
          finishDrag: function(noInertia) {
            removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
              removeClass(this._lastTarget, "leaflet-drag-target");
              this._lastTarget = null;
            }
            off(document, "mousemove touchmove", this._onMove, this);
            off(document, "mouseup touchend touchcancel", this._onUp, this);
            enableImageDrag();
            enableTextSelection();
            var fireDragend = this._moved && this._moving;
            this._moving = false;
            Draggable._dragging = false;
            if (fireDragend) {
              this.fire("dragend", {
                noInertia,
                distance: this._newPos.distanceTo(this._startPos)
              });
            }
          }
        });
        function clipPolygon(points, bounds, round2) {
          var clippedPoints, edges2 = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
          for (i = 0, len = points.length; i < len; i++) {
            points[i]._code = _getBitCode(points[i], bounds);
          }
          for (k = 0; k < 4; k++) {
            edge2 = edges2[k];
            clippedPoints = [];
            for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
              a = points[i];
              b = points[j];
              if (!(a._code & edge2)) {
                if (b._code & edge2) {
                  p = _getEdgeIntersection(b, a, edge2, bounds, round2);
                  p._code = _getBitCode(p, bounds);
                  clippedPoints.push(p);
                }
                clippedPoints.push(a);
              } else if (!(b._code & edge2)) {
                p = _getEdgeIntersection(b, a, edge2, bounds, round2);
                p._code = _getBitCode(p, bounds);
                clippedPoints.push(p);
              }
            }
            points = clippedPoints;
          }
          return points;
        }
        function polygonCenter(latlngs, crs) {
          var i, j, p1, p2, f, area2, x2, y2, center2;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds = toLatLngBounds(latlngs);
          var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points = [];
          for (i = 0; i < len; i++) {
            var latlng = toLatLng(latlngs[i]);
            points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          area2 = x2 = y2 = 0;
          for (i = 0, j = len - 1; i < len; j = i++) {
            p1 = points[i];
            p2 = points[j];
            f = p1.y * p2.x - p2.y * p1.x;
            x2 += (p1.x + p2.x) * f;
            y2 += (p1.y + p2.y) * f;
            area2 += f * 3;
          }
          if (area2 === 0) {
            center2 = points[0];
          } else {
            center2 = [x2 / area2, y2 / area2];
          }
          var latlngCenter = crs.unproject(toPoint(center2));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        function centroid(coords) {
          var latSum = 0;
          var lngSum = 0;
          var len = 0;
          for (var i = 0; i < coords.length; i++) {
            var latlng = toLatLng(coords[i]);
            latSum += latlng.lat;
            lngSum += latlng.lng;
            len++;
          }
          return toLatLng([latSum / len, lngSum / len]);
        }
        var PolyUtil = {
          __proto__: null,
          clipPolygon,
          polygonCenter,
          centroid
        };
        function simplify(points, tolerance) {
          if (!tolerance || !points.length) {
            return points.slice();
          }
          var sqTolerance = tolerance * tolerance;
          points = _reducePoints(points, sqTolerance);
          points = _simplifyDP(points, sqTolerance);
          return points;
        }
        function pointToSegmentDistance(p, p1, p2) {
          return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
        }
        function closestPointOnSegment(p, p1, p2) {
          return _sqClosestPointOnSegment(p, p1, p2);
        }
        function _simplifyDP(points, sqTolerance) {
          var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
          markers[0] = markers[len - 1] = 1;
          _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
          var i, newPoints = [];
          for (i = 0; i < len; i++) {
            if (markers[i]) {
              newPoints.push(points[i]);
            }
          }
          return newPoints;
        }
        function _simplifyDPStep(points, markers, sqTolerance, first, last) {
          var maxSqDist = 0, index2, i, sqDist;
          for (i = first + 1; i <= last - 1; i++) {
            sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
            if (sqDist > maxSqDist) {
              index2 = i;
              maxSqDist = sqDist;
            }
          }
          if (maxSqDist > sqTolerance) {
            markers[index2] = 1;
            _simplifyDPStep(points, markers, sqTolerance, first, index2);
            _simplifyDPStep(points, markers, sqTolerance, index2, last);
          }
        }
        function _reducePoints(points, sqTolerance) {
          var reducedPoints = [points[0]];
          for (var i = 1, prev = 0, len = points.length; i < len; i++) {
            if (_sqDist(points[i], points[prev]) > sqTolerance) {
              reducedPoints.push(points[i]);
              prev = i;
            }
          }
          if (prev < len - 1) {
            reducedPoints.push(points[len - 1]);
          }
          return reducedPoints;
        }
        var _lastCode;
        function clipSegment(a, b, bounds, useLastCode, round2) {
          var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
          _lastCode = codeB;
          while (true) {
            if (!(codeA | codeB)) {
              return [a, b];
            }
            if (codeA & codeB) {
              return false;
            }
            codeOut = codeA || codeB;
            p = _getEdgeIntersection(a, b, codeOut, bounds, round2);
            newCode = _getBitCode(p, bounds);
            if (codeOut === codeA) {
              a = p;
              codeA = newCode;
            } else {
              b = p;
              codeB = newCode;
            }
          }
        }
        function _getEdgeIntersection(a, b, code, bounds, round2) {
          var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x2, y2;
          if (code & 8) {
            x2 = a.x + dx * (max.y - a.y) / dy;
            y2 = max.y;
          } else if (code & 4) {
            x2 = a.x + dx * (min.y - a.y) / dy;
            y2 = min.y;
          } else if (code & 2) {
            x2 = max.x;
            y2 = a.y + dy * (max.x - a.x) / dx;
          } else if (code & 1) {
            x2 = min.x;
            y2 = a.y + dy * (min.x - a.x) / dx;
          }
          return new Point(x2, y2, round2);
        }
        function _getBitCode(p, bounds) {
          var code = 0;
          if (p.x < bounds.min.x) {
            code |= 1;
          } else if (p.x > bounds.max.x) {
            code |= 2;
          }
          if (p.y < bounds.min.y) {
            code |= 4;
          } else if (p.y > bounds.max.y) {
            code |= 8;
          }
          return code;
        }
        function _sqDist(p1, p2) {
          var dx = p2.x - p1.x, dy = p2.y - p1.y;
          return dx * dx + dy * dy;
        }
        function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
          var x2 = p1.x, y2 = p1.y, dx = p2.x - x2, dy = p2.y - y2, dot = dx * dx + dy * dy, t;
          if (dot > 0) {
            t = ((p.x - x2) * dx + (p.y - y2) * dy) / dot;
            if (t > 1) {
              x2 = p2.x;
              y2 = p2.y;
            } else if (t > 0) {
              x2 += dx * t;
              y2 += dy * t;
            }
          }
          dx = p.x - x2;
          dy = p.y - y2;
          return sqDist ? dx * dx + dy * dy : new Point(x2, y2);
        }
        function isFlat(latlngs) {
          return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
        }
        function _flat(latlngs) {
          console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
          return isFlat(latlngs);
        }
        function polylineCenter(latlngs, crs) {
          var i, halfDist, segDist, dist, p1, p2, ratio, center2;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds = toLatLngBounds(latlngs);
          var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points = [];
          for (i = 0; i < len; i++) {
            var latlng = toLatLng(latlngs[i]);
            points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          for (i = 0, halfDist = 0; i < len - 1; i++) {
            halfDist += points[i].distanceTo(points[i + 1]) / 2;
          }
          if (halfDist === 0) {
            center2 = points[0];
          } else {
            for (i = 0, dist = 0; i < len - 1; i++) {
              p1 = points[i];
              p2 = points[i + 1];
              segDist = p1.distanceTo(p2);
              dist += segDist;
              if (dist > halfDist) {
                ratio = (dist - halfDist) / segDist;
                center2 = [
                  p2.x - ratio * (p2.x - p1.x),
                  p2.y - ratio * (p2.y - p1.y)
                ];
                break;
              }
            }
          }
          var latlngCenter = crs.unproject(toPoint(center2));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        var LineUtil = {
          __proto__: null,
          simplify,
          pointToSegmentDistance,
          closestPointOnSegment,
          clipSegment,
          _getEdgeIntersection,
          _getBitCode,
          _sqClosestPointOnSegment,
          isFlat,
          _flat,
          polylineCenter
        };
        var LonLat = {
          project: function(latlng) {
            return new Point(latlng.lng, latlng.lat);
          },
          unproject: function(point2) {
            return new LatLng(point2.y, point2.x);
          },
          bounds: new Bounds([-180, -90], [180, 90])
        };
        var Mercator = {
          R: 6378137,
          R_MINOR: 6356752314245179e-9,
          bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
          project: function(latlng) {
            var d = Math.PI / 180, r = this.R, y2 = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y2);
            var ts = Math.tan(Math.PI / 4 - y2 / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y2 = -r * Math.log(Math.max(ts, 1e-10));
            return new Point(latlng.lng * d * r, y2);
          },
          unproject: function(point2) {
            var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point2.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
              con = e * Math.sin(phi);
              con = Math.pow((1 - con) / (1 + con), e / 2);
              dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
              phi += dphi;
            }
            return new LatLng(phi * d, point2.x * d / r);
          }
        };
        var index = {
          __proto__: null,
          LonLat,
          Mercator,
          SphericalMercator
        };
        var EPSG3395 = extend({}, Earth, {
          code: "EPSG:3395",
          projection: Mercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * Mercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG4326 = extend({}, Earth, {
          code: "EPSG:4326",
          projection: LonLat,
          transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
        });
        var Simple = extend({}, CRS, {
          projection: LonLat,
          transformation: toTransformation(1, 0, -1, 0),
          scale: function(zoom2) {
            return Math.pow(2, zoom2);
          },
          zoom: function(scale2) {
            return Math.log(scale2) / Math.LN2;
          },
          distance: function(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
          },
          infinite: true
        });
        CRS.Earth = Earth;
        CRS.EPSG3395 = EPSG3395;
        CRS.EPSG3857 = EPSG3857;
        CRS.EPSG900913 = EPSG900913;
        CRS.EPSG4326 = EPSG4326;
        CRS.Simple = Simple;
        var Layer = Evented.extend({
          // Classes extending `L.Layer` will inherit the following options:
          options: {
            // @option pane: String = 'overlayPane'
            // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
            pane: "overlayPane",
            // @option attribution: String = null
            // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
            attribution: null,
            bubblingMouseEvents: true
          },
          /* @section
           * Classes extending `L.Layer` will inherit the following methods:
           *
           * @method addTo(map: Map|LayerGroup): this
           * Adds the layer to the given map or layer group.
           */
          addTo: function(map3) {
            map3.addLayer(this);
            return this;
          },
          // @method remove: this
          // Removes the layer from the map it is currently active on.
          remove: function() {
            return this.removeFrom(this._map || this._mapToAdd);
          },
          // @method removeFrom(map: Map): this
          // Removes the layer from the given map
          //
          // @alternative
          // @method removeFrom(group: LayerGroup): this
          // Removes the layer from the given `LayerGroup`
          removeFrom: function(obj) {
            if (obj) {
              obj.removeLayer(this);
            }
            return this;
          },
          // @method getPane(name? : String): HTMLElement
          // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
          getPane: function(name) {
            return this._map.getPane(name ? this.options[name] || name : this.options.pane);
          },
          addInteractiveTarget: function(targetEl) {
            this._map._targets[stamp(targetEl)] = this;
            return this;
          },
          removeInteractiveTarget: function(targetEl) {
            delete this._map._targets[stamp(targetEl)];
            return this;
          },
          // @method getAttribution: String
          // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
          getAttribution: function() {
            return this.options.attribution;
          },
          _layerAdd: function(e) {
            var map3 = e.target;
            if (!map3.hasLayer(this)) {
              return;
            }
            this._map = map3;
            this._zoomAnimated = map3._zoomAnimated;
            if (this.getEvents) {
              var events = this.getEvents();
              map3.on(events, this);
              this.once("remove", function() {
                map3.off(events, this);
              }, this);
            }
            this.onAdd(map3);
            this.fire("add");
            map3.fire("layeradd", { layer: this });
          }
        });
        Map2.include({
          // @method addLayer(layer: Layer): this
          // Adds the given layer to the map
          addLayer: function(layer) {
            if (!layer._layerAdd) {
              throw new Error("The provided object is not a Layer.");
            }
            var id = stamp(layer);
            if (this._layers[id]) {
              return this;
            }
            this._layers[id] = layer;
            layer._mapToAdd = this;
            if (layer.beforeAdd) {
              layer.beforeAdd(this);
            }
            this.whenReady(layer._layerAdd, layer);
            return this;
          },
          // @method removeLayer(layer: Layer): this
          // Removes the given layer from the map.
          removeLayer: function(layer) {
            var id = stamp(layer);
            if (!this._layers[id]) {
              return this;
            }
            if (this._loaded) {
              layer.onRemove(this);
            }
            delete this._layers[id];
            if (this._loaded) {
              this.fire("layerremove", { layer });
              layer.fire("remove");
            }
            layer._map = layer._mapToAdd = null;
            return this;
          },
          // @method hasLayer(layer: Layer): Boolean
          // Returns `true` if the given layer is currently added to the map
          hasLayer: function(layer) {
            return stamp(layer) in this._layers;
          },
          /* @method eachLayer(fn: Function, context?: Object): this
           * Iterates over the layers of the map, optionally specifying context of the iterator function.
           * ```
           * map.eachLayer(function(layer){
           *     layer.bindPopup('Hello');
           * });
           * ```
           */
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          _addLayers: function(layers3) {
            layers3 = layers3 ? isArray(layers3) ? layers3 : [layers3] : [];
            for (var i = 0, len = layers3.length; i < len; i++) {
              this.addLayer(layers3[i]);
            }
          },
          _addZoomLimit: function(layer) {
            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
              this._zoomBoundLayers[stamp(layer)] = layer;
              this._updateZoomLevels();
            }
          },
          _removeZoomLimit: function(layer) {
            var id = stamp(layer);
            if (this._zoomBoundLayers[id]) {
              delete this._zoomBoundLayers[id];
              this._updateZoomLevels();
            }
          },
          _updateZoomLevels: function() {
            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (var i in this._zoomBoundLayers) {
              var options = this._zoomBoundLayers[i].options;
              minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
              maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }
            this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
            if (oldZoomSpan !== this._getZoomSpan()) {
              this.fire("zoomlevelschange");
            }
            if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
              this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
              this.setZoom(this._layersMinZoom);
            }
          }
        });
        var LayerGroup = Layer.extend({
          initialize: function(layers3, options) {
            setOptions(this, options);
            this._layers = {};
            var i, len;
            if (layers3) {
              for (i = 0, len = layers3.length; i < len; i++) {
                this.addLayer(layers3[i]);
              }
            }
          },
          // @method addLayer(layer: Layer): this
          // Adds the given layer to the group.
          addLayer: function(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) {
              this._map.addLayer(layer);
            }
            return this;
          },
          // @method removeLayer(layer: Layer): this
          // Removes the given layer from the group.
          // @alternative
          // @method removeLayer(id: Number): this
          // Removes the layer with the given internal ID from the group.
          removeLayer: function(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) {
              this._map.removeLayer(this._layers[id]);
            }
            delete this._layers[id];
            return this;
          },
          // @method hasLayer(layer: Layer): Boolean
          // Returns `true` if the given layer is currently added to the group.
          // @alternative
          // @method hasLayer(id: Number): Boolean
          // Returns `true` if the given internal ID is currently added to the group.
          hasLayer: function(layer) {
            var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
            return layerId in this._layers;
          },
          // @method clearLayers(): this
          // Removes all the layers from the group.
          clearLayers: function() {
            return this.eachLayer(this.removeLayer, this);
          },
          // @method invoke(methodName: String, …): this
          // Calls `methodName` on every layer contained in this group, passing any
          // additional parameters. Has no effect if the layers contained do not
          // implement `methodName`.
          invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i, layer;
            for (i in this._layers) {
              layer = this._layers[i];
              if (layer[methodName]) {
                layer[methodName].apply(layer, args);
              }
            }
            return this;
          },
          onAdd: function(map3) {
            this.eachLayer(map3.addLayer, map3);
          },
          onRemove: function(map3) {
            this.eachLayer(map3.removeLayer, map3);
          },
          // @method eachLayer(fn: Function, context?: Object): this
          // Iterates over the layers of the group, optionally specifying context of the iterator function.
          // ```js
          // group.eachLayer(function (layer) {
          // 	layer.bindPopup('Hello');
          // });
          // ```
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          // @method getLayer(id: Number): Layer
          // Returns the layer with the given internal ID.
          getLayer: function(id) {
            return this._layers[id];
          },
          // @method getLayers(): Layer[]
          // Returns an array of all the layers added to the group.
          getLayers: function() {
            var layers3 = [];
            this.eachLayer(layers3.push, layers3);
            return layers3;
          },
          // @method setZIndex(zIndex: Number): this
          // Calls `setZIndex` on every layer contained in this group, passing the z-index.
          setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
          },
          // @method getLayerId(layer: Layer): Number
          // Returns the internal ID for a layer
          getLayerId: function(layer) {
            return stamp(layer);
          }
        });
        var layerGroup = function(layers3, options) {
          return new LayerGroup(layers3, options);
        };
        var FeatureGroup = LayerGroup.extend({
          addLayer: function(layer) {
            if (this.hasLayer(layer)) {
              return this;
            }
            layer.addEventParent(this);
            LayerGroup.prototype.addLayer.call(this, layer);
            return this.fire("layeradd", { layer });
          },
          removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
              return this;
            }
            if (layer in this._layers) {
              layer = this._layers[layer];
            }
            layer.removeEventParent(this);
            LayerGroup.prototype.removeLayer.call(this, layer);
            return this.fire("layerremove", { layer });
          },
          // @method setStyle(style: Path options): this
          // Sets the given path options to each layer of the group that has a `setStyle` method.
          setStyle: function(style2) {
            return this.invoke("setStyle", style2);
          },
          // @method bringToFront(): this
          // Brings the layer group to the top of all other layers
          bringToFront: function() {
            return this.invoke("bringToFront");
          },
          // @method bringToBack(): this
          // Brings the layer group to the back of all other layers
          bringToBack: function() {
            return this.invoke("bringToBack");
          },
          // @method getBounds(): LatLngBounds
          // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
          getBounds: function() {
            var bounds = new LatLngBounds();
            for (var id in this._layers) {
              var layer = this._layers[id];
              bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }
            return bounds;
          }
        });
        var featureGroup = function(layers3, options) {
          return new FeatureGroup(layers3, options);
        };
        var Icon = Class.extend({
          /* @section
           * @aka Icon options
           *
           * @option iconUrl: String = null
           * **(required)** The URL to the icon image (absolute or relative to your script path).
           *
           * @option iconRetinaUrl: String = null
           * The URL to a retina sized version of the icon image (absolute or relative to your
           * script path). Used for Retina screen devices.
           *
           * @option iconSize: Point = null
           * Size of the icon image in pixels.
           *
           * @option iconAnchor: Point = null
           * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
           * will be aligned so that this point is at the marker's geographical location. Centered
           * by default if size is specified, also can be set in CSS with negative margins.
           *
           * @option popupAnchor: Point = [0, 0]
           * The coordinates of the point from which popups will "open", relative to the icon anchor.
           *
           * @option tooltipAnchor: Point = [0, 0]
           * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
           *
           * @option shadowUrl: String = null
           * The URL to the icon shadow image. If not specified, no shadow image will be created.
           *
           * @option shadowRetinaUrl: String = null
           *
           * @option shadowSize: Point = null
           * Size of the shadow image in pixels.
           *
           * @option shadowAnchor: Point = null
           * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
           * as iconAnchor if not specified).
           *
           * @option className: String = ''
           * A custom class name to assign to both icon and shadow images. Empty by default.
           */
          options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0],
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          // @method createIcon(oldIcon?: HTMLElement): HTMLElement
          // Called internally when the icon has to be shown, returns a `<img>` HTML element
          // styled according to the options.
          createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
          },
          // @method createShadow(oldIcon?: HTMLElement): HTMLElement
          // As `createIcon`, but for the shadow beneath it.
          createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
          },
          _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
              if (name === "icon") {
                throw new Error("iconUrl not set in Icon options (see the docs).");
              }
              return null;
            }
            var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
            this._setIconStyles(img, name);
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            return img;
          },
          _setIconStyles: function(img, name) {
            var options = this.options;
            var sizeOption = options[name + "Size"];
            if (typeof sizeOption === "number") {
              sizeOption = [sizeOption, sizeOption];
            }
            var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
            img.className = "leaflet-marker-" + name + " " + (options.className || "");
            if (anchor) {
              img.style.marginLeft = -anchor.x + "px";
              img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
              img.style.width = size.x + "px";
              img.style.height = size.y + "px";
            }
          },
          _createImg: function(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
          },
          _getIconUrl: function(name) {
            return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
          }
        });
        function icon2(options) {
          return new Icon(options);
        }
        var IconDefault = Icon.extend({
          options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          },
          _getIconUrl: function(name) {
            if (typeof IconDefault.imagePath !== "string") {
              IconDefault.imagePath = this._detectIconPath();
            }
            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
          },
          _stripUrl: function(path) {
            var strip = function(str, re, idx) {
              var match = re.exec(str);
              return match && match[idx];
            };
            path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
            return path && strip(path, /^(.*)marker-icon\.png$/, 1);
          },
          _detectIconPath: function() {
            var el = create$1("div", "leaflet-default-icon-path", document.body);
            var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
            document.body.removeChild(el);
            path = this._stripUrl(path);
            if (path) {
              return path;
            }
            var link2 = document.querySelector('link[href$="leaflet.css"]');
            if (!link2) {
              return "";
            }
            return link2.href.substring(0, link2.href.length - "leaflet.css".length - 1);
          }
        });
        var MarkerDrag = Handler.extend({
          initialize: function(marker3) {
            this._marker = marker3;
          },
          addHooks: function() {
            var icon3 = this._marker._icon;
            if (!this._draggable) {
              this._draggable = new Draggable(icon3, icon3, true);
            }
            this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).enable();
            addClass(icon3, "leaflet-marker-draggable");
          },
          removeHooks: function() {
            this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).disable();
            if (this._marker._icon) {
              removeClass(this._marker._icon, "leaflet-marker-draggable");
            }
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          _adjustPan: function(e) {
            var marker3 = this._marker, map3 = marker3._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker3._icon), bounds = map3.getPixelBounds(), origin = map3.getPixelOrigin();
            var panBounds = toBounds(
              bounds.min._subtract(origin).add(padding),
              bounds.max._subtract(origin).subtract(padding)
            );
            if (!panBounds.contains(iconPos)) {
              var movement = toPoint(
                (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
                (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
              ).multiplyBy(speed);
              map3.panBy(movement, { animate: false });
              this._draggable._newPos._add(movement);
              this._draggable._startPos._add(movement);
              setPosition(marker3._icon, this._draggable._newPos);
              this._onDrag(e);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDragStart: function() {
            this._oldLatLng = this._marker.getLatLng();
            this._marker.closePopup && this._marker.closePopup();
            this._marker.fire("movestart").fire("dragstart");
          },
          _onPreDrag: function(e) {
            if (this._marker.options.autoPan) {
              cancelAnimFrame(this._panRequest);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDrag: function(e) {
            var marker3 = this._marker, shadow = marker3._shadow, iconPos = getPosition(marker3._icon), latlng = marker3._map.layerPointToLatLng(iconPos);
            if (shadow) {
              setPosition(shadow, iconPos);
            }
            marker3._latlng = latlng;
            e.latlng = latlng;
            e.oldLatLng = this._oldLatLng;
            marker3.fire("move", e).fire("drag", e);
          },
          _onDragEnd: function(e) {
            cancelAnimFrame(this._panRequest);
            delete this._oldLatLng;
            this._marker.fire("moveend").fire("dragend", e);
          }
        });
        var Marker = Layer.extend({
          // @section
          // @aka Marker options
          options: {
            // @option icon: Icon = *
            // Icon instance to use for rendering the marker.
            // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
            // If not specified, a common instance of `L.Icon.Default` is used.
            icon: new IconDefault(),
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option keyboard: Boolean = true
            // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
            keyboard: true,
            // @option title: String = ''
            // Text for the browser tooltip that appear on marker hover (no tooltip by default).
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            title: "",
            // @option alt: String = 'Marker'
            // Text for the `alt` attribute of the icon image.
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            alt: "Marker",
            // @option zIndexOffset: Number = 0
            // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
            zIndexOffset: 0,
            // @option opacity: Number = 1.0
            // The opacity of the marker.
            opacity: 1,
            // @option riseOnHover: Boolean = false
            // If `true`, the marker will get on top of others when you hover the mouse over it.
            riseOnHover: false,
            // @option riseOffset: Number = 250
            // The z-index offset used for the `riseOnHover` feature.
            riseOffset: 250,
            // @option pane: String = 'markerPane'
            // `Map pane` where the markers icon will be added.
            pane: "markerPane",
            // @option shadowPane: String = 'shadowPane'
            // `Map pane` where the markers shadow will be added.
            shadowPane: "shadowPane",
            // @option bubblingMouseEvents: Boolean = false
            // When `true`, a mouse event on this marker will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: false,
            // @option autoPanOnFocus: Boolean = true
            // When `true`, the map will pan whenever the marker is focused (via
            // e.g. pressing `tab` on the keyboard) to ensure the marker is
            // visible within the map's bounds
            autoPanOnFocus: true,
            // @section Draggable marker options
            // @option draggable: Boolean = false
            // Whether the marker is draggable with mouse/touch or not.
            draggable: false,
            // @option autoPan: Boolean = false
            // Whether to pan the map when dragging this marker near its edge or not.
            autoPan: false,
            // @option autoPanPadding: Point = Point(50, 50)
            // Distance (in pixels to the left/right and to the top/bottom) of the
            // map edge to start panning the map.
            autoPanPadding: [50, 50],
            // @option autoPanSpeed: Number = 10
            // Number of pixels the map should pan by.
            autoPanSpeed: 10
          },
          /* @section
           *
           * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
           */
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
          },
          onAdd: function(map3) {
            this._zoomAnimated = this._zoomAnimated && map3.options.markerZoomAnimation;
            if (this._zoomAnimated) {
              map3.on("zoomanim", this._animateZoom, this);
            }
            this._initIcon();
            this.update();
          },
          onRemove: function(map3) {
            if (this.dragging && this.dragging.enabled()) {
              this.options.draggable = true;
              this.dragging.removeHooks();
            }
            delete this.dragging;
            if (this._zoomAnimated) {
              map3.off("zoomanim", this._animateZoom, this);
            }
            this._removeIcon();
            this._removeShadow();
          },
          getEvents: function() {
            return {
              zoom: this.update,
              viewreset: this.update
            };
          },
          // @method getLatLng: LatLng
          // Returns the current geographical position of the marker.
          getLatLng: function() {
            return this._latlng;
          },
          // @method setLatLng(latlng: LatLng): this
          // Changes the marker position to the given point.
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.update();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          // @method setZIndexOffset(offset: Number): this
          // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
          setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            return this.update();
          },
          // @method getIcon: Icon
          // Returns the current icon used by the marker
          getIcon: function() {
            return this.options.icon;
          },
          // @method setIcon(icon: Icon): this
          // Changes the marker icon.
          setIcon: function(icon3) {
            this.options.icon = icon3;
            if (this._map) {
              this._initIcon();
              this.update();
            }
            if (this._popup) {
              this.bindPopup(this._popup, this._popup.options);
            }
            return this;
          },
          getElement: function() {
            return this._icon;
          },
          update: function() {
            if (this._icon && this._map) {
              var pos = this._map.latLngToLayerPoint(this._latlng).round();
              this._setPos(pos);
            }
            return this;
          },
          _initIcon: function() {
            var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var icon3 = options.icon.createIcon(this._icon), addIcon = false;
            if (icon3 !== this._icon) {
              if (this._icon) {
                this._removeIcon();
              }
              addIcon = true;
              if (options.title) {
                icon3.title = options.title;
              }
              if (icon3.tagName === "IMG") {
                icon3.alt = options.alt || "";
              }
            }
            addClass(icon3, classToAdd);
            if (options.keyboard) {
              icon3.tabIndex = "0";
              icon3.setAttribute("role", "button");
            }
            this._icon = icon3;
            if (options.riseOnHover) {
              this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              on(icon3, "focus", this._panOnFocus, this);
            }
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
              this._removeShadow();
              addShadow = true;
            }
            if (newShadow) {
              addClass(newShadow, classToAdd);
              newShadow.alt = "";
            }
            this._shadow = newShadow;
            if (options.opacity < 1) {
              this._updateOpacity();
            }
            if (addIcon) {
              this.getPane().appendChild(this._icon);
            }
            this._initInteraction();
            if (newShadow && addShadow) {
              this.getPane(options.shadowPane).appendChild(this._shadow);
            }
          },
          _removeIcon: function() {
            if (this.options.riseOnHover) {
              this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              off(this._icon, "focus", this._panOnFocus, this);
            }
            remove(this._icon);
            this.removeInteractiveTarget(this._icon);
            this._icon = null;
          },
          _removeShadow: function() {
            if (this._shadow) {
              remove(this._shadow);
            }
            this._shadow = null;
          },
          _setPos: function(pos) {
            if (this._icon) {
              setPosition(this._icon, pos);
            }
            if (this._shadow) {
              setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
          },
          _updateZIndex: function(offset) {
            if (this._icon) {
              this._icon.style.zIndex = this._zIndex + offset;
            }
          },
          _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
          },
          _initInteraction: function() {
            if (!this.options.interactive) {
              return;
            }
            addClass(this._icon, "leaflet-interactive");
            this.addInteractiveTarget(this._icon);
            if (MarkerDrag) {
              var draggable = this.options.draggable;
              if (this.dragging) {
                draggable = this.dragging.enabled();
                this.dragging.disable();
              }
              this.dragging = new MarkerDrag(this);
              if (draggable) {
                this.dragging.enable();
              }
            }
          },
          // @method setOpacity(opacity: Number): this
          // Changes the opacity of the marker.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
              this._updateOpacity();
            }
            return this;
          },
          _updateOpacity: function() {
            var opacity = this.options.opacity;
            if (this._icon) {
              setOpacity(this._icon, opacity);
            }
            if (this._shadow) {
              setOpacity(this._shadow, opacity);
            }
          },
          _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
          },
          _resetZIndex: function() {
            this._updateZIndex(0);
          },
          _panOnFocus: function() {
            var map3 = this._map;
            if (!map3) {
              return;
            }
            var iconOpts = this.options.icon.options;
            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
            map3.panInside(this._latlng, {
              paddingTopLeft: anchor,
              paddingBottomRight: size.subtract(anchor)
            });
          },
          _getPopupAnchor: function() {
            return this.options.icon.options.popupAnchor;
          },
          _getTooltipAnchor: function() {
            return this.options.icon.options.tooltipAnchor;
          }
        });
        function marker2(latlng, options) {
          return new Marker(latlng, options);
        }
        var Path = Layer.extend({
          // @section
          // @aka Path options
          options: {
            // @option stroke: Boolean = true
            // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
            stroke: true,
            // @option color: String = '#3388ff'
            // Stroke color
            color: "#3388ff",
            // @option weight: Number = 3
            // Stroke width in pixels
            weight: 3,
            // @option opacity: Number = 1.0
            // Stroke opacity
            opacity: 1,
            // @option lineCap: String= 'round'
            // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
            lineCap: "round",
            // @option lineJoin: String = 'round'
            // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
            lineJoin: "round",
            // @option dashArray: String = null
            // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashArray: null,
            // @option dashOffset: String = null
            // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashOffset: null,
            // @option fill: Boolean = depends
            // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
            fill: false,
            // @option fillColor: String = *
            // Fill color. Defaults to the value of the [`color`](#path-color) option
            fillColor: null,
            // @option fillOpacity: Number = 0.2
            // Fill opacity.
            fillOpacity: 0.2,
            // @option fillRule: String = 'evenodd'
            // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
            fillRule: "evenodd",
            // className: '',
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option bubblingMouseEvents: Boolean = true
            // When `true`, a mouse event on this path will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: true
          },
          beforeAdd: function(map3) {
            this._renderer = map3.getRenderer(this);
          },
          onAdd: function() {
            this._renderer._initPath(this);
            this._reset();
            this._renderer._addPath(this);
          },
          onRemove: function() {
            this._renderer._removePath(this);
          },
          // @method redraw(): this
          // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
          redraw: function() {
            if (this._map) {
              this._renderer._updatePath(this);
            }
            return this;
          },
          // @method setStyle(style: Path options): this
          // Changes the appearance of a Path based on the options in the `Path options` object.
          setStyle: function(style2) {
            setOptions(this, style2);
            if (this._renderer) {
              this._renderer._updateStyle(this);
              if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
                this._updateBounds();
              }
            }
            return this;
          },
          // @method bringToFront(): this
          // Brings the layer to the top of all path layers.
          bringToFront: function() {
            if (this._renderer) {
              this._renderer._bringToFront(this);
            }
            return this;
          },
          // @method bringToBack(): this
          // Brings the layer to the bottom of all path layers.
          bringToBack: function() {
            if (this._renderer) {
              this._renderer._bringToBack(this);
            }
            return this;
          },
          getElement: function() {
            return this._path;
          },
          _reset: function() {
            this._project();
            this._update();
          },
          _clickTolerance: function() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
          }
        });
        var CircleMarker = Path.extend({
          // @section
          // @aka CircleMarker options
          options: {
            fill: true,
            // @option radius: Number = 10
            // Radius of the circle marker, in pixels
            radius: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            this._radius = this.options.radius;
          },
          // @method setLatLng(latLng: LatLng): this
          // Sets the position of a circle marker to a new location.
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.redraw();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          // @method getLatLng(): LatLng
          // Returns the current geographical position of the circle marker
          getLatLng: function() {
            return this._latlng;
          },
          // @method setRadius(radius: Number): this
          // Sets the radius of a circle marker. Units are in pixels.
          setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
          },
          // @method getRadius(): Number
          // Returns the current radius of the circle
          getRadius: function() {
            return this._radius;
          },
          setStyle: function(options) {
            var radius = options && options.radius || this._radius;
            Path.prototype.setStyle.call(this, options);
            this.setRadius(radius);
            return this;
          },
          _project: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
          },
          _updateBounds: function() {
            var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
            this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
          },
          _update: function() {
            if (this._map) {
              this._updatePath();
            }
          },
          _updatePath: function() {
            this._renderer._updateCircle(this);
          },
          _empty: function() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p) {
            return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
          }
        });
        function circleMarker2(latlng, options) {
          return new CircleMarker(latlng, options);
        }
        var Circle2 = CircleMarker.extend({
          initialize: function(latlng, options, legacyOptions) {
            if (typeof options === "number") {
              options = extend({}, legacyOptions, { radius: options });
            }
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            if (isNaN(this.options.radius)) {
              throw new Error("Circle radius cannot be NaN");
            }
            this._mRadius = this.options.radius;
          },
          // @method setRadius(radius: Number): this
          // Sets the radius of a circle. Units are in meters.
          setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
          },
          // @method getRadius(): Number
          // Returns the current radius of a circle. Units are in meters.
          getRadius: function() {
            return this._mRadius;
          },
          // @method getBounds(): LatLngBounds
          // Returns the `LatLngBounds` of the path.
          getBounds: function() {
            var half = [this._radius, this._radiusY || this._radius];
            return new LatLngBounds(
              this._map.layerPointToLatLng(this._point.subtract(half)),
              this._map.layerPointToLatLng(this._point.add(half))
            );
          },
          setStyle: Path.prototype.setStyle,
          _project: function() {
            var lng = this._latlng.lng, lat = this._latlng.lat, map3 = this._map, crs = map3.options.crs;
            if (crs.distance === Earth.distance) {
              var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map3.project([lat + latR, lng]), bottom = map3.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map3.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
              if (isNaN(lngR) || lngR === 0) {
                lngR = latR / Math.cos(Math.PI / 180 * lat);
              }
              this._point = p.subtract(map3.getPixelOrigin());
              this._radius = isNaN(lngR) ? 0 : p.x - map3.project([lat2, lng - lngR]).x;
              this._radiusY = p.y - top.y;
            } else {
              var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
              this._point = map3.latLngToLayerPoint(this._latlng);
              this._radius = this._point.x - map3.latLngToLayerPoint(latlng2).x;
            }
            this._updateBounds();
          }
        });
        function circle4(latlng, options, legacyOptions) {
          return new Circle2(latlng, options, legacyOptions);
        }
        var Polyline = Path.extend({
          // @section
          // @aka Polyline options
          options: {
            // @option smoothFactor: Number = 1.0
            // How much to simplify the polyline on each zoom level. More means
            // better performance and smoother look, and less means more accurate representation.
            smoothFactor: 1,
            // @option noClip: Boolean = false
            // Disable polyline clipping.
            noClip: false
          },
          initialize: function(latlngs, options) {
            setOptions(this, options);
            this._setLatLngs(latlngs);
          },
          // @method getLatLngs(): LatLng[]
          // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
          getLatLngs: function() {
            return this._latlngs;
          },
          // @method setLatLngs(latlngs: LatLng[]): this
          // Replaces all the points in the polyline with the given array of geographical points.
          setLatLngs: function(latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
          },
          // @method isEmpty(): Boolean
          // Returns `true` if the Polyline has no LatLngs.
          isEmpty: function() {
            return !this._latlngs.length;
          },
          // @method closestLayerPoint(p: Point): Point
          // Returns the point closest to `p` on the Polyline.
          closestLayerPoint: function(p) {
            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
            for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
              var points = this._parts[j];
              for (var i = 1, len = points.length; i < len; i++) {
                p1 = points[i - 1];
                p2 = points[i];
                var sqDist = closest(p, p1, p2, true);
                if (sqDist < minDistance) {
                  minDistance = sqDist;
                  minPoint = closest(p, p1, p2);
                }
              }
            }
            if (minPoint) {
              minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
          },
          // @method getCenter(): LatLng
          // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polylineCenter(this._defaultShape(), this._map.options.crs);
          },
          // @method getBounds(): LatLngBounds
          // Returns the `LatLngBounds` of the path.
          getBounds: function() {
            return this._bounds;
          },
          // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
          // Adds a given point to the polyline. By default, adds to the first ring of
          // the polyline in case of a multi-polyline, but can be overridden by passing
          // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
          addLatLng: function(latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = toLatLng(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
          },
          _setLatLngs: function(latlngs) {
            this._bounds = new LatLngBounds();
            this._latlngs = this._convertLatLngs(latlngs);
          },
          _defaultShape: function() {
            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
          },
          // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
          _convertLatLngs: function(latlngs) {
            var result = [], flat = isFlat(latlngs);
            for (var i = 0, len = latlngs.length; i < len; i++) {
              if (flat) {
                result[i] = toLatLng(latlngs[i]);
                this._bounds.extend(result[i]);
              } else {
                result[i] = this._convertLatLngs(latlngs[i]);
              }
            }
            return result;
          },
          _project: function() {
            var pxBounds = new Bounds();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);
            if (this._bounds.isValid() && pxBounds.isValid()) {
              this._rawPxBounds = pxBounds;
              this._updateBounds();
            }
          },
          _updateBounds: function() {
            var w = this._clickTolerance(), p = new Point(w, w);
            if (!this._rawPxBounds) {
              return;
            }
            this._pxBounds = new Bounds([
              this._rawPxBounds.min.subtract(p),
              this._rawPxBounds.max.add(p)
            ]);
          },
          // recursively turns latlngs into a set of rings with projected coordinates
          _projectLatlngs: function(latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
            if (flat) {
              ring = [];
              for (i = 0; i < len; i++) {
                ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                projectedBounds.extend(ring[i]);
              }
              result.push(ring);
            } else {
              for (i = 0; i < len; i++) {
                this._projectLatlngs(latlngs[i], result, projectedBounds);
              }
            }
          },
          // clip polyline by renderer bounds so that we have less to render for performance
          _clipPoints: function() {
            var bounds = this._renderer._bounds;
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var parts = this._parts, i, j, k, len, len2, segment, points;
            for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
              points = this._rings[i];
              for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                segment = clipSegment(points[j], points[j + 1], bounds, j, true);
                if (!segment) {
                  continue;
                }
                parts[k] = parts[k] || [];
                parts[k].push(segment[0]);
                if (segment[1] !== points[j + 1] || j === len2 - 2) {
                  parts[k].push(segment[1]);
                  k++;
                }
              }
            }
          },
          // simplify each clipped part of the polyline for performance
          _simplifyPoints: function() {
            var parts = this._parts, tolerance = this.options.smoothFactor;
            for (var i = 0, len = parts.length; i < len; i++) {
              parts[i] = simplify(parts[i], tolerance);
            }
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
          },
          _updatePath: function() {
            this._renderer._updatePoly(this);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p, closed) {
            var i, j, k, len, len2, part, w = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                if (!closed && j === 0) {
                  continue;
                }
                if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                  return true;
                }
              }
            }
            return false;
          }
        });
        function polyline2(latlngs, options) {
          return new Polyline(latlngs, options);
        }
        Polyline._flat = _flat;
        var Polygon = Polyline.extend({
          options: {
            fill: true
          },
          isEmpty: function() {
            return !this._latlngs.length || !this._latlngs[0].length;
          },
          // @method getCenter(): LatLng
          // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polygonCenter(this._defaultShape(), this._map.options.crs);
          },
          _convertLatLngs: function(latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
              result.pop();
            }
            return result;
          },
          _setLatLngs: function(latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (isFlat(this._latlngs)) {
              this._latlngs = [this._latlngs];
            }
          },
          _defaultShape: function() {
            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
          },
          _clipPoints: function() {
            var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
            bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
              clipped = clipPolygon(this._rings[i], bounds, true);
              if (clipped.length) {
                this._parts.push(clipped);
              }
            }
          },
          _updatePath: function() {
            this._renderer._updatePoly(this, true);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p) {
            var inside = false, part, p1, p2, i, j, k, len, len2;
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                p1 = part[j];
                p2 = part[k];
                if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                  inside = !inside;
                }
              }
            }
            return inside || Polyline.prototype._containsPoint.call(this, p, true);
          }
        });
        function polygon2(latlngs, options) {
          return new Polygon(latlngs, options);
        }
        var GeoJSON = FeatureGroup.extend({
          /* @section
           * @aka GeoJSON options
           *
           * @option pointToLayer: Function = *
           * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
           * called when data is added, passing the GeoJSON point feature and its `LatLng`.
           * The default is to spawn a default `Marker`:
           * ```js
           * function(geoJsonPoint, latlng) {
           * 	return L.marker(latlng);
           * }
           * ```
           *
           * @option style: Function = *
           * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
           * called internally when data is added.
           * The default value is to not override any defaults:
           * ```js
           * function (geoJsonFeature) {
           * 	return {}
           * }
           * ```
           *
           * @option onEachFeature: Function = *
           * A `Function` that will be called once for each created `Feature`, after it has
           * been created and styled. Useful for attaching events and popups to features.
           * The default is to do nothing with the newly created layers:
           * ```js
           * function (feature, layer) {}
           * ```
           *
           * @option filter: Function = *
           * A `Function` that will be used to decide whether to include a feature or not.
           * The default is to include all features:
           * ```js
           * function (geoJsonFeature) {
           * 	return true;
           * }
           * ```
           * Note: dynamically changing the `filter` option will have effect only on newly
           * added data. It will _not_ re-evaluate already included features.
           *
           * @option coordsToLatLng: Function = *
           * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
           * The default is the `coordsToLatLng` static method.
           *
           * @option markersInheritOptions: Boolean = false
           * Whether default Markers for "Point" type Features inherit from group options.
           */
          initialize: function(geojson, options) {
            setOptions(this, options);
            this._layers = {};
            if (geojson) {
              this.addData(geojson);
            }
          },
          // @method addData( <GeoJSON> data ): this
          // Adds a GeoJSON object to the layer.
          addData: function(geojson) {
            var features = isArray(geojson) ? geojson : geojson.features, i, len, feature2;
            if (features) {
              for (i = 0, len = features.length; i < len; i++) {
                feature2 = features[i];
                if (feature2.geometries || feature2.geometry || feature2.features || feature2.coordinates) {
                  this.addData(feature2);
                }
              }
              return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) {
              return this;
            }
            var layer = geometryToLayer(geojson, options);
            if (!layer) {
              return this;
            }
            layer.feature = asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) {
              options.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
          },
          // @method resetStyle( <Path> layer? ): this
          // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
          // If `layer` is omitted, the style of all features in the current layer is reset.
          resetStyle: function(layer) {
            if (layer === void 0) {
              return this.eachLayer(this.resetStyle, this);
            }
            layer.options = extend({}, layer.defaultOptions);
            this._setLayerStyle(layer, this.options.style);
            return this;
          },
          // @method setStyle( <Function> style ): this
          // Changes styles of GeoJSON vector layers with the given style function.
          setStyle: function(style2) {
            return this.eachLayer(function(layer) {
              this._setLayerStyle(layer, style2);
            }, this);
          },
          _setLayerStyle: function(layer, style2) {
            if (layer.setStyle) {
              if (typeof style2 === "function") {
                style2 = style2(layer.feature);
              }
              layer.setStyle(style2);
            }
          }
        });
        function geometryToLayer(geojson, options) {
          var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers3 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
          if (!coords && !geometry) {
            return null;
          }
          switch (geometry.type) {
            case "Point":
              latlng = _coordsToLatLng(coords);
              return _pointToLayer(pointToLayer, geojson, latlng, options);
            case "MultiPoint":
              for (i = 0, len = coords.length; i < len; i++) {
                latlng = _coordsToLatLng(coords[i]);
                layers3.push(_pointToLayer(pointToLayer, geojson, latlng, options));
              }
              return new FeatureGroup(layers3);
            case "LineString":
            case "MultiLineString":
              latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
              return new Polyline(latlngs, options);
            case "Polygon":
            case "MultiPolygon":
              latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
              return new Polygon(latlngs, options);
            case "GeometryCollection":
              for (i = 0, len = geometry.geometries.length; i < len; i++) {
                var geoLayer = geometryToLayer({
                  geometry: geometry.geometries[i],
                  type: "Feature",
                  properties: geojson.properties
                }, options);
                if (geoLayer) {
                  layers3.push(geoLayer);
                }
              }
              return new FeatureGroup(layers3);
            case "FeatureCollection":
              for (i = 0, len = geometry.features.length; i < len; i++) {
                var featureLayer = geometryToLayer(geometry.features[i], options);
                if (featureLayer) {
                  layers3.push(featureLayer);
                }
              }
              return new FeatureGroup(layers3);
            default:
              throw new Error("Invalid GeoJSON object.");
          }
        }
        function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
          return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
        }
        function coordsToLatLng(coords) {
          return new LatLng(coords[1], coords[0], coords[2]);
        }
        function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
          var latlngs = [];
          for (var i = 0, len = coords.length, latlng; i < len; i++) {
            latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
            latlngs.push(latlng);
          }
          return latlngs;
        }
        function latLngToCoords(latlng, precision) {
          latlng = toLatLng(latlng);
          return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
        }
        function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
          var coords = [];
          for (var i = 0, len = latlngs.length; i < len; i++) {
            coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
          }
          if (!levelsDeep && closed && coords.length > 0) {
            coords.push(coords[0].slice());
          }
          return coords;
        }
        function getFeature(layer, newGeometry) {
          return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
        }
        function asFeature(geojson) {
          if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
            return geojson;
          }
          return {
            type: "Feature",
            properties: {},
            geometry: geojson
          };
        }
        var PointToGeoJSON = {
          toGeoJSON: function(precision) {
            return getFeature(this, {
              type: "Point",
              coordinates: latLngToCoords(this.getLatLng(), precision)
            });
          }
        };
        Marker.include(PointToGeoJSON);
        Circle2.include(PointToGeoJSON);
        CircleMarker.include(PointToGeoJSON);
        Polyline.include({
          toGeoJSON: function(precision) {
            var multi = !isFlat(this._latlngs);
            var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "LineString",
              coordinates: coords
            });
          }
        });
        Polygon.include({
          toGeoJSON: function(precision) {
            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
            var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
            if (!holes) {
              coords = [coords];
            }
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "Polygon",
              coordinates: coords
            });
          }
        });
        LayerGroup.include({
          toMultiPoint: function(precision) {
            var coords = [];
            this.eachLayer(function(layer) {
              coords.push(layer.toGeoJSON(precision).geometry.coordinates);
            });
            return getFeature(this, {
              type: "MultiPoint",
              coordinates: coords
            });
          },
          // @method toGeoJSON(precision?: Number|false): Object
          // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
          // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
          toGeoJSON: function(precision) {
            var type = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (type === "MultiPoint") {
              return this.toMultiPoint(precision);
            }
            var isGeometryCollection = type === "GeometryCollection", jsons = [];
            this.eachLayer(function(layer) {
              if (layer.toGeoJSON) {
                var json = layer.toGeoJSON(precision);
                if (isGeometryCollection) {
                  jsons.push(json.geometry);
                } else {
                  var feature2 = asFeature(json);
                  if (feature2.type === "FeatureCollection") {
                    jsons.push.apply(jsons, feature2.features);
                  } else {
                    jsons.push(feature2);
                  }
                }
              }
            });
            if (isGeometryCollection) {
              return getFeature(this, {
                geometries: jsons,
                type: "GeometryCollection"
              });
            }
            return {
              type: "FeatureCollection",
              features: jsons
            };
          }
        });
        function geoJSON2(geojson, options) {
          return new GeoJSON(geojson, options);
        }
        var geoJson = geoJSON2;
        var ImageOverlay = Layer.extend({
          // @section
          // @aka ImageOverlay options
          options: {
            // @option opacity: Number = 1.0
            // The opacity of the image overlay.
            opacity: 1,
            // @option alt: String = ''
            // Text for the `alt` attribute of the image (useful for accessibility).
            alt: "",
            // @option interactive: Boolean = false
            // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
            interactive: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the image.
            // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option errorOverlayUrl: String = ''
            // URL to the overlay image to show in place of the overlay that failed to load.
            errorOverlayUrl: "",
            // @option zIndex: Number = 1
            // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
            zIndex: 1,
            // @option className: String = ''
            // A custom class name to assign to the image. Empty by default.
            className: ""
          },
          initialize: function(url, bounds, options) {
            this._url = url;
            this._bounds = toLatLngBounds(bounds);
            setOptions(this, options);
          },
          onAdd: function() {
            if (!this._image) {
              this._initImage();
              if (this.options.opacity < 1) {
                this._updateOpacity();
              }
            }
            if (this.options.interactive) {
              addClass(this._image, "leaflet-interactive");
              this.addInteractiveTarget(this._image);
            }
            this.getPane().appendChild(this._image);
            this._reset();
          },
          onRemove: function() {
            remove(this._image);
            if (this.options.interactive) {
              this.removeInteractiveTarget(this._image);
            }
          },
          // @method setOpacity(opacity: Number): this
          // Sets the opacity of the overlay.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._image) {
              this._updateOpacity();
            }
            return this;
          },
          setStyle: function(styleOpts) {
            if (styleOpts.opacity) {
              this.setOpacity(styleOpts.opacity);
            }
            return this;
          },
          // @method bringToFront(): this
          // Brings the layer to the top of all overlays.
          bringToFront: function() {
            if (this._map) {
              toFront(this._image);
            }
            return this;
          },
          // @method bringToBack(): this
          // Brings the layer to the bottom of all overlays.
          bringToBack: function() {
            if (this._map) {
              toBack(this._image);
            }
            return this;
          },
          // @method setUrl(url: String): this
          // Changes the URL of the image.
          setUrl: function(url) {
            this._url = url;
            if (this._image) {
              this._image.src = url;
            }
            return this;
          },
          // @method setBounds(bounds: LatLngBounds): this
          // Update the bounds that this ImageOverlay covers
          setBounds: function(bounds) {
            this._bounds = toLatLngBounds(bounds);
            if (this._map) {
              this._reset();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              zoom: this._reset,
              viewreset: this._reset
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @method setZIndex(value: Number): this
          // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
          setZIndex: function(value) {
            this.options.zIndex = value;
            this._updateZIndex();
            return this;
          },
          // @method getBounds(): LatLngBounds
          // Get the bounds that this ImageOverlay covers
          getBounds: function() {
            return this._bounds;
          },
          // @method getElement(): HTMLElement
          // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
          // used by this overlay.
          getElement: function() {
            return this._image;
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "IMG";
            var img = this._image = wasElementSupplied ? this._url : create$1("img");
            addClass(img, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(img, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(img, this.options.className);
            }
            img.onselectstart = falseFn;
            img.onmousemove = falseFn;
            img.onload = bind(this.fire, this, "load");
            img.onerror = bind(this._overlayOnError, this, "error");
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (this.options.zIndex) {
              this._updateZIndex();
            }
            if (wasElementSupplied) {
              this._url = img.src;
              return;
            }
            img.src = this._url;
            img.alt = this.options.alt;
          },
          _animateZoom: function(e) {
            var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
            setTransform(this._image, offset, scale2);
          },
          _reset: function() {
            var image = this._image, bounds = new Bounds(
              this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
              this._map.latLngToLayerPoint(this._bounds.getSouthEast())
            ), size = bounds.getSize();
            setPosition(image, bounds.min);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
          },
          _updateOpacity: function() {
            setOpacity(this._image, this.options.opacity);
          },
          _updateZIndex: function() {
            if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._image.style.zIndex = this.options.zIndex;
            }
          },
          _overlayOnError: function() {
            this.fire("error");
            var errorUrl = this.options.errorOverlayUrl;
            if (errorUrl && this._url !== errorUrl) {
              this._url = errorUrl;
              this._image.src = errorUrl;
            }
          },
          // @method getCenter(): LatLng
          // Returns the center of the ImageOverlay.
          getCenter: function() {
            return this._bounds.getCenter();
          }
        });
        var imageOverlay = function(url, bounds, options) {
          return new ImageOverlay(url, bounds, options);
        };
        var VideoOverlay = ImageOverlay.extend({
          // @section
          // @aka VideoOverlay options
          options: {
            // @option autoplay: Boolean = true
            // Whether the video starts playing automatically when loaded.
            // On some browsers autoplay will only work with `muted: true`
            autoplay: true,
            // @option loop: Boolean = true
            // Whether the video will loop back to the beginning when played.
            loop: true,
            // @option keepAspectRatio: Boolean = true
            // Whether the video will save aspect ratio after the projection.
            // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
            keepAspectRatio: true,
            // @option muted: Boolean = false
            // Whether the video starts on mute when loaded.
            muted: false,
            // @option playsInline: Boolean = true
            // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
            playsInline: true
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "VIDEO";
            var vid = this._image = wasElementSupplied ? this._url : create$1("video");
            addClass(vid, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(vid, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(vid, this.options.className);
            }
            vid.onselectstart = falseFn;
            vid.onmousemove = falseFn;
            vid.onloadeddata = bind(this.fire, this, "load");
            if (wasElementSupplied) {
              var sourceElements = vid.getElementsByTagName("source");
              var sources = [];
              for (var j = 0; j < sourceElements.length; j++) {
                sources.push(sourceElements[j].src);
              }
              this._url = sourceElements.length > 0 ? sources : [vid.src];
              return;
            }
            if (!isArray(this._url)) {
              this._url = [this._url];
            }
            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
              vid.style["objectFit"] = "fill";
            }
            vid.autoplay = !!this.options.autoplay;
            vid.loop = !!this.options.loop;
            vid.muted = !!this.options.muted;
            vid.playsInline = !!this.options.playsInline;
            for (var i = 0; i < this._url.length; i++) {
              var source = create$1("source");
              source.src = this._url[i];
              vid.appendChild(source);
            }
          }
          // @method getElement(): HTMLVideoElement
          // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
          // used by this overlay.
        });
        function videoOverlay(video, bounds, options) {
          return new VideoOverlay(video, bounds, options);
        }
        var SVGOverlay = ImageOverlay.extend({
          _initImage: function() {
            var el = this._image = this._url;
            addClass(el, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(el, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(el, this.options.className);
            }
            el.onselectstart = falseFn;
            el.onmousemove = falseFn;
          }
          // @method getElement(): SVGElement
          // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
          // used by this overlay.
        });
        function svgOverlay(el, bounds, options) {
          return new SVGOverlay(el, bounds, options);
        }
        var DivOverlay = Layer.extend({
          // @section
          // @aka DivOverlay options
          options: {
            // @option interactive: Boolean = false
            // If true, the popup/tooltip will listen to the mouse events.
            interactive: false,
            // @option offset: Point = Point(0, 0)
            // The offset of the overlay position.
            offset: [0, 0],
            // @option className: String = ''
            // A custom CSS class name to assign to the overlay.
            className: "",
            // @option pane: String = undefined
            // `Map pane` where the overlay will be added.
            pane: void 0,
            // @option content: String|HTMLElement|Function = ''
            // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
            // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
            content: ""
          },
          initialize: function(options, source) {
            if (options && (options instanceof LatLng || isArray(options))) {
              this._latlng = toLatLng(options);
              setOptions(this, source);
            } else {
              setOptions(this, options);
              this._source = source;
            }
            if (this.options.content) {
              this._content = this.options.content;
            }
          },
          // @method openOn(map: Map): this
          // Adds the overlay to the map.
          // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
          openOn: function(map3) {
            map3 = arguments.length ? map3 : this._source._map;
            if (!map3.hasLayer(this)) {
              map3.addLayer(this);
            }
            return this;
          },
          // @method close(): this
          // Closes the overlay.
          // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
          // and `layer.closePopup()`/`.closeTooltip()`.
          close: function() {
            if (this._map) {
              this._map.removeLayer(this);
            }
            return this;
          },
          // @method toggle(layer?: Layer): this
          // Opens or closes the overlay bound to layer depending on its current state.
          // Argument may be omitted only for overlay bound to layer.
          // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
          toggle: function(layer) {
            if (this._map) {
              this.close();
            } else {
              if (arguments.length) {
                this._source = layer;
              } else {
                layer = this._source;
              }
              this._prepareOpen();
              this.openOn(layer._map);
            }
            return this;
          },
          onAdd: function(map3) {
            this._zoomAnimated = map3._zoomAnimated;
            if (!this._container) {
              this._initLayout();
            }
            if (map3._fadeAnimated) {
              setOpacity(this._container, 0);
            }
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (map3._fadeAnimated) {
              setOpacity(this._container, 1);
            }
            this.bringToFront();
            if (this.options.interactive) {
              addClass(this._container, "leaflet-interactive");
              this.addInteractiveTarget(this._container);
            }
          },
          onRemove: function(map3) {
            if (map3._fadeAnimated) {
              setOpacity(this._container, 0);
              this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
            } else {
              remove(this._container);
            }
            if (this.options.interactive) {
              removeClass(this._container, "leaflet-interactive");
              this.removeInteractiveTarget(this._container);
            }
          },
          // @namespace DivOverlay
          // @method getLatLng: LatLng
          // Returns the geographical point of the overlay.
          getLatLng: function() {
            return this._latlng;
          },
          // @method setLatLng(latlng: LatLng): this
          // Sets the geographical point where the overlay will open.
          setLatLng: function(latlng) {
            this._latlng = toLatLng(latlng);
            if (this._map) {
              this._updatePosition();
              this._adjustPan();
            }
            return this;
          },
          // @method getContent: String|HTMLElement
          // Returns the content of the overlay.
          getContent: function() {
            return this._content;
          },
          // @method setContent(htmlContent: String|HTMLElement|Function): this
          // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
          // The function should return a `String` or `HTMLElement` to be used in the overlay.
          setContent: function(content) {
            this._content = content;
            this.update();
            return this;
          },
          // @method getElement: String|HTMLElement
          // Returns the HTML container of the overlay.
          getElement: function() {
            return this._container;
          },
          // @method update: null
          // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
          update: function() {
            if (!this._map) {
              return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
          },
          getEvents: function() {
            var events = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @method isOpen: Boolean
          // Returns `true` when the overlay is visible on the map.
          isOpen: function() {
            return !!this._map && this._map.hasLayer(this);
          },
          // @method bringToFront: this
          // Brings this overlay in front of other overlays (in the same map pane).
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
            }
            return this;
          },
          // @method bringToBack: this
          // Brings this overlay to the back of other overlays (in the same map pane).
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
            }
            return this;
          },
          // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
          _prepareOpen: function(latlng) {
            var source = this._source;
            if (!source._map) {
              return false;
            }
            if (source instanceof FeatureGroup) {
              source = null;
              var layers3 = this._source._layers;
              for (var id in layers3) {
                if (layers3[id]._map) {
                  source = layers3[id];
                  break;
                }
              }
              if (!source) {
                return false;
              }
              this._source = source;
            }
            if (!latlng) {
              if (source.getCenter) {
                latlng = source.getCenter();
              } else if (source.getLatLng) {
                latlng = source.getLatLng();
              } else if (source.getBounds) {
                latlng = source.getBounds().getCenter();
              } else {
                throw new Error("Unable to get source layer LatLng.");
              }
            }
            this.setLatLng(latlng);
            if (this._map) {
              this.update();
            }
            return true;
          },
          _updateContent: function() {
            if (!this._content) {
              return;
            }
            var node = this._contentNode;
            var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
            if (typeof content === "string") {
              node.innerHTML = content;
            } else {
              while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
              }
              node.appendChild(content);
            }
            this.fire("contentupdate");
          },
          _updatePosition: function() {
            if (!this._map) {
              return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (this._zoomAnimated) {
              setPosition(this._container, pos.add(anchor));
            } else {
              offset = offset.add(pos).add(anchor);
            }
            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
            this._container.style.bottom = bottom + "px";
            this._container.style.left = left + "px";
          },
          _getAnchor: function() {
            return [0, 0];
          }
        });
        Map2.include({
          _initOverlay: function(OverlayClass, content, latlng, options) {
            var overlay = content;
            if (!(overlay instanceof OverlayClass)) {
              overlay = new OverlayClass(options).setContent(content);
            }
            if (latlng) {
              overlay.setLatLng(latlng);
            }
            return overlay;
          }
        });
        Layer.include({
          _initOverlay: function(OverlayClass, old, content, options) {
            var overlay = content;
            if (overlay instanceof OverlayClass) {
              setOptions(overlay, options);
              overlay._source = this;
            } else {
              overlay = old && !options ? old : new OverlayClass(options, this);
              overlay.setContent(content);
            }
            return overlay;
          }
        });
        var Popup = DivOverlay.extend({
          // @section
          // @aka Popup options
          options: {
            // @option pane: String = 'popupPane'
            // `Map pane` where the popup will be added.
            pane: "popupPane",
            // @option offset: Point = Point(0, 7)
            // The offset of the popup position.
            offset: [0, 7],
            // @option maxWidth: Number = 300
            // Max width of the popup, in pixels.
            maxWidth: 300,
            // @option minWidth: Number = 50
            // Min width of the popup, in pixels.
            minWidth: 50,
            // @option maxHeight: Number = null
            // If set, creates a scrollable container of the given height
            // inside a popup if its content exceeds it.
            // The scrollable container can be styled using the
            // `leaflet-popup-scrolled` CSS class selector.
            maxHeight: null,
            // @option autoPan: Boolean = true
            // Set it to `false` if you don't want the map to do panning animation
            // to fit the opened popup.
            autoPan: true,
            // @option autoPanPaddingTopLeft: Point = null
            // The margin between the popup and the top left corner of the map
            // view after autopanning was performed.
            autoPanPaddingTopLeft: null,
            // @option autoPanPaddingBottomRight: Point = null
            // The margin between the popup and the bottom right corner of the map
            // view after autopanning was performed.
            autoPanPaddingBottomRight: null,
            // @option autoPanPadding: Point = Point(5, 5)
            // Equivalent of setting both top left and bottom right autopan padding to the same value.
            autoPanPadding: [5, 5],
            // @option keepInView: Boolean = false
            // Set it to `true` if you want to prevent users from panning the popup
            // off of the screen while it is open.
            keepInView: false,
            // @option closeButton: Boolean = true
            // Controls the presence of a close button in the popup.
            closeButton: true,
            // @option autoClose: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the popup closing when another popup is opened.
            autoClose: true,
            // @option closeOnEscapeKey: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the ESC key for closing of the popup.
            closeOnEscapeKey: true,
            // @option closeOnClick: Boolean = *
            // Set it if you want to override the default behavior of the popup closing when user clicks
            // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
            // @option className: String = ''
            // A custom CSS class name to assign to the popup.
            className: ""
          },
          // @namespace Popup
          // @method openOn(map: Map): this
          // Alternative to `map.openPopup(popup)`.
          // Adds the popup to the map and closes the previous one.
          openOn: function(map3) {
            map3 = arguments.length ? map3 : this._source._map;
            if (!map3.hasLayer(this) && map3._popup && map3._popup.options.autoClose) {
              map3.removeLayer(map3._popup);
            }
            map3._popup = this;
            return DivOverlay.prototype.openOn.call(this, map3);
          },
          onAdd: function(map3) {
            DivOverlay.prototype.onAdd.call(this, map3);
            map3.fire("popupopen", { popup: this });
            if (this._source) {
              this._source.fire("popupopen", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.on("preclick", stopPropagation);
              }
            }
          },
          onRemove: function(map3) {
            DivOverlay.prototype.onRemove.call(this, map3);
            map3.fire("popupclose", { popup: this });
            if (this._source) {
              this._source.fire("popupclose", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.off("preclick", stopPropagation);
              }
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
              events.preclick = this.close;
            }
            if (this.options.keepInView) {
              events.moveend = this._adjustPan;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-popup", container = this._container = create$1(
              "div",
              prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
            );
            var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
            this._contentNode = create$1("div", prefix + "-content", wrapper);
            disableClickPropagation(container);
            disableScrollPropagation(this._contentNode);
            on(container, "contextmenu", stopPropagation);
            this._tipContainer = create$1("div", prefix + "-tip-container", container);
            this._tip = create$1("div", prefix + "-tip", this._tipContainer);
            if (this.options.closeButton) {
              var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
              closeButton.setAttribute("role", "button");
              closeButton.setAttribute("aria-label", "Close popup");
              closeButton.href = "#close";
              closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
              on(closeButton, "click", function(ev) {
                preventDefault(ev);
                this.close();
              }, this);
            }
          },
          _updateLayout: function() {
            var container = this._contentNode, style2 = container.style;
            style2.width = "";
            style2.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style2.width = width + 1 + "px";
            style2.whiteSpace = "";
            style2.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
              style2.height = maxHeight + "px";
              addClass(container, scrolledClass);
            } else {
              removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
            setPosition(this._container, pos.add(anchor));
          },
          _adjustPan: function() {
            if (!this.options.autoPan) {
              return;
            }
            if (this._map._panAnim) {
              this._map._panAnim.stop();
            }
            if (this._autopanning) {
              this._autopanning = false;
              return;
            }
            var map3 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
            layerPos._add(getPosition(this._container));
            var containerPos = map3.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map3.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
              dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
              dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
              dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
              dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
              if (this.options.keepInView) {
                this._autopanning = true;
              }
              map3.fire("autopanstart").panBy([dx, dy]);
            }
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
          }
        });
        var popup = function(options, source) {
          return new Popup(options, source);
        };
        Map2.mergeOptions({
          closePopupOnClick: true
        });
        Map2.include({
          // @method openPopup(popup: Popup): this
          // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
          // @alternative
          // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
          // Creates a popup with the specified content and options and opens it in the given point on a map.
          openPopup: function(popup2, latlng, options) {
            this._initOverlay(Popup, popup2, latlng, options).openOn(this);
            return this;
          },
          // @method closePopup(popup?: Popup): this
          // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
          closePopup: function(popup2) {
            popup2 = arguments.length ? popup2 : this._popup;
            if (popup2) {
              popup2.close();
            }
            return this;
          }
        });
        Layer.include({
          // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
          // Binds a popup to the layer with the passed `content` and sets up the
          // necessary event listeners. If a `Function` is passed it will receive
          // the layer as the first argument and should return a `String` or `HTMLElement`.
          bindPopup: function(content, options) {
            this._popup = this._initOverlay(Popup, this._popup, content, options);
            if (!this._popupHandlersAdded) {
              this.on({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = true;
            }
            return this;
          },
          // @method unbindPopup(): this
          // Removes the popup previously bound with `bindPopup`.
          unbindPopup: function() {
            if (this._popup) {
              this.off({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = false;
              this._popup = null;
            }
            return this;
          },
          // @method openPopup(latlng?: LatLng): this
          // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
          openPopup: function(latlng) {
            if (this._popup) {
              if (!(this instanceof FeatureGroup)) {
                this._popup._source = this;
              }
              if (this._popup._prepareOpen(latlng || this._latlng)) {
                this._popup.openOn(this._map);
              }
            }
            return this;
          },
          // @method closePopup(): this
          // Closes the popup bound to this layer if it is open.
          closePopup: function() {
            if (this._popup) {
              this._popup.close();
            }
            return this;
          },
          // @method togglePopup(): this
          // Opens or closes the popup bound to this layer depending on its current state.
          togglePopup: function() {
            if (this._popup) {
              this._popup.toggle(this);
            }
            return this;
          },
          // @method isPopupOpen(): boolean
          // Returns `true` if the popup bound to this layer is currently open.
          isPopupOpen: function() {
            return this._popup ? this._popup.isOpen() : false;
          },
          // @method setPopupContent(content: String|HTMLElement|Popup): this
          // Sets the content of the popup bound to this layer.
          setPopupContent: function(content) {
            if (this._popup) {
              this._popup.setContent(content);
            }
            return this;
          },
          // @method getPopup(): Popup
          // Returns the popup bound to this layer.
          getPopup: function() {
            return this._popup;
          },
          _openPopup: function(e) {
            if (!this._popup || !this._map) {
              return;
            }
            stop(e);
            var target = e.layer || e.target;
            if (this._popup._source === target && !(target instanceof Path)) {
              if (this._map.hasLayer(this._popup)) {
                this.closePopup();
              } else {
                this.openPopup(e.latlng);
              }
              return;
            }
            this._popup._source = target;
            this.openPopup(e.latlng);
          },
          _movePopup: function(e) {
            this._popup.setLatLng(e.latlng);
          },
          _onKeyPress: function(e) {
            if (e.originalEvent.keyCode === 13) {
              this._openPopup(e);
            }
          }
        });
        var Tooltip = DivOverlay.extend({
          // @section
          // @aka Tooltip options
          options: {
            // @option pane: String = 'tooltipPane'
            // `Map pane` where the tooltip will be added.
            pane: "tooltipPane",
            // @option offset: Point = Point(0, 0)
            // Optional offset of the tooltip position.
            offset: [0, 0],
            // @option direction: String = 'auto'
            // Direction where to open the tooltip. Possible values are: `right`, `left`,
            // `top`, `bottom`, `center`, `auto`.
            // `auto` will dynamically switch between `right` and `left` according to the tooltip
            // position on the map.
            direction: "auto",
            // @option permanent: Boolean = false
            // Whether to open the tooltip permanently or only on mouseover.
            permanent: false,
            // @option sticky: Boolean = false
            // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
            sticky: false,
            // @option opacity: Number = 0.9
            // Tooltip container opacity.
            opacity: 0.9
          },
          onAdd: function(map3) {
            DivOverlay.prototype.onAdd.call(this, map3);
            this.setOpacity(this.options.opacity);
            map3.fire("tooltipopen", { tooltip: this });
            if (this._source) {
              this.addEventParent(this._source);
              this._source.fire("tooltipopen", { tooltip: this }, true);
            }
          },
          onRemove: function(map3) {
            DivOverlay.prototype.onRemove.call(this, map3);
            map3.fire("tooltipclose", { tooltip: this });
            if (this._source) {
              this.removeEventParent(this._source);
              this._source.fire("tooltipclose", { tooltip: this }, true);
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (!this.options.permanent) {
              events.preclick = this.close;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = create$1("div", className);
            this._container.setAttribute("role", "tooltip");
            this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
          },
          _updateLayout: function() {
          },
          _adjustPan: function() {
          },
          _setPosition: function(pos) {
            var subX, subY, map3 = this._map, container = this._container, centerPoint = map3.latLngToContainerPoint(map3.getCenter()), tooltipPoint = map3.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (direction === "top") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight;
            } else if (direction === "bottom") {
              subX = tooltipWidth / 2;
              subY = 0;
            } else if (direction === "center") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight / 2;
            } else if (direction === "right") {
              subX = 0;
              subY = tooltipHeight / 2;
            } else if (direction === "left") {
              subX = tooltipWidth;
              subY = tooltipHeight / 2;
            } else if (tooltipPoint.x < centerPoint.x) {
              direction = "right";
              subX = 0;
              subY = tooltipHeight / 2;
            } else {
              direction = "left";
              subX = tooltipWidth + (offset.x + anchor.x) * 2;
              subY = tooltipHeight / 2;
            }
            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
            removeClass(container, "leaflet-tooltip-right");
            removeClass(container, "leaflet-tooltip-left");
            removeClass(container, "leaflet-tooltip-top");
            removeClass(container, "leaflet-tooltip-bottom");
            addClass(container, "leaflet-tooltip-" + direction);
            setPosition(container, pos);
          },
          _updatePosition: function() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._container) {
              setOpacity(this._container, opacity);
            }
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
            this._setPosition(pos);
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
          }
        });
        var tooltip = function(options, source) {
          return new Tooltip(options, source);
        };
        Map2.include({
          // @method openTooltip(tooltip: Tooltip): this
          // Opens the specified tooltip.
          // @alternative
          // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
          // Creates a tooltip with the specified content and options and open it.
          openTooltip: function(tooltip2, latlng, options) {
            this._initOverlay(Tooltip, tooltip2, latlng, options).openOn(this);
            return this;
          },
          // @method closeTooltip(tooltip: Tooltip): this
          // Closes the tooltip given as parameter.
          closeTooltip: function(tooltip2) {
            tooltip2.close();
            return this;
          }
        });
        Layer.include({
          // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
          // Binds a tooltip to the layer with the passed `content` and sets up the
          // necessary event listeners. If a `Function` is passed it will receive
          // the layer as the first argument and should return a `String` or `HTMLElement`.
          bindTooltip: function(content, options) {
            if (this._tooltip && this.isTooltipOpen()) {
              this.unbindTooltip();
            }
            this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
            this._initTooltipInteractions();
            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
              this.openTooltip();
            }
            return this;
          },
          // @method unbindTooltip(): this
          // Removes the tooltip previously bound with `bindTooltip`.
          unbindTooltip: function() {
            if (this._tooltip) {
              this._initTooltipInteractions(true);
              this.closeTooltip();
              this._tooltip = null;
            }
            return this;
          },
          _initTooltipInteractions: function(remove2) {
            if (!remove2 && this._tooltipHandlersAdded) {
              return;
            }
            var onOff = remove2 ? "off" : "on", events = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            if (!this._tooltip.options.permanent) {
              events.mouseover = this._openTooltip;
              events.mouseout = this.closeTooltip;
              events.click = this._openTooltip;
              if (this._map) {
                this._addFocusListeners();
              } else {
                events.add = this._addFocusListeners;
              }
            } else {
              events.add = this._openTooltip;
            }
            if (this._tooltip.options.sticky) {
              events.mousemove = this._moveTooltip;
            }
            this[onOff](events);
            this._tooltipHandlersAdded = !remove2;
          },
          // @method openTooltip(latlng?: LatLng): this
          // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
          openTooltip: function(latlng) {
            if (this._tooltip) {
              if (!(this instanceof FeatureGroup)) {
                this._tooltip._source = this;
              }
              if (this._tooltip._prepareOpen(latlng)) {
                this._tooltip.openOn(this._map);
                if (this.getElement) {
                  this._setAriaDescribedByOnLayer(this);
                } else if (this.eachLayer) {
                  this.eachLayer(this._setAriaDescribedByOnLayer, this);
                }
              }
            }
            return this;
          },
          // @method closeTooltip(): this
          // Closes the tooltip bound to this layer if it is open.
          closeTooltip: function() {
            if (this._tooltip) {
              return this._tooltip.close();
            }
          },
          // @method toggleTooltip(): this
          // Opens or closes the tooltip bound to this layer depending on its current state.
          toggleTooltip: function() {
            if (this._tooltip) {
              this._tooltip.toggle(this);
            }
            return this;
          },
          // @method isTooltipOpen(): boolean
          // Returns `true` if the tooltip bound to this layer is currently open.
          isTooltipOpen: function() {
            return this._tooltip.isOpen();
          },
          // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
          // Sets the content of the tooltip bound to this layer.
          setTooltipContent: function(content) {
            if (this._tooltip) {
              this._tooltip.setContent(content);
            }
            return this;
          },
          // @method getTooltip(): Tooltip
          // Returns the tooltip bound to this layer.
          getTooltip: function() {
            return this._tooltip;
          },
          _addFocusListeners: function() {
            if (this.getElement) {
              this._addFocusListenersOnLayer(this);
            } else if (this.eachLayer) {
              this.eachLayer(this._addFocusListenersOnLayer, this);
            }
          },
          _addFocusListenersOnLayer: function(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) {
              on(el, "focus", function() {
                this._tooltip._source = layer;
                this.openTooltip();
              }, this);
              on(el, "blur", this.closeTooltip, this);
            }
          },
          _setAriaDescribedByOnLayer: function(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) {
              el.setAttribute("aria-describedby", this._tooltip._container.id);
            }
          },
          _openTooltip: function(e) {
            if (!this._tooltip || !this._map) {
              return;
            }
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
              this._openOnceFlag = true;
              var that = this;
              this._map.once("moveend", function() {
                that._openOnceFlag = false;
                that._openTooltip(e);
              });
              return;
            }
            this._tooltip._source = e.layer || e.target;
            this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
          },
          _moveTooltip: function(e) {
            var latlng = e.latlng, containerPoint, layerPoint;
            if (this._tooltip.options.sticky && e.originalEvent) {
              containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
              layerPoint = this._map.containerPointToLayerPoint(containerPoint);
              latlng = this._map.layerPointToLatLng(layerPoint);
            }
            this._tooltip.setLatLng(latlng);
          }
        });
        var DivIcon = Icon.extend({
          options: {
            // @section
            // @aka DivIcon options
            iconSize: [12, 12],
            // also can be set through CSS
            // iconAnchor: (Point),
            // popupAnchor: (Point),
            // @option html: String|HTMLElement = ''
            // Custom HTML code to put inside the div element, empty by default. Alternatively,
            // an instance of `HTMLElement`.
            html: false,
            // @option bgPos: Point = [0, 0]
            // Optional relative position of the background, in pixels
            bgPos: null,
            className: "leaflet-div-icon"
          },
          createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html instanceof Element) {
              empty(div);
              div.appendChild(options.html);
            } else {
              div.innerHTML = options.html !== false ? options.html : "";
            }
            if (options.bgPos) {
              var bgPos = toPoint(options.bgPos);
              div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
          },
          createShadow: function() {
            return null;
          }
        });
        function divIcon(options) {
          return new DivIcon(options);
        }
        Icon.Default = IconDefault;
        var GridLayer = Layer.extend({
          // @section
          // @aka GridLayer options
          options: {
            // @option tileSize: Number|Point = 256
            // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
            tileSize: 256,
            // @option opacity: Number = 1.0
            // Opacity of the tiles. Can be used in the `createTile()` function.
            opacity: 1,
            // @option updateWhenIdle: Boolean = (depends)
            // Load new tiles only when panning ends.
            // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
            // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
            // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
            updateWhenIdle: Browser.mobile,
            // @option updateWhenZooming: Boolean = true
            // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
            updateWhenZooming: true,
            // @option updateInterval: Number = 200
            // Tiles will not update more than once every `updateInterval` milliseconds when panning.
            updateInterval: 200,
            // @option zIndex: Number = 1
            // The explicit zIndex of the tile layer.
            zIndex: 1,
            // @option bounds: LatLngBounds = undefined
            // If set, tiles will only be loaded inside the set `LatLngBounds`.
            bounds: null,
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = undefined
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: void 0,
            // @option maxNativeZoom: Number = undefined
            // Maximum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
            // from `maxNativeZoom` level and auto-scaled.
            maxNativeZoom: void 0,
            // @option minNativeZoom: Number = undefined
            // Minimum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
            // from `minNativeZoom` level and auto-scaled.
            minNativeZoom: void 0,
            // @option noWrap: Boolean = false
            // Whether the layer is wrapped around the antimeridian. If `true`, the
            // GridLayer will only be displayed once at low zoom levels. Has no
            // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
            // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
            // tiles outside the CRS limits.
            noWrap: false,
            // @option pane: String = 'tilePane'
            // `Map pane` where the grid layer will be added.
            pane: "tilePane",
            // @option className: String = ''
            // A custom class name to assign to the tile layer. Empty by default.
            className: "",
            // @option keepBuffer: Number = 2
            // When panning the map, keep this many rows and columns of tiles before unloading them.
            keepBuffer: 2
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          onAdd: function() {
            this._initContainer();
            this._levels = {};
            this._tiles = {};
            this._resetView();
          },
          beforeAdd: function(map3) {
            map3._addZoomLimit(this);
          },
          onRemove: function(map3) {
            this._removeAllTiles();
            remove(this._container);
            map3._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = void 0;
          },
          // @method bringToFront: this
          // Brings the tile layer to the top of all tile layers.
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
              this._setAutoZIndex(Math.max);
            }
            return this;
          },
          // @method bringToBack: this
          // Brings the tile layer to the bottom of all tile layers.
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
              this._setAutoZIndex(Math.min);
            }
            return this;
          },
          // @method getContainer: HTMLElement
          // Returns the HTML element that contains the tiles for this layer.
          getContainer: function() {
            return this._container;
          },
          // @method setOpacity(opacity: Number): this
          // Changes the [opacity](#gridlayer-opacity) of the grid layer.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
          },
          // @method setZIndex(zIndex: Number): this
          // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
          setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
          },
          // @method isLoading: Boolean
          // Returns `true` if any tile in the grid layer has not finished loading.
          isLoading: function() {
            return this._loading;
          },
          // @method redraw: this
          // Causes the layer to clear all the tiles and request them again.
          redraw: function() {
            if (this._map) {
              this._removeAllTiles();
              var tileZoom = this._clampZoom(this._map.getZoom());
              if (tileZoom !== this._tileZoom) {
                this._tileZoom = tileZoom;
                this._updateLevels();
              }
              this._update();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
            };
            if (!this.options.updateWhenIdle) {
              if (!this._onMove) {
                this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
              }
              events.move = this._onMove;
            }
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @section Extension methods
          // Layers extending `GridLayer` shall reimplement the following method.
          // @method createTile(coords: Object, done?: Function): HTMLElement
          // Called only internally, must be overridden by classes extending `GridLayer`.
          // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
          // is specified, it must be called when the tile has finished loading and drawing.
          createTile: function() {
            return document.createElement("div");
          },
          // @section
          // @method getTileSize: Point
          // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
          getTileSize: function() {
            var s = this.options.tileSize;
            return s instanceof Point ? s : new Point(s, s);
          },
          _updateZIndex: function() {
            if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._container.style.zIndex = this.options.zIndex;
            }
          },
          _setAutoZIndex: function(compare) {
            var layers3 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
            for (var i = 0, len = layers3.length, zIndex; i < len; i++) {
              zIndex = layers3[i].style.zIndex;
              if (layers3[i] !== this._container && zIndex) {
                edgeZIndex = compare(edgeZIndex, +zIndex);
              }
            }
            if (isFinite(edgeZIndex)) {
              this.options.zIndex = edgeZIndex + compare(-1, 1);
              this._updateZIndex();
            }
          },
          _updateOpacity: function() {
            if (!this._map) {
              return;
            }
            if (Browser.ielt9) {
              return;
            }
            setOpacity(this._container, this.options.opacity);
            var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
            for (var key in this._tiles) {
              var tile = this._tiles[key];
              if (!tile.current || !tile.loaded) {
                continue;
              }
              var fade = Math.min(1, (now - tile.loaded) / 200);
              setOpacity(tile.el, fade);
              if (fade < 1) {
                nextFrame = true;
              } else {
                if (tile.active) {
                  willPrune = true;
                } else {
                  this._onOpaqueTile(tile);
                }
                tile.active = true;
              }
            }
            if (willPrune && !this._noPrune) {
              this._pruneTiles();
            }
            if (nextFrame) {
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            }
          },
          _onOpaqueTile: falseFn,
          _initContainer: function() {
            if (this._container) {
              return;
            }
            this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
            this._updateZIndex();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
            this.getPane().appendChild(this._container);
          },
          _updateLevels: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
            if (zoom2 === void 0) {
              return void 0;
            }
            for (var z in this._levels) {
              z = Number(z);
              if (this._levels[z].el.children.length || z === zoom2) {
                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
                this._onUpdateLevel(z);
              } else {
                remove(this._levels[z].el);
                this._removeTilesAtZoom(z);
                this._onRemoveLevel(z);
                delete this._levels[z];
              }
            }
            var level = this._levels[zoom2], map3 = this._map;
            if (!level) {
              level = this._levels[zoom2] = {};
              level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
              level.el.style.zIndex = maxZoom;
              level.origin = map3.project(map3.unproject(map3.getPixelOrigin()), zoom2).round();
              level.zoom = zoom2;
              this._setZoomTransform(level, map3.getCenter(), map3.getZoom());
              falseFn(level.el.offsetWidth);
              this._onCreateLevel(level);
            }
            this._level = level;
            return level;
          },
          _onUpdateLevel: falseFn,
          _onRemoveLevel: falseFn,
          _onCreateLevel: falseFn,
          _pruneTiles: function() {
            if (!this._map) {
              return;
            }
            var key, tile;
            var zoom2 = this._map.getZoom();
            if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              tile.retain = tile.current;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              if (tile.current && !tile.active) {
                var coords = tile.coords;
                if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                  this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                }
              }
            }
            for (key in this._tiles) {
              if (!this._tiles[key].retain) {
                this._removeTile(key);
              }
            }
          },
          _removeTilesAtZoom: function(zoom2) {
            for (var key in this._tiles) {
              if (this._tiles[key].coords.z !== zoom2) {
                continue;
              }
              this._removeTile(key);
            }
          },
          _removeAllTiles: function() {
            for (var key in this._tiles) {
              this._removeTile(key);
            }
          },
          _invalidateAll: function() {
            for (var z in this._levels) {
              remove(this._levels[z].el);
              this._onRemoveLevel(Number(z));
              delete this._levels[z];
            }
            this._removeAllTiles();
            this._tileZoom = void 0;
          },
          _retainParent: function(x2, y2, z, minZoom) {
            var x22 = Math.floor(x2 / 2), y22 = Math.floor(y2 / 2), z2 = z - 1, coords2 = new Point(+x22, +y22);
            coords2.z = +z2;
            var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
            if (tile && tile.active) {
              tile.retain = true;
              return true;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }
            if (z2 > minZoom) {
              return this._retainParent(x22, y22, z2, minZoom);
            }
            return false;
          },
          _retainChildren: function(x2, y2, z, maxZoom) {
            for (var i = 2 * x2; i < 2 * x2 + 2; i++) {
              for (var j = 2 * y2; j < 2 * y2 + 2; j++) {
                var coords = new Point(i, j);
                coords.z = z + 1;
                var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                if (tile && tile.active) {
                  tile.retain = true;
                  continue;
                } else if (tile && tile.loaded) {
                  tile.retain = true;
                }
                if (z + 1 < maxZoom) {
                  this._retainChildren(i, j, z + 1, maxZoom);
                }
              }
            }
          },
          _resetView: function(e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
          },
          _animateZoom: function(e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
          },
          _clampZoom: function(zoom2) {
            var options = this.options;
            if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
              return options.minNativeZoom;
            }
            if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
              return options.maxNativeZoom;
            }
            return zoom2;
          },
          _setView: function(center2, zoom2, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom2);
            if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
              tileZoom = void 0;
            } else {
              tileZoom = this._clampZoom(tileZoom);
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
              this._tileZoom = tileZoom;
              if (this._abortLoading) {
                this._abortLoading();
              }
              this._updateLevels();
              this._resetGrid();
              if (tileZoom !== void 0) {
                this._update(center2);
              }
              if (!noPrune) {
                this._pruneTiles();
              }
              this._noPrune = !!noPrune;
            }
            this._setZoomTransforms(center2, zoom2);
          },
          _setZoomTransforms: function(center2, zoom2) {
            for (var i in this._levels) {
              this._setZoomTransform(this._levels[i], center2, zoom2);
            }
          },
          _setZoomTransform: function(level, center2, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center2, zoom2)).round();
            if (Browser.any3d) {
              setTransform(level.el, translate, scale2);
            } else {
              setPosition(level.el, translate);
            }
          },
          _resetGrid: function() {
            var map3 = this._map, crs = map3.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
            var bounds = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds) {
              this._globalTileRange = this._pxBoundsToTileRange(bounds);
            }
            this._wrapX = crs.wrapLng && !this.options.noWrap && [
              Math.floor(map3.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
              Math.ceil(map3.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
            ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
              Math.floor(map3.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
              Math.ceil(map3.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
            ];
          },
          _onMoveEnd: function() {
            if (!this._map || this._map._animatingZoom) {
              return;
            }
            this._update();
          },
          _getTiledPixelBounds: function(center2) {
            var map3 = this._map, mapZoom = map3._animatingZoom ? Math.max(map3._animateToZoom, map3.getZoom()) : map3.getZoom(), scale2 = map3.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map3.project(center2, this._tileZoom).floor(), halfSize = map3.getSize().divideBy(scale2 * 2);
            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
          },
          // Private method to load tiles in the grid's active zoom level according to map bounds
          _update: function(center2) {
            var map3 = this._map;
            if (!map3) {
              return;
            }
            var zoom2 = this._clampZoom(map3.getZoom());
            if (center2 === void 0) {
              center2 = map3.getCenter();
            }
            if (this._tileZoom === void 0) {
              return;
            }
            var pixelBounds = this._getTiledPixelBounds(center2), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
              tileRange.getBottomLeft().subtract([margin, -margin]),
              tileRange.getTopRight().add([margin, -margin])
            );
            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
              throw new Error("Attempted to load an infinite number of tiles");
            }
            for (var key in this._tiles) {
              var c = this._tiles[key].coords;
              if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
                this._tiles[key].current = false;
              }
            }
            if (Math.abs(zoom2 - this._tileZoom) > 1) {
              this._setView(center2, zoom2);
              return;
            }
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
              for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                var coords = new Point(i, j);
                coords.z = this._tileZoom;
                if (!this._isValidTile(coords)) {
                  continue;
                }
                var tile = this._tiles[this._tileCoordsToKey(coords)];
                if (tile) {
                  tile.current = true;
                } else {
                  queue.push(coords);
                }
              }
            }
            queue.sort(function(a, b) {
              return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
              if (!this._loading) {
                this._loading = true;
                this.fire("loading");
              }
              var fragment = document.createDocumentFragment();
              for (i = 0; i < queue.length; i++) {
                this._addTile(queue[i], fragment);
              }
              this._level.el.appendChild(fragment);
            }
          },
          _isValidTile: function(coords) {
            var crs = this._map.options.crs;
            if (!crs.infinite) {
              var bounds = this._globalTileRange;
              if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
                return false;
              }
            }
            if (!this.options.bounds) {
              return true;
            }
            var tileBounds = this._tileCoordsToBounds(coords);
            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
          },
          _keyToBounds: function(key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
          },
          _tileCoordsToNwSe: function(coords) {
            var map3 = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map3.unproject(nwPoint, coords.z), se = map3.unproject(sePoint, coords.z);
            return [nw, se];
          },
          // converts tile coordinates to its geographical bounds
          _tileCoordsToBounds: function(coords) {
            var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
            if (!this.options.noWrap) {
              bounds = this._map.wrapLatLngBounds(bounds);
            }
            return bounds;
          },
          // converts tile coordinates to key for the tile cache
          _tileCoordsToKey: function(coords) {
            return coords.x + ":" + coords.y + ":" + coords.z;
          },
          // converts tile cache key to coordinates
          _keyToTileCoords: function(key) {
            var k = key.split(":"), coords = new Point(+k[0], +k[1]);
            coords.z = +k[2];
            return coords;
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            remove(tile.el);
            delete this._tiles[key];
            this.fire("tileunload", {
              tile: tile.el,
              coords: this._keyToTileCoords(key)
            });
          },
          _initTile: function(tile) {
            addClass(tile, "leaflet-tile");
            var tileSize = this.getTileSize();
            tile.style.width = tileSize.x + "px";
            tile.style.height = tileSize.y + "px";
            tile.onselectstart = falseFn;
            tile.onmousemove = falseFn;
            if (Browser.ielt9 && this.options.opacity < 1) {
              setOpacity(tile, this.options.opacity);
            }
          },
          _addTile: function(coords, container) {
            var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
            var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
            this._initTile(tile);
            if (this.createTile.length < 2) {
              requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
            }
            setPosition(tile, tilePos);
            this._tiles[key] = {
              el: tile,
              coords,
              current: true
            };
            container.appendChild(tile);
            this.fire("tileloadstart", {
              tile,
              coords
            });
          },
          _tileReady: function(coords, err, tile) {
            if (err) {
              this.fire("tileerror", {
                error: err,
                tile,
                coords
              });
            }
            var key = this._tileCoordsToKey(coords);
            tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.loaded = +/* @__PURE__ */ new Date();
            if (this._map._fadeAnimated) {
              setOpacity(tile.el, 0);
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            } else {
              tile.active = true;
              this._pruneTiles();
            }
            if (!err) {
              addClass(tile.el, "leaflet-tile-loaded");
              this.fire("tileload", {
                tile: tile.el,
                coords
              });
            }
            if (this._noTilesToLoad()) {
              this._loading = false;
              this.fire("load");
              if (Browser.ielt9 || !this._map._fadeAnimated) {
                requestAnimFrame(this._pruneTiles, this);
              } else {
                setTimeout(bind(this._pruneTiles, this), 250);
              }
            }
          },
          _getTilePos: function(coords) {
            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
          },
          _wrapCoords: function(coords) {
            var newCoords = new Point(
              this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
              this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
            );
            newCoords.z = coords.z;
            return newCoords;
          },
          _pxBoundsToTileRange: function(bounds) {
            var tileSize = this.getTileSize();
            return new Bounds(
              bounds.min.unscaleBy(tileSize).floor(),
              bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
            );
          },
          _noTilesToLoad: function() {
            for (var key in this._tiles) {
              if (!this._tiles[key].loaded) {
                return false;
              }
            }
            return true;
          }
        });
        function gridLayer(options) {
          return new GridLayer(options);
        }
        var TileLayer = GridLayer.extend({
          // @section
          // @aka TileLayer options
          options: {
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = 18
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: 18,
            // @option subdomains: String|String[] = 'abc'
            // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
            subdomains: "abc",
            // @option errorTileUrl: String = ''
            // URL to the tile image to show in place of the tile that failed to load.
            errorTileUrl: "",
            // @option zoomOffset: Number = 0
            // The zoom number used in tile URLs will be offset with this value.
            zoomOffset: 0,
            // @option tms: Boolean = false
            // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
            tms: false,
            // @option zoomReverse: Boolean = false
            // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
            zoomReverse: false,
            // @option detectRetina: Boolean = false
            // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
            detectRetina: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option referrerPolicy: Boolean|String = false
            // Whether the referrerPolicy attribute will be added to the tiles.
            // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
            // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
            // (e.g. to validate an API token).
            // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
            referrerPolicy: false
          },
          initialize: function(url, options) {
            this._url = url;
            options = setOptions(this, options);
            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
              options.tileSize = Math.floor(options.tileSize / 2);
              if (!options.zoomReverse) {
                options.zoomOffset++;
                options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
              } else {
                options.zoomOffset--;
                options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
              }
              options.minZoom = Math.max(0, options.minZoom);
            } else if (!options.zoomReverse) {
              options.maxZoom = Math.max(options.minZoom, options.maxZoom);
            } else {
              options.minZoom = Math.min(options.maxZoom, options.minZoom);
            }
            if (typeof options.subdomains === "string") {
              options.subdomains = options.subdomains.split("");
            }
            this.on("tileunload", this._onTileRemove);
          },
          // @method setUrl(url: String, noRedraw?: Boolean): this
          // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
          // If the URL does not change, the layer will not be redrawn unless
          // the noRedraw parameter is set to false.
          setUrl: function(url, noRedraw) {
            if (this._url === url && noRedraw === void 0) {
              noRedraw = true;
            }
            this._url = url;
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          },
          // @method createTile(coords: Object, done?: Function): HTMLElement
          // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
          // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
          // callback is called when the tile has been loaded.
          createTile: function(coords, done) {
            var tile = document.createElement("img");
            on(tile, "load", bind(this._tileOnLoad, this, done, tile));
            on(tile, "error", bind(this._tileOnError, this, done, tile));
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (typeof this.options.referrerPolicy === "string") {
              tile.referrerPolicy = this.options.referrerPolicy;
            }
            tile.alt = "";
            tile.src = this.getTileUrl(coords);
            return tile;
          },
          // @section Extension methods
          // @uninheritable
          // Layers extending `TileLayer` might reimplement the following method.
          // @method getTileUrl(coords: Object): String
          // Called only internally, returns the URL for a tile given its coordinates.
          // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
          getTileUrl: function(coords) {
            var data = {
              r: Browser.retina ? "@2x" : "",
              s: this._getSubdomain(coords),
              x: coords.x,
              y: coords.y,
              z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
              var invertedY = this._globalTileRange.max.y - coords.y;
              if (this.options.tms) {
                data["y"] = invertedY;
              }
              data["-y"] = invertedY;
            }
            return template(this._url, extend(data, this.options));
          },
          _tileOnLoad: function(done, tile) {
            if (Browser.ielt9) {
              setTimeout(bind(done, this, null, tile), 0);
            } else {
              done(null, tile);
            }
          },
          _tileOnError: function(done, tile, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl && tile.getAttribute("src") !== errorUrl) {
              tile.src = errorUrl;
            }
            done(e, tile);
          },
          _onTileRemove: function(e) {
            e.tile.onload = null;
          },
          _getZoomForUrl: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
            if (zoomReverse) {
              zoom2 = maxZoom - zoom2;
            }
            return zoom2 + zoomOffset;
          },
          _getSubdomain: function(tilePoint) {
            var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index2];
          },
          // stops loading all tiles in the background layer
          _abortLoading: function() {
            var i, tile;
            for (i in this._tiles) {
              if (this._tiles[i].coords.z !== this._tileZoom) {
                tile = this._tiles[i].el;
                tile.onload = falseFn;
                tile.onerror = falseFn;
                if (!tile.complete) {
                  tile.src = emptyImageUrl;
                  var coords = this._tiles[i].coords;
                  remove(tile);
                  delete this._tiles[i];
                  this.fire("tileabort", {
                    tile,
                    coords
                  });
                }
              }
            }
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.el.setAttribute("src", emptyImageUrl);
            return GridLayer.prototype._removeTile.call(this, key);
          },
          _tileReady: function(coords, err, tile) {
            if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
              return;
            }
            return GridLayer.prototype._tileReady.call(this, coords, err, tile);
          }
        });
        function tileLayer2(url, options) {
          return new TileLayer(url, options);
        }
        var TileLayerWMS = TileLayer.extend({
          // @section
          // @aka TileLayer.WMS options
          // If any custom options not documented here are used, they will be sent to the
          // WMS server as extra parameters in each request URL. This can be useful for
          // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
          defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            // @option layers: String = ''
            // **(required)** Comma-separated list of WMS layers to show.
            layers: "",
            // @option styles: String = ''
            // Comma-separated list of WMS styles.
            styles: "",
            // @option format: String = 'image/jpeg'
            // WMS image format (use `'image/png'` for layers with transparency).
            format: "image/jpeg",
            // @option transparent: Boolean = false
            // If `true`, the WMS service will return images with transparency.
            transparent: false,
            // @option version: String = '1.1.1'
            // Version of the WMS service to use
            version: "1.1.1"
          },
          options: {
            // @option crs: CRS = null
            // Coordinate Reference System to use for the WMS requests, defaults to
            // map CRS. Don't change this if you're not sure what it means.
            crs: null,
            // @option uppercase: Boolean = false
            // If `true`, WMS request parameter keys will be uppercase.
            uppercase: false
          },
          initialize: function(url, options) {
            this._url = url;
            var wmsParams = extend({}, this.defaultWmsParams);
            for (var i in options) {
              if (!(i in this.options)) {
                wmsParams[i] = options[i];
              }
            }
            options = setOptions(this, options);
            var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
            var tileSize = this.getTileSize();
            wmsParams.width = tileSize.x * realRetina;
            wmsParams.height = tileSize.y * realRetina;
            this.wmsParams = wmsParams;
          },
          onAdd: function(map3) {
            this._crs = this.options.crs || map3.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            TileLayer.prototype.onAdd.call(this, map3);
          },
          getTileUrl: function(coords) {
            var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox3 = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox3;
          },
          // @method setParams(params: Object, noRedraw?: Boolean): this
          // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
          setParams: function(params, noRedraw) {
            extend(this.wmsParams, params);
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          }
        });
        function tileLayerWMS(url, options) {
          return new TileLayerWMS(url, options);
        }
        TileLayer.WMS = TileLayerWMS;
        tileLayer2.wms = tileLayerWMS;
        var Renderer = Layer.extend({
          // @section
          // @aka Renderer options
          options: {
            // @option padding: Number = 0.1
            // How much to extend the clip area around the map view (relative to its size)
            // e.g. 0.1 would be 10% of map view in each direction
            padding: 0.1
          },
          initialize: function(options) {
            setOptions(this, options);
            stamp(this);
            this._layers = this._layers || {};
          },
          onAdd: function() {
            if (!this._container) {
              this._initContainer();
              addClass(this._container, "leaflet-zoom-animated");
            }
            this.getPane().appendChild(this._container);
            this._update();
            this.on("update", this._updatePaths, this);
          },
          onRemove: function() {
            this.off("update", this._updatePaths, this);
            this._destroyContainer();
          },
          getEvents: function() {
            var events = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._onAnimZoom;
            }
            return events;
          },
          _onAnimZoom: function(ev) {
            this._updateTransform(ev.center, ev.zoom);
          },
          _onZoom: function() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
          },
          _updateTransform: function(center2, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center2, zoom2));
            if (Browser.any3d) {
              setTransform(this._container, topLeftOffset, scale2);
            } else {
              setPosition(this._container, topLeftOffset);
            }
          },
          _reset: function() {
            this._update();
            this._updateTransform(this._center, this._zoom);
            for (var id in this._layers) {
              this._layers[id]._reset();
            }
          },
          _onZoomEnd: function() {
            for (var id in this._layers) {
              this._layers[id]._project();
            }
          },
          _updatePaths: function() {
            for (var id in this._layers) {
              this._layers[id]._update();
            }
          },
          _update: function() {
            var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
            this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();
          }
        });
        var Canvas = Renderer.extend({
          // @section
          // @aka Canvas options
          options: {
            // @option tolerance: Number = 0
            // How much to extend the click tolerance around a path/object on the map.
            tolerance: 0
          },
          getEvents: function() {
            var events = Renderer.prototype.getEvents.call(this);
            events.viewprereset = this._onViewPreReset;
            return events;
          },
          _onViewPreReset: function() {
            this._postponeUpdatePaths = true;
          },
          onAdd: function() {
            Renderer.prototype.onAdd.call(this);
            this._draw();
          },
          _initContainer: function() {
            var container = this._container = document.createElement("canvas");
            on(container, "mousemove", this._onMouseMove, this);
            on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            on(container, "mouseout", this._handleMouseOut, this);
            container["_leaflet_disable_events"] = true;
            this._ctx = container.getContext("2d");
          },
          _destroyContainer: function() {
            cancelAnimFrame(this._redrawRequest);
            delete this._ctx;
            remove(this._container);
            off(this._container);
            delete this._container;
          },
          _updatePaths: function() {
            if (this._postponeUpdatePaths) {
              return;
            }
            var layer;
            this._redrawBounds = null;
            for (var id in this._layers) {
              layer = this._layers[id];
              layer._update();
            }
            this._redraw();
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
            setPosition(container, b.min);
            container.width = m * size.x;
            container.height = m * size.y;
            container.style.width = size.x + "px";
            container.style.height = size.y + "px";
            if (Browser.retina) {
              this._ctx.scale(2, 2);
            }
            this._ctx.translate(-b.min.x, -b.min.y);
            this.fire("update");
          },
          _reset: function() {
            Renderer.prototype._reset.call(this);
            if (this._postponeUpdatePaths) {
              this._postponeUpdatePaths = false;
              this._updatePaths();
            }
          },
          _initPath: function(layer) {
            this._updateDashArray(layer);
            this._layers[stamp(layer)] = layer;
            var order = layer._order = {
              layer,
              prev: this._drawLast,
              next: null
            };
            if (this._drawLast) {
              this._drawLast.next = order;
            }
            this._drawLast = order;
            this._drawFirst = this._drawFirst || this._drawLast;
          },
          _addPath: function(layer) {
            this._requestRedraw(layer);
          },
          _removePath: function(layer) {
            var order = layer._order;
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              this._drawLast = prev;
            }
            if (prev) {
              prev.next = next;
            } else {
              this._drawFirst = next;
            }
            delete layer._order;
            delete this._layers[stamp(layer)];
            this._requestRedraw(layer);
          },
          _updatePath: function(layer) {
            this._extendRedrawBounds(layer);
            layer._project();
            layer._update();
            this._requestRedraw(layer);
          },
          _updateStyle: function(layer) {
            this._updateDashArray(layer);
            this._requestRedraw(layer);
          },
          _updateDashArray: function(layer) {
            if (typeof layer.options.dashArray === "string") {
              var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
              for (i = 0; i < parts.length; i++) {
                dashValue = Number(parts[i]);
                if (isNaN(dashValue)) {
                  return;
                }
                dashArray.push(dashValue);
              }
              layer.options._dashArray = dashArray;
            } else {
              layer.options._dashArray = layer.options.dashArray;
            }
          },
          _requestRedraw: function(layer) {
            if (!this._map) {
              return;
            }
            this._extendRedrawBounds(layer);
            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
          },
          _extendRedrawBounds: function(layer) {
            if (layer._pxBounds) {
              var padding = (layer.options.weight || 0) + 1;
              this._redrawBounds = this._redrawBounds || new Bounds();
              this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
              this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
            }
          },
          _redraw: function() {
            this._redrawRequest = null;
            if (this._redrawBounds) {
              this._redrawBounds.min._floor();
              this._redrawBounds.max._ceil();
            }
            this._clear();
            this._draw();
            this._redrawBounds = null;
          },
          _clear: function() {
            var bounds = this._redrawBounds;
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
            } else {
              this._ctx.save();
              this._ctx.setTransform(1, 0, 0, 1, 0, 0);
              this._ctx.clearRect(0, 0, this._container.width, this._container.height);
              this._ctx.restore();
            }
          },
          _draw: function() {
            var layer, bounds = this._redrawBounds;
            this._ctx.save();
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.beginPath();
              this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
              this._ctx.clip();
            }
            this._drawing = true;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
                layer._updatePath();
              }
            }
            this._drawing = false;
            this._ctx.restore();
          },
          _updatePoly: function(layer, closed) {
            if (!this._drawing) {
              return;
            }
            var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
            if (!len) {
              return;
            }
            ctx.beginPath();
            for (i = 0; i < len; i++) {
              for (j = 0, len2 = parts[i].length; j < len2; j++) {
                p = parts[i][j];
                ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
              }
              if (closed) {
                ctx.closePath();
              }
            }
            this._fillStroke(ctx, layer);
          },
          _updateCircle: function(layer) {
            if (!this._drawing || layer._empty()) {
              return;
            }
            var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
            if (s !== 1) {
              ctx.save();
              ctx.scale(1, s);
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
            if (s !== 1) {
              ctx.restore();
            }
            this._fillStroke(ctx, layer);
          },
          _fillStroke: function(ctx, layer) {
            var options = layer.options;
            if (options.fill) {
              ctx.globalAlpha = options.fillOpacity;
              ctx.fillStyle = options.fillColor || options.color;
              ctx.fill(options.fillRule || "evenodd");
            }
            if (options.stroke && options.weight !== 0) {
              if (ctx.setLineDash) {
                ctx.setLineDash(layer.options && layer.options._dashArray || []);
              }
              ctx.globalAlpha = options.opacity;
              ctx.lineWidth = options.weight;
              ctx.strokeStyle = options.color;
              ctx.lineCap = options.lineCap;
              ctx.lineJoin = options.lineJoin;
              ctx.stroke();
            }
          },
          // Canvas obviously doesn't have mouse events for individual drawn objects,
          // so we emulate that by calculating what's under the mouse on mousemove/click manually
          _onClick: function(e) {
            var point2 = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point2)) {
                if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                  clickedLayer = layer;
                }
              }
            }
            this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
          },
          _onMouseMove: function(e) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
              return;
            }
            var point2 = this._map.mouseEventToLayerPoint(e);
            this._handleMouseHover(e, point2);
          },
          _handleMouseOut: function(e) {
            var layer = this._hoveredLayer;
            if (layer) {
              removeClass(this._container, "leaflet-interactive");
              this._fireEvent([layer], e, "mouseout");
              this._hoveredLayer = null;
              this._mouseHoverThrottled = false;
            }
          },
          _handleMouseHover: function(e, point2) {
            if (this._mouseHoverThrottled) {
              return;
            }
            var layer, candidateHoveredLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point2)) {
                candidateHoveredLayer = layer;
              }
            }
            if (candidateHoveredLayer !== this._hoveredLayer) {
              this._handleMouseOut(e);
              if (candidateHoveredLayer) {
                addClass(this._container, "leaflet-interactive");
                this._fireEvent([candidateHoveredLayer], e, "mouseover");
                this._hoveredLayer = candidateHoveredLayer;
              }
            }
            this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
            this._mouseHoverThrottled = true;
            setTimeout(bind(function() {
              this._mouseHoverThrottled = false;
            }, this), 32);
          },
          _fireEvent: function(layers3, e, type) {
            this._map._fireDOMEvent(e, type || e.type, layers3);
          },
          _bringToFront: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              return;
            }
            if (prev) {
              prev.next = next;
            } else if (next) {
              this._drawFirst = next;
            }
            order.prev = this._drawLast;
            this._drawLast.next = order;
            order.next = null;
            this._drawLast = order;
            this._requestRedraw(layer);
          },
          _bringToBack: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (prev) {
              prev.next = next;
            } else {
              return;
            }
            if (next) {
              next.prev = prev;
            } else if (prev) {
              this._drawLast = prev;
            }
            order.prev = null;
            order.next = this._drawFirst;
            this._drawFirst.prev = order;
            this._drawFirst = order;
            this._requestRedraw(layer);
          }
        });
        function canvas(options) {
          return Browser.canvas ? new Canvas(options) : null;
        }
        var vmlCreate = function() {
          try {
            document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
            return function(name) {
              return document.createElement("<lvml:" + name + ' class="lvml">');
            };
          } catch (e) {
          }
          return function(name) {
            return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
          };
        }();
        var vmlMixin = {
          _initContainer: function() {
            this._container = create$1("div", "leaflet-vml-container");
          },
          _update: function() {
            if (this._map._animatingZoom) {
              return;
            }
            Renderer.prototype._update.call(this);
            this.fire("update");
          },
          _initPath: function(layer) {
            var container = layer._container = vmlCreate("shape");
            addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
            container.coordsize = "1 1";
            layer._path = vmlCreate("path");
            container.appendChild(layer._path);
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            var container = layer._container;
            this._container.appendChild(container);
            if (layer.options.interactive) {
              layer.addInteractiveTarget(container);
            }
          },
          _removePath: function(layer) {
            var container = layer._container;
            remove(container);
            layer.removeInteractiveTarget(container);
            delete this._layers[stamp(layer)];
          },
          _updateStyle: function(layer) {
            var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
            container.stroked = !!options.stroke;
            container.filled = !!options.fill;
            if (options.stroke) {
              if (!stroke) {
                stroke = layer._stroke = vmlCreate("stroke");
              }
              container.appendChild(stroke);
              stroke.weight = options.weight + "px";
              stroke.color = options.color;
              stroke.opacity = options.opacity;
              if (options.dashArray) {
                stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
              } else {
                stroke.dashStyle = "";
              }
              stroke.endcap = options.lineCap.replace("butt", "flat");
              stroke.joinstyle = options.lineJoin;
            } else if (stroke) {
              container.removeChild(stroke);
              layer._stroke = null;
            }
            if (options.fill) {
              if (!fill) {
                fill = layer._fill = vmlCreate("fill");
              }
              container.appendChild(fill);
              fill.color = options.fillColor || options.color;
              fill.opacity = options.fillOpacity;
            } else if (fill) {
              container.removeChild(fill);
              layer._fill = null;
            }
          },
          _updateCircle: function(layer) {
            var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
            this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
          },
          _setPath: function(layer, path) {
            layer._path.v = path;
          },
          _bringToFront: function(layer) {
            toFront(layer._container);
          },
          _bringToBack: function(layer) {
            toBack(layer._container);
          }
        };
        var create = Browser.vml ? vmlCreate : svgCreate;
        var SVG = Renderer.extend({
          _initContainer: function() {
            this._container = create("svg");
            this._container.setAttribute("pointer-events", "none");
            this._rootGroup = create("g");
            this._container.appendChild(this._rootGroup);
          },
          _destroyContainer: function() {
            remove(this._container);
            off(this._container);
            delete this._container;
            delete this._rootGroup;
            delete this._svgSize;
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, size = b.getSize(), container = this._container;
            if (!this._svgSize || !this._svgSize.equals(size)) {
              this._svgSize = size;
              container.setAttribute("width", size.x);
              container.setAttribute("height", size.y);
            }
            setPosition(container, b.min);
            container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
            this.fire("update");
          },
          // methods below are called by vector layers implementations
          _initPath: function(layer) {
            var path = layer._path = create("path");
            if (layer.options.className) {
              addClass(path, layer.options.className);
            }
            if (layer.options.interactive) {
              addClass(path, "leaflet-interactive");
            }
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            if (!this._rootGroup) {
              this._initContainer();
            }
            this._rootGroup.appendChild(layer._path);
            layer.addInteractiveTarget(layer._path);
          },
          _removePath: function(layer) {
            remove(layer._path);
            layer.removeInteractiveTarget(layer._path);
            delete this._layers[stamp(layer)];
          },
          _updatePath: function(layer) {
            layer._project();
            layer._update();
          },
          _updateStyle: function(layer) {
            var path = layer._path, options = layer.options;
            if (!path) {
              return;
            }
            if (options.stroke) {
              path.setAttribute("stroke", options.color);
              path.setAttribute("stroke-opacity", options.opacity);
              path.setAttribute("stroke-width", options.weight);
              path.setAttribute("stroke-linecap", options.lineCap);
              path.setAttribute("stroke-linejoin", options.lineJoin);
              if (options.dashArray) {
                path.setAttribute("stroke-dasharray", options.dashArray);
              } else {
                path.removeAttribute("stroke-dasharray");
              }
              if (options.dashOffset) {
                path.setAttribute("stroke-dashoffset", options.dashOffset);
              } else {
                path.removeAttribute("stroke-dashoffset");
              }
            } else {
              path.setAttribute("stroke", "none");
            }
            if (options.fill) {
              path.setAttribute("fill", options.fillColor || options.color);
              path.setAttribute("fill-opacity", options.fillOpacity);
              path.setAttribute("fill-rule", options.fillRule || "evenodd");
            } else {
              path.setAttribute("fill", "none");
            }
          },
          _updatePoly: function(layer, closed) {
            this._setPath(layer, pointsToPath(layer._parts, closed));
          },
          _updateCircle: function(layer) {
            var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
            var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
            this._setPath(layer, d);
          },
          _setPath: function(layer, path) {
            layer._path.setAttribute("d", path);
          },
          // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
          _bringToFront: function(layer) {
            toFront(layer._path);
          },
          _bringToBack: function(layer) {
            toBack(layer._path);
          }
        });
        if (Browser.vml) {
          SVG.include(vmlMixin);
        }
        function svg(options) {
          return Browser.svg || Browser.vml ? new SVG(options) : null;
        }
        Map2.include({
          // @namespace Map; @method getRenderer(layer: Path): Renderer
          // Returns the instance of `Renderer` that should be used to render the given
          // `Path`. It will ensure that the `renderer` options of the map and paths
          // are respected, and that the renderers do exist on the map.
          getRenderer: function(layer) {
            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
            if (!renderer) {
              renderer = this._renderer = this._createRenderer();
            }
            if (!this.hasLayer(renderer)) {
              this.addLayer(renderer);
            }
            return renderer;
          },
          _getPaneRenderer: function(name) {
            if (name === "overlayPane" || name === void 0) {
              return false;
            }
            var renderer = this._paneRenderers[name];
            if (renderer === void 0) {
              renderer = this._createRenderer({ pane: name });
              this._paneRenderers[name] = renderer;
            }
            return renderer;
          },
          _createRenderer: function(options) {
            return this.options.preferCanvas && canvas(options) || svg(options);
          }
        });
        var Rectangle = Polygon.extend({
          initialize: function(latLngBounds, options) {
            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
          },
          // @method setBounds(latLngBounds: LatLngBounds): this
          // Redraws the rectangle with the passed bounds.
          setBounds: function(latLngBounds) {
            return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
          },
          _boundsToLatLngs: function(latLngBounds) {
            latLngBounds = toLatLngBounds(latLngBounds);
            return [
              latLngBounds.getSouthWest(),
              latLngBounds.getNorthWest(),
              latLngBounds.getNorthEast(),
              latLngBounds.getSouthEast()
            ];
          }
        });
        function rectangle(latLngBounds, options) {
          return new Rectangle(latLngBounds, options);
        }
        SVG.create = create;
        SVG.pointsToPath = pointsToPath;
        GeoJSON.geometryToLayer = geometryToLayer;
        GeoJSON.coordsToLatLng = coordsToLatLng;
        GeoJSON.coordsToLatLngs = coordsToLatLngs;
        GeoJSON.latLngToCoords = latLngToCoords;
        GeoJSON.latLngsToCoords = latLngsToCoords;
        GeoJSON.getFeature = getFeature;
        GeoJSON.asFeature = asFeature;
        Map2.mergeOptions({
          // @option boxZoom: Boolean = true
          // Whether the map can be zoomed to a rectangular area specified by
          // dragging the mouse while pressing the shift key.
          boxZoom: true
        });
        var BoxZoom = Handler.extend({
          initialize: function(map3) {
            this._map = map3;
            this._container = map3._container;
            this._pane = map3._panes.overlayPane;
            this._resetStateTimeout = 0;
            map3.on("unload", this._destroy, this);
          },
          addHooks: function() {
            on(this._container, "mousedown", this._onMouseDown, this);
          },
          removeHooks: function() {
            off(this._container, "mousedown", this._onMouseDown, this);
          },
          moved: function() {
            return this._moved;
          },
          _destroy: function() {
            remove(this._pane);
            delete this._pane;
          },
          _resetState: function() {
            this._resetStateTimeout = 0;
            this._moved = false;
          },
          _clearDeferredResetState: function() {
            if (this._resetStateTimeout !== 0) {
              clearTimeout(this._resetStateTimeout);
              this._resetStateTimeout = 0;
            }
          },
          _onMouseDown: function(e) {
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
              return false;
            }
            this._clearDeferredResetState();
            this._resetState();
            disableTextSelection();
            disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(e);
            on(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseMove: function(e) {
            if (!this._moved) {
              this._moved = true;
              this._box = create$1("div", "leaflet-zoom-box", this._container);
              addClass(this._container, "leaflet-crosshair");
              this._map.fire("boxzoomstart");
            }
            this._point = this._map.mouseEventToContainerPoint(e);
            var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
            setPosition(this._box, bounds.min);
            this._box.style.width = size.x + "px";
            this._box.style.height = size.y + "px";
          },
          _finish: function() {
            if (this._moved) {
              remove(this._box);
              removeClass(this._container, "leaflet-crosshair");
            }
            enableTextSelection();
            enableImageDrag();
            off(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseUp: function(e) {
            if (e.which !== 1 && e.button !== 1) {
              return;
            }
            this._finish();
            if (!this._moved) {
              return;
            }
            this._clearDeferredResetState();
            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
            var bounds = new LatLngBounds(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
          },
          _onKeyDown: function(e) {
            if (e.keyCode === 27) {
              this._finish();
              this._clearDeferredResetState();
              this._resetState();
            }
          }
        });
        Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
        Map2.mergeOptions({
          // @option doubleClickZoom: Boolean|String = true
          // Whether the map can be zoomed in by double clicking on it and
          // zoomed out by double clicking while holding shift. If passed
          // `'center'`, double-click zoom will zoom to the center of the
          //  view regardless of where the mouse was.
          doubleClickZoom: true
        });
        var DoubleClickZoom = Handler.extend({
          addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
          },
          removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
          },
          _onDoubleClick: function(e) {
            var map3 = this._map, oldZoom = map3.getZoom(), delta = map3.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
            if (map3.options.doubleClickZoom === "center") {
              map3.setZoom(zoom2);
            } else {
              map3.setZoomAround(e.containerPoint, zoom2);
            }
          }
        });
        Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
        Map2.mergeOptions({
          // @option dragging: Boolean = true
          // Whether the map is draggable with mouse/touch or not.
          dragging: true,
          // @section Panning Inertia Options
          // @option inertia: Boolean = *
          // If enabled, panning of the map will have an inertia effect where
          // the map builds momentum while dragging and continues moving in
          // the same direction for some time. Feels especially nice on touch
          // devices. Enabled by default.
          inertia: true,
          // @option inertiaDeceleration: Number = 3000
          // The rate with which the inertial movement slows down, in pixels/second².
          inertiaDeceleration: 3400,
          // px/s^2
          // @option inertiaMaxSpeed: Number = Infinity
          // Max speed of the inertial movement, in pixels/second.
          inertiaMaxSpeed: Infinity,
          // px/s
          // @option easeLinearity: Number = 0.2
          easeLinearity: 0.2,
          // TODO refactor, move to CRS
          // @option worldCopyJump: Boolean = false
          // With this option enabled, the map tracks when you pan to another "copy"
          // of the world and seamlessly jumps to the original one so that all overlays
          // like markers and vector layers are still visible.
          worldCopyJump: false,
          // @option maxBoundsViscosity: Number = 0.0
          // If `maxBounds` is set, this option will control how solid the bounds
          // are when dragging the map around. The default value of `0.0` allows the
          // user to drag outside the bounds at normal speed, higher values will
          // slow down map dragging outside bounds, and `1.0` makes the bounds fully
          // solid, preventing the user from dragging outside the bounds.
          maxBoundsViscosity: 0
        });
        var Drag = Handler.extend({
          addHooks: function() {
            if (!this._draggable) {
              var map3 = this._map;
              this._draggable = new Draggable(map3._mapPane, map3._container);
              this._draggable.on({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
              }, this);
              this._draggable.on("predrag", this._onPreDragLimit, this);
              if (map3.options.worldCopyJump) {
                this._draggable.on("predrag", this._onPreDragWrap, this);
                map3.on("zoomend", this._onZoomEnd, this);
                map3.whenReady(this._onZoomEnd, this);
              }
            }
            addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
            this._draggable.enable();
            this._positions = [];
            this._times = [];
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-grab");
            removeClass(this._map._container, "leaflet-touch-drag");
            this._draggable.disable();
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          moving: function() {
            return this._draggable && this._draggable._moving;
          },
          _onDragStart: function() {
            var map3 = this._map;
            map3._stop();
            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
              var bounds = toLatLngBounds(this._map.options.maxBounds);
              this._offsetLimit = toBounds(
                this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
                this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
              );
              this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
            } else {
              this._offsetLimit = null;
            }
            map3.fire("movestart").fire("dragstart");
            if (map3.options.inertia) {
              this._positions = [];
              this._times = [];
            }
          },
          _onDrag: function(e) {
            if (this._map.options.inertia) {
              var time = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
              this._positions.push(pos);
              this._times.push(time);
              this._prunePositions(time);
            }
            this._map.fire("move", e).fire("drag", e);
          },
          _prunePositions: function(time) {
            while (this._positions.length > 1 && time - this._times[0] > 50) {
              this._positions.shift();
              this._times.shift();
            }
          },
          _onZoomEnd: function() {
            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
          },
          _viscousLimit: function(value, threshold) {
            return value - (value - threshold) * this._viscosity;
          },
          _onPreDragLimit: function() {
            if (!this._viscosity || !this._offsetLimit) {
              return;
            }
            var offset = this._draggable._newPos.subtract(this._draggable._startPos);
            var limit = this._offsetLimit;
            if (offset.x < limit.min.x) {
              offset.x = this._viscousLimit(offset.x, limit.min.x);
            }
            if (offset.y < limit.min.y) {
              offset.y = this._viscousLimit(offset.y, limit.min.y);
            }
            if (offset.x > limit.max.x) {
              offset.x = this._viscousLimit(offset.x, limit.max.x);
            }
            if (offset.y > limit.max.y) {
              offset.y = this._viscousLimit(offset.y, limit.max.y);
            }
            this._draggable._newPos = this._draggable._startPos.add(offset);
          },
          _onPreDragWrap: function() {
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x2 = this._draggable._newPos.x, newX1 = (x2 - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x2 + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._absPos = this._draggable._newPos.clone();
            this._draggable._newPos.x = newX;
          },
          _onDragEnd: function(e) {
            var map3 = this._map, options = map3.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
            map3.fire("dragend", e);
            if (noInertia) {
              map3.fire("moveend");
            } else {
              this._prunePositions(+/* @__PURE__ */ new Date());
              var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
              if (!offset.x && !offset.y) {
                map3.fire("moveend");
              } else {
                offset = map3._limitOffset(offset, map3.options.maxBounds);
                requestAnimFrame(function() {
                  map3.panBy(offset, {
                    duration: decelerationDuration,
                    easeLinearity: ease,
                    noMoveStart: true,
                    animate: true
                  });
                });
              }
            }
          }
        });
        Map2.addInitHook("addHandler", "dragging", Drag);
        Map2.mergeOptions({
          // @option keyboard: Boolean = true
          // Makes the map focusable and allows users to navigate the map with keyboard
          // arrows and `+`/`-` keys.
          keyboard: true,
          // @option keyboardPanDelta: Number = 80
          // Amount of pixels to pan when pressing an arrow key.
          keyboardPanDelta: 80
        });
        var Keyboard = Handler.extend({
          keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
          },
          initialize: function(map3) {
            this._map = map3;
            this._setPanDelta(map3.options.keyboardPanDelta);
            this._setZoomDelta(map3.options.zoomDelta);
          },
          addHooks: function() {
            var container = this._map._container;
            if (container.tabIndex <= 0) {
              container.tabIndex = "0";
            }
            on(container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          removeHooks: function() {
            this._removeHooks();
            off(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          _onMouseDown: function() {
            if (this._focused) {
              return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
          },
          _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
          },
          _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
          },
          _setPanDelta: function(panDelta) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.left.length; i < len; i++) {
              keys[codes.left[i]] = [-1 * panDelta, 0];
            }
            for (i = 0, len = codes.right.length; i < len; i++) {
              keys[codes.right[i]] = [panDelta, 0];
            }
            for (i = 0, len = codes.down.length; i < len; i++) {
              keys[codes.down[i]] = [0, panDelta];
            }
            for (i = 0, len = codes.up.length; i < len; i++) {
              keys[codes.up[i]] = [0, -1 * panDelta];
            }
          },
          _setZoomDelta: function(zoomDelta) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.zoomIn.length; i < len; i++) {
              keys[codes.zoomIn[i]] = zoomDelta;
            }
            for (i = 0, len = codes.zoomOut.length; i < len; i++) {
              keys[codes.zoomOut[i]] = -zoomDelta;
            }
          },
          _addHooks: function() {
            on(document, "keydown", this._onKeyDown, this);
          },
          _removeHooks: function() {
            off(document, "keydown", this._onKeyDown, this);
          },
          _onKeyDown: function(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) {
              return;
            }
            var key = e.keyCode, map3 = this._map, offset;
            if (key in this._panKeys) {
              if (!map3._panAnim || !map3._panAnim._inProgress) {
                offset = this._panKeys[key];
                if (e.shiftKey) {
                  offset = toPoint(offset).multiplyBy(3);
                }
                if (map3.options.maxBounds) {
                  offset = map3._limitOffset(toPoint(offset), map3.options.maxBounds);
                }
                if (map3.options.worldCopyJump) {
                  var newLatLng = map3.wrapLatLng(map3.unproject(map3.project(map3.getCenter()).add(offset)));
                  map3.panTo(newLatLng);
                } else {
                  map3.panBy(offset);
                }
              }
            } else if (key in this._zoomKeys) {
              map3.setZoom(map3.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
            } else if (key === 27 && map3._popup && map3._popup.options.closeOnEscapeKey) {
              map3.closePopup();
            } else {
              return;
            }
            stop(e);
          }
        });
        Map2.addInitHook("addHandler", "keyboard", Keyboard);
        Map2.mergeOptions({
          // @section Mouse wheel options
          // @option scrollWheelZoom: Boolean|String = true
          // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
          // it will zoom to the center of the view regardless of where the mouse was.
          scrollWheelZoom: true,
          // @option wheelDebounceTime: Number = 40
          // Limits the rate at which a wheel can fire (in milliseconds). By default
          // user can't zoom via wheel more often than once per 40 ms.
          wheelDebounceTime: 40,
          // @option wheelPxPerZoomLevel: Number = 60
          // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
          // mean a change of one full zoom level. Smaller values will make wheel-zooming
          // faster (and vice versa).
          wheelPxPerZoomLevel: 60
        });
        var ScrollWheelZoom = Handler.extend({
          addHooks: function() {
            on(this._map._container, "wheel", this._onWheelScroll, this);
            this._delta = 0;
          },
          removeHooks: function() {
            off(this._map._container, "wheel", this._onWheelScroll, this);
          },
          _onWheelScroll: function(e) {
            var delta = getWheelDelta(e);
            var debounce = this._map.options.wheelDebounceTime;
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) {
              this._startTime = +/* @__PURE__ */ new Date();
            }
            var left = Math.max(debounce - (+/* @__PURE__ */ new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(bind(this._performZoom, this), left);
            stop(e);
          },
          _performZoom: function() {
            var map3 = this._map, zoom2 = map3.getZoom(), snap = this._map.options.zoomSnap || 0;
            map3._stop();
            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map3._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
              return;
            }
            if (map3.options.scrollWheelZoom === "center") {
              map3.setZoom(zoom2 + delta);
            } else {
              map3.setZoomAround(this._lastMousePos, zoom2 + delta);
            }
          }
        });
        Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
        var tapHoldDelay = 600;
        Map2.mergeOptions({
          // @section Touch interaction options
          // @option tapHold: Boolean
          // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
          tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
          // @option tapTolerance: Number = 15
          // The max number of pixels a user can shift his finger during touch
          // for it to be considered a valid tap.
          tapTolerance: 15
        });
        var TapHold = Handler.extend({
          addHooks: function() {
            on(this._map._container, "touchstart", this._onDown, this);
          },
          removeHooks: function() {
            off(this._map._container, "touchstart", this._onDown, this);
          },
          _onDown: function(e) {
            clearTimeout(this._holdTimeout);
            if (e.touches.length !== 1) {
              return;
            }
            var first = e.touches[0];
            this._startPos = this._newPos = new Point(first.clientX, first.clientY);
            this._holdTimeout = setTimeout(bind(function() {
              this._cancel();
              if (!this._isTapValid()) {
                return;
              }
              on(document, "touchend", preventDefault);
              on(document, "touchend touchcancel", this._cancelClickPrevent);
              this._simulateEvent("contextmenu", first);
            }, this), tapHoldDelay);
            on(document, "touchend touchcancel contextmenu", this._cancel, this);
            on(document, "touchmove", this._onMove, this);
          },
          _cancelClickPrevent: function cancelClickPrevent() {
            off(document, "touchend", preventDefault);
            off(document, "touchend touchcancel", cancelClickPrevent);
          },
          _cancel: function() {
            clearTimeout(this._holdTimeout);
            off(document, "touchend touchcancel contextmenu", this._cancel, this);
            off(document, "touchmove", this._onMove, this);
          },
          _onMove: function(e) {
            var first = e.touches[0];
            this._newPos = new Point(first.clientX, first.clientY);
          },
          _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
          },
          _simulateEvent: function(type, e) {
            var simulatedEvent = new MouseEvent(type, {
              bubbles: true,
              cancelable: true,
              view: window,
              // detail: 1,
              screenX: e.screenX,
              screenY: e.screenY,
              clientX: e.clientX,
              clientY: e.clientY
              // button: 2,
              // buttons: 2
            });
            simulatedEvent._simulated = true;
            e.target.dispatchEvent(simulatedEvent);
          }
        });
        Map2.addInitHook("addHandler", "tapHold", TapHold);
        Map2.mergeOptions({
          // @section Touch interaction options
          // @option touchZoom: Boolean|String = *
          // Whether the map can be zoomed by touch-dragging with two fingers. If
          // passed `'center'`, it will zoom to the center of the view regardless of
          // where the touch events (fingers) were. Enabled for touch-capable web
          // browsers.
          touchZoom: Browser.touch,
          // @option bounceAtZoomLimits: Boolean = true
          // Set it to false if you don't want the map to zoom beyond min/max zoom
          // and then bounce back when pinch-zooming.
          bounceAtZoomLimits: true
        });
        var TouchZoom = Handler.extend({
          addHooks: function() {
            addClass(this._map._container, "leaflet-touch-zoom");
            on(this._map._container, "touchstart", this._onTouchStart, this);
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-touch-zoom");
            off(this._map._container, "touchstart", this._onTouchStart, this);
          },
          _onTouchStart: function(e) {
            var map3 = this._map;
            if (!e.touches || e.touches.length !== 2 || map3._animatingZoom || this._zooming) {
              return;
            }
            var p1 = map3.mouseEventToContainerPoint(e.touches[0]), p2 = map3.mouseEventToContainerPoint(e.touches[1]);
            this._centerPoint = map3.getSize()._divideBy(2);
            this._startLatLng = map3.containerPointToLatLng(this._centerPoint);
            if (map3.options.touchZoom !== "center") {
              this._pinchStartLatLng = map3.containerPointToLatLng(p1.add(p2)._divideBy(2));
            }
            this._startDist = p1.distanceTo(p2);
            this._startZoom = map3.getZoom();
            this._moved = false;
            this._zooming = true;
            map3._stop();
            on(document, "touchmove", this._onTouchMove, this);
            on(document, "touchend touchcancel", this._onTouchEnd, this);
            preventDefault(e);
          },
          _onTouchMove: function(e) {
            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
              return;
            }
            var map3 = this._map, p1 = map3.mouseEventToContainerPoint(e.touches[0]), p2 = map3.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
            this._zoom = map3.getScaleZoom(scale2, this._startZoom);
            if (!map3.options.bounceAtZoomLimits && (this._zoom < map3.getMinZoom() && scale2 < 1 || this._zoom > map3.getMaxZoom() && scale2 > 1)) {
              this._zoom = map3._limitZoom(this._zoom);
            }
            if (map3.options.touchZoom === "center") {
              this._center = this._startLatLng;
              if (scale2 === 1) {
                return;
              }
            } else {
              var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
              if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
                return;
              }
              this._center = map3.unproject(map3.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
            }
            if (!this._moved) {
              map3._moveStart(true, false);
              this._moved = true;
            }
            cancelAnimFrame(this._animRequest);
            var moveFn = bind(map3._move, map3, this._center, this._zoom, { pinch: true, round: false }, void 0);
            this._animRequest = requestAnimFrame(moveFn, this, true);
            preventDefault(e);
          },
          _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
              this._zooming = false;
              return;
            }
            this._zooming = false;
            cancelAnimFrame(this._animRequest);
            off(document, "touchmove", this._onTouchMove, this);
            off(document, "touchend touchcancel", this._onTouchEnd, this);
            if (this._map.options.zoomAnimation) {
              this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
            } else {
              this._map._resetView(this._center, this._map._limitZoom(this._zoom));
            }
          }
        });
        Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
        Map2.BoxZoom = BoxZoom;
        Map2.DoubleClickZoom = DoubleClickZoom;
        Map2.Drag = Drag;
        Map2.Keyboard = Keyboard;
        Map2.ScrollWheelZoom = ScrollWheelZoom;
        Map2.TapHold = TapHold;
        Map2.TouchZoom = TouchZoom;
        exports2.Bounds = Bounds;
        exports2.Browser = Browser;
        exports2.CRS = CRS;
        exports2.Canvas = Canvas;
        exports2.Circle = Circle2;
        exports2.CircleMarker = CircleMarker;
        exports2.Class = Class;
        exports2.Control = Control;
        exports2.DivIcon = DivIcon;
        exports2.DivOverlay = DivOverlay;
        exports2.DomEvent = DomEvent;
        exports2.DomUtil = DomUtil;
        exports2.Draggable = Draggable;
        exports2.Evented = Evented;
        exports2.FeatureGroup = FeatureGroup;
        exports2.GeoJSON = GeoJSON;
        exports2.GridLayer = GridLayer;
        exports2.Handler = Handler;
        exports2.Icon = Icon;
        exports2.ImageOverlay = ImageOverlay;
        exports2.LatLng = LatLng;
        exports2.LatLngBounds = LatLngBounds;
        exports2.Layer = Layer;
        exports2.LayerGroup = LayerGroup;
        exports2.LineUtil = LineUtil;
        exports2.Map = Map2;
        exports2.Marker = Marker;
        exports2.Mixin = Mixin;
        exports2.Path = Path;
        exports2.Point = Point;
        exports2.PolyUtil = PolyUtil;
        exports2.Polygon = Polygon;
        exports2.Polyline = Polyline;
        exports2.Popup = Popup;
        exports2.PosAnimation = PosAnimation;
        exports2.Projection = index;
        exports2.Rectangle = Rectangle;
        exports2.Renderer = Renderer;
        exports2.SVG = SVG;
        exports2.SVGOverlay = SVGOverlay;
        exports2.TileLayer = TileLayer;
        exports2.Tooltip = Tooltip;
        exports2.Transformation = Transformation;
        exports2.Util = Util;
        exports2.VideoOverlay = VideoOverlay;
        exports2.bind = bind;
        exports2.bounds = toBounds;
        exports2.canvas = canvas;
        exports2.circle = circle4;
        exports2.circleMarker = circleMarker2;
        exports2.control = control;
        exports2.divIcon = divIcon;
        exports2.extend = extend;
        exports2.featureGroup = featureGroup;
        exports2.geoJSON = geoJSON2;
        exports2.geoJson = geoJson;
        exports2.gridLayer = gridLayer;
        exports2.icon = icon2;
        exports2.imageOverlay = imageOverlay;
        exports2.latLng = toLatLng;
        exports2.latLngBounds = toLatLngBounds;
        exports2.layerGroup = layerGroup;
        exports2.map = createMap;
        exports2.marker = marker2;
        exports2.point = toPoint;
        exports2.polygon = polygon2;
        exports2.polyline = polyline2;
        exports2.popup = popup;
        exports2.rectangle = rectangle;
        exports2.setOptions = setOptions;
        exports2.stamp = stamp;
        exports2.svg = svg;
        exports2.svgOverlay = svgOverlay;
        exports2.tileLayer = tileLayer2;
        exports2.tooltip = tooltip;
        exports2.transformation = toTransformation;
        exports2.version = version;
        exports2.videoOverlay = videoOverlay;
        var oldL = window.L;
        exports2.noConflict = function() {
          window.L = oldL;
          return this;
        };
        window.L = exports2;
      });
    }
  });

  // ../../../../../../../node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "../../../../../../../node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty2.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // ../../../../../../../node_modules/concaveman/node_modules/rbush/rbush.min.js
  var require_rbush_min = __commonJS({
    "../../../../../../../node_modules/concaveman/node_modules/rbush/rbush.min.js"(exports, module) {
      !function(t, i) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
      }(exports, function() {
        "use strict";
        function t(t2, r2, e3, a2, h2) {
          !function t3(n2, r3, e4, a3, h3) {
            for (; a3 > e4; ) {
              if (a3 - e4 > 600) {
                var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                t3(n2, r3, m2, c2, h3);
              }
              var p2 = n2[r3], d2 = e4, x2 = a3;
              for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
                for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
                  d2++;
                for (; h3(n2[x2], p2) > 0; )
                  x2--;
              }
              0 === h3(n2[e4], p2) ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
            }
          }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
        }
        function i(t2, i2, n2) {
          var r2 = t2[i2];
          t2[i2] = t2[n2], t2[n2] = r2;
        }
        function n(t2, i2) {
          return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
        }
        var r = function(t2) {
          void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e(t2, i2, n2) {
          if (!n2)
            return i2.indexOf(t2);
          for (var r2 = 0; r2 < i2.length; r2++)
            if (n2(t2, i2[r2]))
              return r2;
          return -1;
        }
        function a(t2, i2) {
          h(t2, 0, t2.children.length, i2, t2);
        }
        function h(t2, i2, n2, r2, e3) {
          e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
          for (var a2 = i2; a2 < n2; a2++) {
            var h2 = t2.children[a2];
            o(e3, t2.leaf ? r2(h2) : h2);
          }
          return e3;
        }
        function o(t2, i2) {
          return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
        }
        function s(t2, i2) {
          return t2.minX - i2.minX;
        }
        function l(t2, i2) {
          return t2.minY - i2.minY;
        }
        function f(t2) {
          return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
        }
        function u(t2) {
          return t2.maxX - t2.minX + (t2.maxY - t2.minY);
        }
        function m(t2, i2) {
          return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
        }
        function c(t2, i2) {
          return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
        }
        function p(t2) {
          return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d(i2, n2, r2, e3, a2) {
          for (var h2 = [n2, r2]; h2.length; )
            if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
              var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
              t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
            }
        }
        return r.prototype.all = function() {
          return this._all(this.data, []);
        }, r.prototype.search = function(t2) {
          var i2 = this.data, n2 = [];
          if (!c(t2, i2))
            return n2;
          for (var r2 = this.toBBox, e3 = []; i2; ) {
            for (var a2 = 0; a2 < i2.children.length; a2++) {
              var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
              c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
            }
            i2 = e3.pop();
          }
          return n2;
        }, r.prototype.collides = function(t2) {
          var i2 = this.data;
          if (!c(t2, i2))
            return false;
          for (var n2 = []; i2; ) {
            for (var r2 = 0; r2 < i2.children.length; r2++) {
              var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
              if (c(t2, a2)) {
                if (i2.leaf || m(t2, a2))
                  return true;
                n2.push(e3);
              }
            }
            i2 = n2.pop();
          }
          return false;
        }, r.prototype.load = function(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (var i2 = 0; i2 < t2.length; i2++)
              this.insert(t2[i2]);
            return this;
          }
          var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n2.height)
              this._splitRoot(this.data, n2);
            else {
              if (this.data.height < n2.height) {
                var r2 = this.data;
                this.data = n2, n2 = r2;
              }
              this._insert(n2, this.data.height - n2.height - 1, true);
            }
          else
            this.data = n2;
          return this;
        }, r.prototype.insert = function(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }, r.prototype.clear = function() {
          return this.data = p([]), this;
        }, r.prototype.remove = function(t2, i2) {
          if (!t2)
            return this;
          for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
            if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
              var f2 = e(t2, h2.children, i2);
              if (-1 !== f2)
                return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
            }
            a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
          }
          return this;
        }, r.prototype.toBBox = function(t2) {
          return t2;
        }, r.prototype.compareMinX = function(t2, i2) {
          return t2.minX - i2.minX;
        }, r.prototype.compareMinY = function(t2, i2) {
          return t2.minY - i2.minY;
        }, r.prototype.toJSON = function() {
          return this.data;
        }, r.prototype.fromJSON = function(t2) {
          return this.data = t2, this;
        }, r.prototype._all = function(t2, i2) {
          for (var n2 = []; t2; )
            t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
          return i2;
        }, r.prototype._build = function(t2, i2, n2, r2) {
          var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
          if (h2 <= o2)
            return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
          r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
          var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
          d(t2, i2, n2, l2, this.compareMinX);
          for (var f2 = i2; f2 <= n2; f2 += l2) {
            var u2 = Math.min(f2 + l2 - 1, n2);
            d(t2, f2, u2, s2, this.compareMinY);
            for (var m2 = f2; m2 <= u2; m2 += s2) {
              var c2 = Math.min(m2 + s2 - 1, u2);
              e3.children.push(this._build(t2, m2, c2, r2 - 1));
            }
          }
          return a(e3, this.toBBox), e3;
        }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
          for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
            for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
              var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
              u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
            }
            i2 = h2 || i2.children[0];
          }
          var m2, c2;
          return i2;
        }, r.prototype._insert = function(t2, i2, n2) {
          var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
          for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
            this._split(e3, i2), i2--;
          this._adjustParentBBoxes(r2, e3, i2);
        }, r.prototype._split = function(t2, i2) {
          var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
          this._chooseSplitAxis(n2, e3, r2);
          var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
          o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
        }, r.prototype._splitRoot = function(t2, i2) {
          this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
        }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
          for (var r2, e3, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
            var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
            v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
          }
          return r2 || n2 - i2;
        }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
          var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
          this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
        }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
          t2.children.sort(r2);
          for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
            var m2 = t2.children[f2];
            o(a2, t2.leaf ? e3(m2) : m2), l2 += u(a2);
          }
          for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
            var p2 = t2.children[c2];
            o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
          }
          return l2;
        }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
          for (var r2 = n2; r2 >= 0; r2--)
            o(i2[r2], t2);
        }, r.prototype._condense = function(t2) {
          for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
            0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
        }, r;
      });
    }
  });

  // ../../../../../../../node_modules/tinyqueue/tinyqueue.js
  var require_tinyqueue = __commonJS({
    "../../../../../../../node_modules/tinyqueue/tinyqueue.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.TinyQueue = factory());
      })(exports, function() {
        "use strict";
        var TinyQueue = function TinyQueue2(data, compare) {
          if (data === void 0)
            data = [];
          if (compare === void 0)
            compare = defaultCompare;
          this.data = data;
          this.length = this.data.length;
          this.compare = compare;
          if (this.length > 0) {
            for (var i = (this.length >> 1) - 1; i >= 0; i--) {
              this._down(i);
            }
          }
        };
        TinyQueue.prototype.push = function push(item) {
          this.data.push(item);
          this.length++;
          this._up(this.length - 1);
        };
        TinyQueue.prototype.pop = function pop() {
          if (this.length === 0) {
            return void 0;
          }
          var top = this.data[0];
          var bottom = this.data.pop();
          this.length--;
          if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
          }
          return top;
        };
        TinyQueue.prototype.peek = function peek() {
          return this.data[0];
        };
        TinyQueue.prototype._up = function _up(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var item = data[pos];
          while (pos > 0) {
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) {
              break;
            }
            data[pos] = current;
            pos = parent;
          }
          data[pos] = item;
        };
        TinyQueue.prototype._down = function _down(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var halfLength = this.length >> 1;
          var item = data[pos];
          while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var best = data[left];
            var right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
              left = right;
              best = data[right];
            }
            if (compare(best, item) >= 0) {
              break;
            }
            data[pos] = best;
            pos = left;
          }
          data[pos] = item;
        };
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return TinyQueue;
      });
    }
  });

  // ../../../../../../../node_modules/point-in-polygon/flat.js
  var require_flat = __commonJS({
    "../../../../../../../node_modules/point-in-polygon/flat.js"(exports, module) {
      module.exports = function pointInPolygonFlat(point2, vs, start, end) {
        var x2 = point2[0], y2 = point2[1];
        var inside = false;
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = vs.length;
        var len = (end - start) / 2;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
          var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
          var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // ../../../../../../../node_modules/point-in-polygon/nested.js
  var require_nested = __commonJS({
    "../../../../../../../node_modules/point-in-polygon/nested.js"(exports, module) {
      module.exports = function pointInPolygonNested(point2, vs, start, end) {
        var x2 = point2[0], y2 = point2[1];
        var inside = false;
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = vs.length;
        var len = end - start;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[i + start][0], yi = vs[i + start][1];
          var xj = vs[j + start][0], yj = vs[j + start][1];
          var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // ../../../../../../../node_modules/point-in-polygon/index.js
  var require_point_in_polygon = __commonJS({
    "../../../../../../../node_modules/point-in-polygon/index.js"(exports, module) {
      var pointInPolygonFlat = require_flat();
      var pointInPolygonNested = require_nested();
      module.exports = function pointInPolygon(point2, vs, start, end) {
        if (vs.length > 0 && Array.isArray(vs[0])) {
          return pointInPolygonNested(point2, vs, start, end);
        } else {
          return pointInPolygonFlat(point2, vs, start, end);
        }
      };
      module.exports.nested = pointInPolygonNested;
      module.exports.flat = pointInPolygonFlat;
    }
  });

  // ../../../../../../../node_modules/robust-predicates/umd/orient2d.min.js
  var require_orient2d_min = __commonJS({
    "../../../../../../../node_modules/robust-predicates/umd/orient2d.min.js"(exports, module) {
      !function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).predicates = {});
      }(exports, function(t) {
        "use strict";
        const e = 134217729, n = 33306690738754706e-32;
        function r(t2, e3, n2, r2, o2) {
          let f2, i2, u2, c2, s2 = e3[0], a2 = r2[0], d2 = 0, l2 = 0;
          a2 > s2 == a2 > -s2 ? (f2 = s2, s2 = e3[++d2]) : (f2 = a2, a2 = r2[++l2]);
          let p = 0;
          if (d2 < t2 && l2 < n2)
            for (a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = s2 + f2) - s2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = a2 + f2) - a2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2); d2 < t2 && l2 < n2; )
              a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2);
          for (; d2 < t2; )
            u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
          for (; l2 < n2; )
            u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
          return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
        }
        function o(t2) {
          return new Float64Array(t2);
        }
        const f = 33306690738754716e-32, i = 22204460492503146e-32, u = 11093356479670487e-47, c = o(4), s = o(8), a = o(12), d = o(16), l = o(4);
        t.orient2d = function(t2, o2, p, b, y2, h) {
          const M = (o2 - h) * (p - y2), x2 = (t2 - y2) * (b - h), j = M - x2;
          if (0 === M || 0 === x2 || M > 0 != x2 > 0)
            return j;
          const m = Math.abs(M + x2);
          return Math.abs(j) >= f * m ? j : -function(t3, o3, f2, p2, b2, y3, h2) {
            let M2, x3, j2, m2, _, v, w, A, F, O, P, g, k, q, z, B2, C, D;
            const E = t3 - b2, G = f2 - b2, H = o3 - y3, I = p2 - y3;
            _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = E * I) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = H * G) - w * F - A * F - w * O))), c[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), c[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, c[2] = g - (D - _) + (P - _), c[3] = D;
            let J = function(t4, e3) {
              let n2 = e3[0];
              for (let r2 = 1; r2 < t4; r2++)
                n2 += e3[r2];
              return n2;
            }(4, c), K = i * h2;
            if (J >= K || -J >= K)
              return J;
            if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x3 = o3 - (H + (_ = o3 - H)) + (_ - y3), m2 = p2 - (I + (_ = p2 - I)) + (_ - y3), 0 === M2 && 0 === x3 && 0 === j2 && 0 === m2)
              return J;
            if (K = u * h2 + n * Math.abs(J), (J += E * m2 + I * M2 - (H * j2 + G * x3)) >= K || -J >= K)
              return J;
            _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = M2 * I) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = x3 * G) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const L3 = r(4, c, 4, l, s);
            _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = E * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = H * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const N = r(L3, s, 4, l, a);
            _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = M2 * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = x3 * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const Q = r(N, a, 4, l, d);
            return d[Q - 1];
          }(t2, o2, p, b, y2, h, m);
        }, t.orient2dfast = function(t2, e3, n2, r2, o2, f2) {
          return (e3 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
        }, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // ../../../../../../../node_modules/concaveman/index.js
  var require_concaveman = __commonJS({
    "../../../../../../../node_modules/concaveman/index.js"(exports, module) {
      "use strict";
      var RBush = require_rbush_min();
      var Queue = require_tinyqueue();
      var pointInPolygon = require_point_in_polygon();
      var orient = require_orient2d_min().orient2d;
      if (Queue.default) {
        Queue = Queue.default;
      }
      module.exports = concaveman2;
      module.exports.default = concaveman2;
      function concaveman2(points, concavity, lengthThreshold) {
        concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
        lengthThreshold = lengthThreshold || 0;
        var hull = fastConvexHull(points);
        var tree = new RBush(16);
        tree.toBBox = function(a2) {
          return {
            minX: a2[0],
            minY: a2[1],
            maxX: a2[0],
            maxY: a2[1]
          };
        };
        tree.compareMinX = function(a2, b2) {
          return a2[0] - b2[0];
        };
        tree.compareMinY = function(a2, b2) {
          return a2[1] - b2[1];
        };
        tree.load(points);
        var queue = [];
        for (var i = 0, last; i < hull.length; i++) {
          var p = hull[i];
          tree.remove(p);
          last = insertNode(p, last);
          queue.push(last);
        }
        var segTree = new RBush(16);
        for (i = 0; i < queue.length; i++)
          segTree.insert(updateBBox(queue[i]));
        var sqConcavity = concavity * concavity;
        var sqLenThreshold = lengthThreshold * lengthThreshold;
        while (queue.length) {
          var node = queue.shift();
          var a = node.p;
          var b = node.next.p;
          var sqLen = getSqDist(a, b);
          if (sqLen < sqLenThreshold)
            continue;
          var maxSqLen = sqLen / sqConcavity;
          p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
          if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {
            queue.push(node);
            queue.push(insertNode(p, node));
            tree.remove(p);
            segTree.remove(node);
            segTree.insert(updateBBox(node));
            segTree.insert(updateBBox(node.next));
          }
        }
        node = last;
        var concave = [];
        do {
          concave.push(node.p);
          node = node.next;
        } while (node !== last);
        concave.push(node.p);
        return concave;
      }
      function findCandidate(tree, a, b, c, d, maxDist, segTree) {
        var queue = new Queue([], compareDist);
        var node = tree.data;
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
            if (dist > maxDist)
              continue;
            queue.push({
              node: child,
              dist
            });
          }
          while (queue.length && !queue.peek().node.children) {
            var item = queue.pop();
            var p = item.node;
            var d0 = sqSegDist(p, a, b);
            var d1 = sqSegDist(p, c, d);
            if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree))
              return p;
          }
          node = queue.pop();
          if (node)
            node = node.node;
        }
        return null;
      }
      function compareDist(a, b) {
        return a.dist - b.dist;
      }
      function sqSegBoxDist(a, b, bbox3) {
        if (inside(a, bbox3) || inside(b, bbox3))
          return 0;
        var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.maxX, bbox3.minY);
        if (d1 === 0)
          return 0;
        var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.minX, bbox3.maxY);
        if (d2 === 0)
          return 0;
        var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.maxX, bbox3.minY, bbox3.maxX, bbox3.maxY);
        if (d3 === 0)
          return 0;
        var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.maxY, bbox3.maxX, bbox3.maxY);
        if (d4 === 0)
          return 0;
        return Math.min(d1, d2, d3, d4);
      }
      function inside(a, bbox3) {
        return a[0] >= bbox3.minX && a[0] <= bbox3.maxX && a[1] >= bbox3.minY && a[1] <= bbox3.maxY;
      }
      function noIntersections(a, b, segTree) {
        var minX = Math.min(a[0], b[0]);
        var minY = Math.min(a[1], b[1]);
        var maxX = Math.max(a[0], b[0]);
        var maxY = Math.max(a[1], b[1]);
        var edges2 = segTree.search({ minX, minY, maxX, maxY });
        for (var i = 0; i < edges2.length; i++) {
          if (intersects2(edges2[i].p, edges2[i].next.p, a, b))
            return false;
        }
        return true;
      }
      function cross(p1, p2, p3) {
        return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
      }
      function intersects2(p1, q1, p2, q2) {
        return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
      }
      function updateBBox(node) {
        var p1 = node.p;
        var p2 = node.next.p;
        node.minX = Math.min(p1[0], p2[0]);
        node.minY = Math.min(p1[1], p2[1]);
        node.maxX = Math.max(p1[0], p2[0]);
        node.maxY = Math.max(p1[1], p2[1]);
        return node;
      }
      function fastConvexHull(points) {
        var left = points[0];
        var top = points[0];
        var right = points[0];
        var bottom = points[0];
        for (var i = 0; i < points.length; i++) {
          var p = points[i];
          if (p[0] < left[0])
            left = p;
          if (p[0] > right[0])
            right = p;
          if (p[1] < top[1])
            top = p;
          if (p[1] > bottom[1])
            bottom = p;
        }
        var cull = [left, top, right, bottom];
        var filtered = cull.slice();
        for (i = 0; i < points.length; i++) {
          if (!pointInPolygon(points[i], cull))
            filtered.push(points[i]);
        }
        return convexHull(filtered);
      }
      function insertNode(p, prev) {
        var node = {
          p,
          prev: null,
          next: null,
          minX: 0,
          minY: 0,
          maxX: 0,
          maxY: 0
        };
        if (!prev) {
          node.prev = node;
          node.next = node;
        } else {
          node.next = prev.next;
          node.prev = prev;
          prev.next.prev = node;
          prev.next = node;
        }
        return node;
      }
      function getSqDist(p1, p2) {
        var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
        return dx * dx + dy * dy;
      }
      function sqSegDist(p, p1, p2) {
        var x2 = p1[0], y2 = p1[1], dx = p2[0] - x2, dy = p2[1] - y2;
        if (dx !== 0 || dy !== 0) {
          var t = ((p[0] - x2) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
            x2 = p2[0];
            y2 = p2[1];
          } else if (t > 0) {
            x2 += dx * t;
            y2 += dy * t;
          }
        }
        dx = p[0] - x2;
        dy = p[1] - y2;
        return dx * dx + dy * dy;
      }
      function sqSegSegDist(x02, y0, x12, y1, x2, y2, x3, y3) {
        var ux = x12 - x02;
        var uy = y1 - y0;
        var vx = x3 - x2;
        var vy = y3 - y2;
        var wx = x02 - x2;
        var wy = y0 - y2;
        var a = ux * ux + uy * uy;
        var b = ux * vx + uy * vy;
        var c = vx * vx + vy * vy;
        var d = ux * wx + uy * wy;
        var e = vx * wx + vy * wy;
        var D = a * c - b * b;
        var sc, sN, tc, tN;
        var sD = D;
        var tD = D;
        if (D === 0) {
          sN = 0;
          sD = 1;
          tN = e;
          tD = c;
        } else {
          sN = b * e - c * d;
          tN = a * e - b * d;
          if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
          } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
          }
        }
        if (tN < 0) {
          tN = 0;
          if (-d < 0)
            sN = 0;
          else if (-d > a)
            sN = sD;
          else {
            sN = -d;
            sD = a;
          }
        } else if (tN > tD) {
          tN = tD;
          if (-d + b < 0)
            sN = 0;
          else if (-d + b > a)
            sN = sD;
          else {
            sN = -d + b;
            sD = a;
          }
        }
        sc = sN === 0 ? 0 : sN / sD;
        tc = tN === 0 ? 0 : tN / tD;
        var cx = (1 - sc) * x02 + sc * x12;
        var cy = (1 - sc) * y0 + sc * y1;
        var cx2 = (1 - tc) * x2 + tc * x3;
        var cy2 = (1 - tc) * y2 + tc * y3;
        var dx = cx2 - cx;
        var dy = cy2 - cy;
        return dx * dx + dy * dy;
      }
      function compareByX(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
      }
      function convexHull(points) {
        points.sort(compareByX);
        var lower = [];
        for (var i = 0; i < points.length; i++) {
          while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
            lower.pop();
          }
          lower.push(points[i]);
        }
        var upper = [];
        for (var ii = points.length - 1; ii >= 0; ii--) {
          while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
            upper.pop();
          }
          upper.push(points[ii]);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
      }
    }
  });

  // ../../../../../../../node_modules/quickselect/quickselect.js
  var require_quickselect = __commonJS({
    "../../../../../../../node_modules/quickselect/quickselect.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.quickselect = factory();
      })(exports, function() {
        "use strict";
        function quickselect(arr, k, left, right, compare) {
          quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
        }
        function quickselectStep(arr, k, left, right, compare) {
          while (right > left) {
            if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
            }
            var t = arr[k];
            var i = left;
            var j = right;
            swap(arr, left, k);
            if (compare(arr[right], t) > 0)
              swap(arr, left, right);
            while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0)
                i++;
              while (compare(arr[j], t) > 0)
                j--;
            }
            if (compare(arr[left], t) === 0)
              swap(arr, left, j);
            else {
              j++;
              swap(arr, j, right);
            }
            if (j <= k)
              left = j + 1;
            if (k <= j)
              right = j - 1;
          }
        }
        function swap(arr, i, j) {
          var tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
        }
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return quickselect;
      });
    }
  });

  // ../../../../../../../node_modules/rbush/index.js
  var require_rbush = __commonJS({
    "../../../../../../../node_modules/rbush/index.js"(exports, module) {
      "use strict";
      module.exports = rbush6;
      module.exports.default = rbush6;
      var quickselect = require_quickselect();
      function rbush6(maxEntries, format) {
        if (!(this instanceof rbush6))
          return new rbush6(maxEntries, format);
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        if (format) {
          this._initFormat(format);
        }
        this.clear();
      }
      rbush6.prototype = {
        all: function() {
          return this._all(this.data, []);
        },
        search: function(bbox3) {
          var node = this.data, result = [], toBBox = this.toBBox;
          if (!intersects2(bbox3, node))
            return result;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects2(bbox3, childBBox)) {
                if (node.leaf)
                  result.push(child);
                else if (contains(bbox3, childBBox))
                  this._all(child, result);
                else
                  nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return result;
        },
        collides: function(bbox3) {
          var node = this.data, toBBox = this.toBBox;
          if (!intersects2(bbox3, node))
            return false;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects2(bbox3, childBBox)) {
                if (node.leaf || contains(bbox3, childBBox))
                  return true;
                nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return false;
        },
        load: function(data) {
          if (!(data && data.length))
            return this;
          if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
              this.insert(data[i]);
            }
            return this;
          }
          var node = this._build(data.slice(), 0, data.length - 1, 0);
          if (!this.data.children.length) {
            this.data = node;
          } else if (this.data.height === node.height) {
            this._splitRoot(this.data, node);
          } else {
            if (this.data.height < node.height) {
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
            }
            this._insert(node, this.data.height - node.height - 1, true);
          }
          return this;
        },
        insert: function(item) {
          if (item)
            this._insert(item, this.data.height - 1);
          return this;
        },
        clear: function() {
          this.data = createNode([]);
          return this;
        },
        remove: function(item, equalsFn) {
          if (!item)
            return this;
          var node = this.data, bbox3 = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
          while (node || path.length) {
            if (!node) {
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
            }
            if (node.leaf) {
              index = findItem(item, node.children, equalsFn);
              if (index !== -1) {
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
              }
            }
            if (!goingUp && !node.leaf && contains(node, bbox3)) {
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];
            } else if (parent) {
              i++;
              node = parent.children[i];
              goingUp = false;
            } else
              node = null;
          }
          return this;
        },
        toBBox: function(item) {
          return item;
        },
        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,
        toJSON: function() {
          return this.data;
        },
        fromJSON: function(data) {
          this.data = data;
          return this;
        },
        _all: function(node, result) {
          var nodesToSearch = [];
          while (node) {
            if (node.leaf)
              result.push.apply(result, node.children);
            else
              nodesToSearch.push.apply(nodesToSearch, node.children);
            node = nodesToSearch.pop();
          }
          return result;
        },
        _build: function(items, left, right, height) {
          var N = right - left + 1, M = this._maxEntries, node;
          if (N <= M) {
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
          }
          if (!height) {
            height = Math.ceil(Math.log(N) / Math.log(M));
            M = Math.ceil(N / Math.pow(M, height - 1));
          }
          node = createNode([]);
          node.leaf = false;
          node.height = height;
          var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
          multiSelect(items, left, right, N1, this.compareMinX);
          for (i = left; i <= right; i += N1) {
            right2 = Math.min(i + N1 - 1, right);
            multiSelect(items, i, right2, N2, this.compareMinY);
            for (j = i; j <= right2; j += N2) {
              right3 = Math.min(j + N2 - 1, right2);
              node.children.push(this._build(items, j, right3, height - 1));
            }
          }
          calcBBox(node, this.toBBox);
          return node;
        },
        _chooseSubtree: function(bbox3, node, level, path) {
          var i, len, child, targetNode, area2, enlargement, minArea, minEnlargement;
          while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level)
              break;
            minArea = minEnlargement = Infinity;
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              area2 = bboxArea(child);
              enlargement = enlargedArea(bbox3, child) - area2;
              if (enlargement < minEnlargement) {
                minEnlargement = enlargement;
                minArea = area2 < minArea ? area2 : minArea;
                targetNode = child;
              } else if (enlargement === minEnlargement) {
                if (area2 < minArea) {
                  minArea = area2;
                  targetNode = child;
                }
              }
            }
            node = targetNode || node.children[0];
          }
          return node;
        },
        _insert: function(item, level, isNode) {
          var toBBox = this.toBBox, bbox3 = isNode ? item : toBBox(item), insertPath = [];
          var node = this._chooseSubtree(bbox3, this.data, level, insertPath);
          node.children.push(item);
          extend(node, bbox3);
          while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
            } else
              break;
          }
          this._adjustParentBBoxes(bbox3, insertPath, level);
        },
        // split overflowed node into two
        _split: function(insertPath, level) {
          var node = insertPath[level], M = node.children.length, m = this._minEntries;
          this._chooseSplitAxis(node, m, M);
          var splitIndex = this._chooseSplitIndex(node, m, M);
          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;
          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);
          if (level)
            insertPath[level - 1].children.push(newNode);
          else
            this._splitRoot(node, newNode);
        },
        _splitRoot: function(node, newNode) {
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
        },
        _chooseSplitIndex: function(node, m, M) {
          var i, bbox1, bbox22, overlap, area2, minOverlap, minArea, index;
          minOverlap = minArea = Infinity;
          for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox22 = distBBox(node, i, M, this.toBBox);
            overlap = intersectionArea(bbox1, bbox22);
            area2 = bboxArea(bbox1) + bboxArea(bbox22);
            if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;
              minArea = area2 < minArea ? area2 : minArea;
            } else if (overlap === minOverlap) {
              if (area2 < minArea) {
                minArea = area2;
                index = i;
              }
            }
          }
          return index;
        },
        // sorts node children by the best axis for split
        _chooseSplitAxis: function(node, m, M) {
          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
          if (xMargin < yMargin)
            node.children.sort(compareMinX);
        },
        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function(node, m, M, compare) {
          node.children.sort(compare);
          var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
          for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
          }
          for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
          }
          return margin;
        },
        _adjustParentBBoxes: function(bbox3, path, level) {
          for (var i = level; i >= 0; i--) {
            extend(path[i], bbox3);
          }
        },
        _condense: function(path) {
          for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
              if (i > 0) {
                siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);
              } else
                this.clear();
            } else
              calcBBox(path[i], this.toBBox);
          }
        },
        _initFormat: function(format) {
          var compareArr = ["return a", " - b", ";"];
          this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
          this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
          this.toBBox = new Function(
            "a",
            "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};"
          );
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn)
          return items.indexOf(item);
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i]))
            return i;
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode)
          destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k, child; i < p; i++) {
          child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
      }
      function compareNodeMinX(a, b) {
        return a.minX - b.minX;
      }
      function compareNodeMinY(a, b) {
        return a.minY - b.minY;
      }
      function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
      }
      function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
      }
      function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
      }
      function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
      }
      function intersects2(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right], mid;
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n)
            continue;
          mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);
          stack.push(left, mid, mid, right);
        }
      }
    }
  });

  // ../../../../../../../node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "../../../../../../../node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x2 = data[i];
            y2 = data[i + 1];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area2(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p = c.next;
        while (p !== a) {
          if (p.x >= x02 && p.x <= x12 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x02, y0, minX, minY, invSize), maxZ = zOrder(x12, y1, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p.x >= x02 && p.x <= x12 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n.x >= x02 && n.x <= x12 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p.x >= x02 && p.x <= x12 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n.x >= x02 && n.x <= x12 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
          var a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects2(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              m = p.x < p.next.x ? p : p.next;
              if (x2 === hx)
                return m;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan2 = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan2;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
          if (p.z === 0)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = (x2 - minX) * invSize | 0;
        y2 = (y2 - minY) * invSize | 0;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
        (area2(a.prev, a, b.prev) || area2(a, b.prev, b)) || // does not create opposite-facing sectors
        equals(a, b) && area2(a.prev, a, a.next) > 0 && area2(b.prev, b, b.next) > 0);
      }
      function area2(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects2(p1, q1, p2, q2) {
        var o1 = sign2(area2(p1, q1, p2));
        var o2 = sign2(area2(p1, q1, q2));
        var o3 = sign2(area2(p2, q2, p1));
        var o4 = sign2(area2(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        var p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects2(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area2(a.prev, a, a.next) < 0 ? area2(a, b, a.next) >= 0 && area2(a, a.prev, b) >= 0 : area2(a, b, a.prev) < 0 || area2(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x2, y2, last) {
        var p = new Node2(i, x2, y2);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node2(i, x2, y2) {
        this.i = i;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea2 = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea2 -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
          );
        }
        return polygonArea2 === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea2) / polygonArea2);
      };
      function signedArea(data, start, end, dim) {
        var sum2 = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
          sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum2;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // ../../../../../../../node_modules/geojson-rbush/node_modules/rbush/rbush.min.js
  var require_rbush_min2 = __commonJS({
    "../../../../../../../node_modules/geojson-rbush/node_modules/rbush/rbush.min.js"(exports, module) {
      !function(t, i) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
      }(exports, function() {
        "use strict";
        function t(t2, r2, e3, a2, h2) {
          !function t3(n2, r3, e4, a3, h3) {
            for (; a3 > e4; ) {
              if (a3 - e4 > 600) {
                var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                t3(n2, r3, m2, c2, h3);
              }
              var p2 = n2[r3], d2 = e4, x2 = a3;
              for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
                for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
                  d2++;
                for (; h3(n2[x2], p2) > 0; )
                  x2--;
              }
              0 === h3(n2[e4], p2) ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
            }
          }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
        }
        function i(t2, i2, n2) {
          var r2 = t2[i2];
          t2[i2] = t2[n2], t2[n2] = r2;
        }
        function n(t2, i2) {
          return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
        }
        var r = function(t2) {
          void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e(t2, i2, n2) {
          if (!n2)
            return i2.indexOf(t2);
          for (var r2 = 0; r2 < i2.length; r2++)
            if (n2(t2, i2[r2]))
              return r2;
          return -1;
        }
        function a(t2, i2) {
          h(t2, 0, t2.children.length, i2, t2);
        }
        function h(t2, i2, n2, r2, e3) {
          e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
          for (var a2 = i2; a2 < n2; a2++) {
            var h2 = t2.children[a2];
            o(e3, t2.leaf ? r2(h2) : h2);
          }
          return e3;
        }
        function o(t2, i2) {
          return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
        }
        function s(t2, i2) {
          return t2.minX - i2.minX;
        }
        function l(t2, i2) {
          return t2.minY - i2.minY;
        }
        function f(t2) {
          return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
        }
        function u(t2) {
          return t2.maxX - t2.minX + (t2.maxY - t2.minY);
        }
        function m(t2, i2) {
          return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
        }
        function c(t2, i2) {
          return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
        }
        function p(t2) {
          return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d(i2, n2, r2, e3, a2) {
          for (var h2 = [n2, r2]; h2.length; )
            if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
              var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
              t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
            }
        }
        return r.prototype.all = function() {
          return this._all(this.data, []);
        }, r.prototype.search = function(t2) {
          var i2 = this.data, n2 = [];
          if (!c(t2, i2))
            return n2;
          for (var r2 = this.toBBox, e3 = []; i2; ) {
            for (var a2 = 0; a2 < i2.children.length; a2++) {
              var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
              c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
            }
            i2 = e3.pop();
          }
          return n2;
        }, r.prototype.collides = function(t2) {
          var i2 = this.data;
          if (!c(t2, i2))
            return false;
          for (var n2 = []; i2; ) {
            for (var r2 = 0; r2 < i2.children.length; r2++) {
              var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
              if (c(t2, a2)) {
                if (i2.leaf || m(t2, a2))
                  return true;
                n2.push(e3);
              }
            }
            i2 = n2.pop();
          }
          return false;
        }, r.prototype.load = function(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (var i2 = 0; i2 < t2.length; i2++)
              this.insert(t2[i2]);
            return this;
          }
          var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n2.height)
              this._splitRoot(this.data, n2);
            else {
              if (this.data.height < n2.height) {
                var r2 = this.data;
                this.data = n2, n2 = r2;
              }
              this._insert(n2, this.data.height - n2.height - 1, true);
            }
          else
            this.data = n2;
          return this;
        }, r.prototype.insert = function(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }, r.prototype.clear = function() {
          return this.data = p([]), this;
        }, r.prototype.remove = function(t2, i2) {
          if (!t2)
            return this;
          for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
            if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
              var f2 = e(t2, h2.children, i2);
              if (-1 !== f2)
                return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
            }
            a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
          }
          return this;
        }, r.prototype.toBBox = function(t2) {
          return t2;
        }, r.prototype.compareMinX = function(t2, i2) {
          return t2.minX - i2.minX;
        }, r.prototype.compareMinY = function(t2, i2) {
          return t2.minY - i2.minY;
        }, r.prototype.toJSON = function() {
          return this.data;
        }, r.prototype.fromJSON = function(t2) {
          return this.data = t2, this;
        }, r.prototype._all = function(t2, i2) {
          for (var n2 = []; t2; )
            t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
          return i2;
        }, r.prototype._build = function(t2, i2, n2, r2) {
          var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
          if (h2 <= o2)
            return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
          r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
          var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
          d(t2, i2, n2, l2, this.compareMinX);
          for (var f2 = i2; f2 <= n2; f2 += l2) {
            var u2 = Math.min(f2 + l2 - 1, n2);
            d(t2, f2, u2, s2, this.compareMinY);
            for (var m2 = f2; m2 <= u2; m2 += s2) {
              var c2 = Math.min(m2 + s2 - 1, u2);
              e3.children.push(this._build(t2, m2, c2, r2 - 1));
            }
          }
          return a(e3, this.toBBox), e3;
        }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
          for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
            for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
              var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
              u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
            }
            i2 = h2 || i2.children[0];
          }
          var m2, c2;
          return i2;
        }, r.prototype._insert = function(t2, i2, n2) {
          var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
          for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
            this._split(e3, i2), i2--;
          this._adjustParentBBoxes(r2, e3, i2);
        }, r.prototype._split = function(t2, i2) {
          var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
          this._chooseSplitAxis(n2, e3, r2);
          var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
          o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
        }, r.prototype._splitRoot = function(t2, i2) {
          this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
        }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
          for (var r2, e3, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
            var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
            v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
          }
          return r2 || n2 - i2;
        }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
          var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
          this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
        }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
          t2.children.sort(r2);
          for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
            var m2 = t2.children[f2];
            o(a2, t2.leaf ? e3(m2) : m2), l2 += u(a2);
          }
          for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
            var p2 = t2.children[c2];
            o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
          }
          return l2;
        }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
          for (var r2 = n2; r2 >= 0; r2--)
            o(i2[r2], t2);
        }, r.prototype._condense = function(t2) {
          for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
            0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
        }, r;
      });
    }
  });

  // ../../../../../../../node_modules/@turf/helpers/dist/js/index.js
  var require_js = __commonJS({
    "../../../../../../../node_modules/@turf/helpers/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.earthRadius = 63710088e-1;
      exports.factors = {
        centimeters: exports.earthRadius * 100,
        centimetres: exports.earthRadius * 100,
        degrees: exports.earthRadius / 111325,
        feet: exports.earthRadius * 3.28084,
        inches: exports.earthRadius * 39.37,
        kilometers: exports.earthRadius / 1e3,
        kilometres: exports.earthRadius / 1e3,
        meters: exports.earthRadius,
        metres: exports.earthRadius,
        miles: exports.earthRadius / 1609.344,
        millimeters: exports.earthRadius * 1e3,
        millimetres: exports.earthRadius * 1e3,
        nauticalmiles: exports.earthRadius / 1852,
        radians: 1,
        yards: exports.earthRadius * 1.0936
      };
      exports.unitsFactors = {
        centimeters: 100,
        centimetres: 100,
        degrees: 1 / 111325,
        feet: 3.28084,
        inches: 39.37,
        kilometers: 1 / 1e3,
        kilometres: 1 / 1e3,
        meters: 1,
        metres: 1,
        miles: 1 / 1609.344,
        millimeters: 1e3,
        millimetres: 1e3,
        nauticalmiles: 1 / 1852,
        radians: 1 / exports.earthRadius,
        yards: 1.0936133
      };
      exports.areaFactors = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
      };
      function feature2(geom, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var feat = { type: "Feature" };
        if (options.id === 0 || options.id) {
          feat.id = options.id;
        }
        if (options.bbox) {
          feat.bbox = options.bbox;
        }
        feat.properties = properties || {};
        feat.geometry = geom;
        return feat;
      }
      exports.feature = feature2;
      function geometry(type, coordinates, _options) {
        if (_options === void 0) {
          _options = {};
        }
        switch (type) {
          case "Point":
            return point2(coordinates).geometry;
          case "LineString":
            return lineString2(coordinates).geometry;
          case "Polygon":
            return polygon2(coordinates).geometry;
          case "MultiPoint":
            return multiPoint2(coordinates).geometry;
          case "MultiLineString":
            return multiLineString2(coordinates).geometry;
          case "MultiPolygon":
            return multiPolygon2(coordinates).geometry;
          default:
            throw new Error(type + " is invalid");
        }
      }
      exports.geometry = geometry;
      function point2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (!coordinates) {
          throw new Error("coordinates is required");
        }
        if (!Array.isArray(coordinates)) {
          throw new Error("coordinates must be an Array");
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be at least 2 numbers long");
        }
        if (!isNumber2(coordinates[0]) || !isNumber2(coordinates[1])) {
          throw new Error("coordinates must contain numbers");
        }
        var geom = {
          type: "Point",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.point = point2;
      function points(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return point2(coords, properties);
        }), options);
      }
      exports.points = points;
      function polygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
          var ring = coordinates_1[_i];
          if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
          }
          for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
              throw new Error("First and last Position are not equivalent.");
            }
          }
        }
        var geom = {
          type: "Polygon",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.polygon = polygon2;
      function polygons(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return polygon2(coords, properties);
        }), options);
      }
      exports.polygons = polygons;
      function lineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be an array of two or more positions");
        }
        var geom = {
          type: "LineString",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.lineString = lineString2;
      function lineStrings(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return lineString2(coords, properties);
        }), options);
      }
      exports.lineStrings = lineStrings;
      function featureCollection2(features, options) {
        if (options === void 0) {
          options = {};
        }
        var fc = { type: "FeatureCollection" };
        if (options.id) {
          fc.id = options.id;
        }
        if (options.bbox) {
          fc.bbox = options.bbox;
        }
        fc.features = features;
        return fc;
      }
      exports.featureCollection = featureCollection2;
      function multiLineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiLineString",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiLineString = multiLineString2;
      function multiPoint2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPoint",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiPoint = multiPoint2;
      function multiPolygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPolygon",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiPolygon = multiPolygon2;
      function geometryCollection2(geometries, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "GeometryCollection",
          geometries
        };
        return feature2(geom, properties, options);
      }
      exports.geometryCollection = geometryCollection2;
      function round2(num, precision) {
        if (precision === void 0) {
          precision = 0;
        }
        if (precision && !(precision >= 0)) {
          throw new Error("precision must be a positive number");
        }
        var multiplier = Math.pow(10, precision || 0);
        return Math.round(num * multiplier) / multiplier;
      }
      exports.round = round2;
      function radiansToLength2(radians2, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return radians2 * factor;
      }
      exports.radiansToLength = radiansToLength2;
      function lengthToRadians2(distance2, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return distance2 / factor;
      }
      exports.lengthToRadians = lengthToRadians2;
      function lengthToDegrees2(distance2, units) {
        return radiansToDegrees2(lengthToRadians2(distance2, units));
      }
      exports.lengthToDegrees = lengthToDegrees2;
      function bearingToAzimuth2(bearing2) {
        var angle = bearing2 % 360;
        if (angle < 0) {
          angle += 360;
        }
        return angle;
      }
      exports.bearingToAzimuth = bearingToAzimuth2;
      function radiansToDegrees2(radians2) {
        var degrees2 = radians2 % (2 * Math.PI);
        return degrees2 * 180 / Math.PI;
      }
      exports.radiansToDegrees = radiansToDegrees2;
      function degreesToRadians2(degrees2) {
        var radians2 = degrees2 % 360;
        return radians2 * Math.PI / 180;
      }
      exports.degreesToRadians = degreesToRadians2;
      function convertLength2(length2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "kilometers";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(length2 >= 0)) {
          throw new Error("length must be a positive number");
        }
        return radiansToLength2(lengthToRadians2(length2, originalUnit), finalUnit);
      }
      exports.convertLength = convertLength2;
      function convertArea(area2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "meters";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(area2 >= 0)) {
          throw new Error("area must be a positive number");
        }
        var startFactor = exports.areaFactors[originalUnit];
        if (!startFactor) {
          throw new Error("invalid original units");
        }
        var finalFactor = exports.areaFactors[finalUnit];
        if (!finalFactor) {
          throw new Error("invalid final units");
        }
        return area2 / startFactor * finalFactor;
      }
      exports.convertArea = convertArea;
      function isNumber2(num) {
        return !isNaN(num) && num !== null && !Array.isArray(num);
      }
      exports.isNumber = isNumber2;
      function isObject2(input) {
        return !!input && input.constructor === Object;
      }
      exports.isObject = isObject2;
      function validateBBox(bbox3) {
        if (!bbox3) {
          throw new Error("bbox is required");
        }
        if (!Array.isArray(bbox3)) {
          throw new Error("bbox must be an Array");
        }
        if (bbox3.length !== 4 && bbox3.length !== 6) {
          throw new Error("bbox must be an Array of 4 or 6 numbers");
        }
        bbox3.forEach(function(num) {
          if (!isNumber2(num)) {
            throw new Error("bbox must only contain numbers");
          }
        });
      }
      exports.validateBBox = validateBBox;
      function validateId(id) {
        if (!id) {
          throw new Error("id is required");
        }
        if (["string", "number"].indexOf(typeof id) === -1) {
          throw new Error("id must be a number or a string");
        }
      }
      exports.validateId = validateId;
    }
  });

  // ../../../../../../../node_modules/@turf/meta/dist/js/index.js
  var require_js2 = __commonJS({
    "../../../../../../../node_modules/@turf/meta/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var helpers = require_js();
      function coordEach2(geojson, callback, excludeWrapCoord) {
        if (geojson === null)
          return;
        var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null)
              continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch (geomType) {
              case null:
                break;
              case "Point":
                if (callback(
                  coords,
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
              case "LineString":
              case "MultiPoint":
                for (j = 0; j < coords.length; j++) {
                  if (callback(
                    coords[j],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                  if (geomType === "MultiPoint")
                    multiFeatureIndex++;
                }
                if (geomType === "LineString")
                  multiFeatureIndex++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (j = 0; j < coords.length; j++) {
                  for (k = 0; k < coords[j].length - wrapShrink; k++) {
                    if (callback(
                      coords[j][k],
                      coordIndex,
                      featureIndex,
                      multiFeatureIndex,
                      geometryIndex
                    ) === false)
                      return false;
                    coordIndex++;
                  }
                  if (geomType === "MultiLineString")
                    multiFeatureIndex++;
                  if (geomType === "Polygon")
                    geometryIndex++;
                }
                if (geomType === "Polygon")
                  multiFeatureIndex++;
                break;
              case "MultiPolygon":
                for (j = 0; j < coords.length; j++) {
                  geometryIndex = 0;
                  for (k = 0; k < coords[j].length; k++) {
                    for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                      if (callback(
                        coords[j][k][l],
                        coordIndex,
                        featureIndex,
                        multiFeatureIndex,
                        geometryIndex
                      ) === false)
                        return false;
                      coordIndex++;
                    }
                    geometryIndex++;
                  }
                  multiFeatureIndex++;
                }
                break;
              case "GeometryCollection":
                for (j = 0; j < geometry.geometries.length; j++)
                  if (coordEach2(geometry.geometries[j], callback, excludeWrapCoord) === false)
                    return false;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
      function coordReduce2(geojson, callback, initialValue, excludeWrapCoord) {
        var previousValue = initialValue;
        coordEach2(
          geojson,
          function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
            if (coordIndex === 0 && initialValue === void 0)
              previousValue = currentCoord;
            else
              previousValue = callback(
                previousValue,
                currentCoord,
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          },
          excludeWrapCoord
        );
        return previousValue;
      }
      function propEach(geojson, callback) {
        var i;
        switch (geojson.type) {
          case "FeatureCollection":
            for (i = 0; i < geojson.features.length; i++) {
              if (callback(geojson.features[i].properties, i) === false)
                break;
            }
            break;
          case "Feature":
            callback(geojson.properties, 0);
            break;
        }
      }
      function propReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        propEach(geojson, function(currentProperties, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentProperties;
          else
            previousValue = callback(previousValue, currentProperties, featureIndex);
        });
        return previousValue;
      }
      function featureEach2(geojson, callback) {
        if (geojson.type === "Feature") {
          callback(geojson, 0);
        } else if (geojson.type === "FeatureCollection") {
          for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false)
              break;
          }
        }
      }
      function featureReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        featureEach2(geojson, function(currentFeature, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentFeature;
          else
            previousValue = callback(previousValue, currentFeature, featureIndex);
        });
        return previousValue;
      }
      function coordAll2(geojson) {
        var coords = [];
        coordEach2(geojson, function(coord) {
          coords.push(coord);
        });
        return coords;
      }
      function geomEach2(geojson, callback) {
        var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (i = 0; i < stop; i++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
              if (callback(
                null,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
              continue;
            }
            switch (geometry.type) {
              case "Point":
              case "LineString":
              case "MultiPoint":
              case "Polygon":
              case "MultiLineString":
              case "MultiPolygon": {
                if (callback(
                  geometry,
                  featureIndex,
                  featureProperties,
                  featureBBox,
                  featureId
                ) === false)
                  return false;
                break;
              }
              case "GeometryCollection": {
                for (j = 0; j < geometry.geometries.length; j++) {
                  if (callback(
                    geometry.geometries[j],
                    featureIndex,
                    featureProperties,
                    featureBBox,
                    featureId
                  ) === false)
                    return false;
                }
                break;
              }
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
          featureIndex++;
        }
      }
      function geomReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        geomEach2(
          geojson,
          function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentGeometry;
            else
              previousValue = callback(
                previousValue,
                currentGeometry,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              );
          }
        );
        return previousValue;
      }
      function flattenEach2(geojson, callback) {
        geomEach2(geojson, function(geometry, featureIndex, properties, bbox3, id) {
          var type = geometry === null ? null : geometry.type;
          switch (type) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
              if (callback(
                helpers.feature(geometry, properties, { bbox: bbox3, id }),
                featureIndex,
                0
              ) === false)
                return false;
              return;
          }
          var geomType;
          switch (type) {
            case "MultiPoint":
              geomType = "Point";
              break;
            case "MultiLineString":
              geomType = "LineString";
              break;
            case "MultiPolygon":
              geomType = "Polygon";
              break;
          }
          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
              type: geomType,
              coordinates: coordinate
            };
            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false)
              return false;
          }
        });
      }
      function flattenReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        flattenEach2(
          geojson,
          function(currentFeature, featureIndex, multiFeatureIndex) {
            if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
              previousValue = currentFeature;
            else
              previousValue = callback(
                previousValue,
                currentFeature,
                featureIndex,
                multiFeatureIndex
              );
          }
        );
        return previousValue;
      }
      function segmentEach2(geojson, callback) {
        flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          var segmentIndex = 0;
          if (!feature2.geometry)
            return;
          var type = feature2.geometry.type;
          if (type === "Point" || type === "MultiPoint")
            return;
          var previousCoords;
          var previousFeatureIndex = 0;
          var previousMultiIndex = 0;
          var prevGeomIndex = 0;
          if (coordEach2(
            feature2,
            function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
              if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
              }
              var currentSegment = helpers.lineString(
                [previousCoords, currentCoord],
                feature2.properties
              );
              if (callback(
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              ) === false)
                return false;
              segmentIndex++;
              previousCoords = currentCoord;
            }
          ) === false)
            return false;
        });
      }
      function segmentReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        var started = false;
        segmentEach2(
          geojson,
          function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
            if (started === false && initialValue === void 0)
              previousValue = currentSegment;
            else
              previousValue = callback(
                previousValue,
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              );
            started = true;
          }
        );
        return previousValue;
      }
      function lineEach(geojson, callback) {
        if (!geojson)
          throw new Error("geojson is required");
        flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          if (feature2.geometry === null)
            return;
          var type = feature2.geometry.type;
          var coords = feature2.geometry.coordinates;
          switch (type) {
            case "LineString":
              if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
                return false;
              break;
            case "Polygon":
              for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(
                  helpers.lineString(coords[geometryIndex], feature2.properties),
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
              }
              break;
          }
        });
      }
      function lineReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        lineEach(
          geojson,
          function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentLine;
            else
              previousValue = callback(
                previousValue,
                currentLine,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          }
        );
        return previousValue;
      }
      function findSegment(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var segmentIndex = options.segmentIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
            if (segmentIndex < 0)
              segmentIndex = coords.length + segmentIndex - 1;
            return helpers.lineString(
              [coords[segmentIndex], coords[segmentIndex + 1]],
              properties,
              options
            );
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
            return helpers.lineString(
              [
                coords[geometryIndex][segmentIndex],
                coords[geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
            return helpers.lineString(
              [
                coords[multiFeatureIndex][segmentIndex],
                coords[multiFeatureIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
            return helpers.lineString(
              [
                coords[multiFeatureIndex][geometryIndex][segmentIndex],
                coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      function findPoint(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var coordIndex = options.coordIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
            return helpers.point(coords, properties, options);
          case "MultiPoint":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            return helpers.point(coords[multiFeatureIndex], properties, options);
          case "LineString":
            if (coordIndex < 0)
              coordIndex = coords.length + coordIndex;
            return helpers.point(coords[coordIndex], properties, options);
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[geometryIndex].length + coordIndex;
            return helpers.point(coords[geometryIndex][coordIndex], properties, options);
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex].length + coordIndex;
            return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
            return helpers.point(
              coords[multiFeatureIndex][geometryIndex][coordIndex],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      exports.coordAll = coordAll2;
      exports.coordEach = coordEach2;
      exports.coordReduce = coordReduce2;
      exports.featureEach = featureEach2;
      exports.featureReduce = featureReduce2;
      exports.findPoint = findPoint;
      exports.findSegment = findSegment;
      exports.flattenEach = flattenEach2;
      exports.flattenReduce = flattenReduce;
      exports.geomEach = geomEach2;
      exports.geomReduce = geomReduce2;
      exports.lineEach = lineEach;
      exports.lineReduce = lineReduce2;
      exports.propEach = propEach;
      exports.propReduce = propReduce;
      exports.segmentEach = segmentEach2;
      exports.segmentReduce = segmentReduce2;
    }
  });

  // ../../../../../../../node_modules/@turf/bbox/dist/js/index.js
  var require_js3 = __commonJS({
    "../../../../../../../node_modules/@turf/bbox/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var meta_1 = require_js2();
      function bbox3(geojson) {
        var result = [Infinity, Infinity, -Infinity, -Infinity];
        meta_1.coordEach(geojson, function(coord) {
          if (result[0] > coord[0]) {
            result[0] = coord[0];
          }
          if (result[1] > coord[1]) {
            result[1] = coord[1];
          }
          if (result[2] < coord[0]) {
            result[2] = coord[0];
          }
          if (result[3] < coord[1]) {
            result[3] = coord[1];
          }
        });
        return result;
      }
      bbox3["default"] = bbox3;
      exports.default = bbox3;
    }
  });

  // ../../../../../../../node_modules/geojson-rbush/index.js
  var require_geojson_rbush = __commonJS({
    "../../../../../../../node_modules/geojson-rbush/index.js"(exports, module) {
      var rbush6 = require_rbush_min2();
      var helpers = require_js();
      var meta = require_js2();
      var turfBBox = require_js3().default;
      var featureEach2 = meta.featureEach;
      var coordEach2 = meta.coordEach;
      var polygon2 = helpers.polygon;
      var featureCollection2 = helpers.featureCollection;
      function geojsonRbush(maxEntries) {
        var tree = new rbush6(maxEntries);
        tree.insert = function(feature2) {
          if (feature2.type !== "Feature")
            throw new Error("invalid feature");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          return rbush6.prototype.insert.call(this, feature2);
        };
        tree.load = function(features) {
          var load = [];
          if (Array.isArray(features)) {
            features.forEach(function(feature2) {
              if (feature2.type !== "Feature")
                throw new Error("invalid features");
              feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
              load.push(feature2);
            });
          } else {
            featureEach2(features, function(feature2) {
              if (feature2.type !== "Feature")
                throw new Error("invalid features");
              feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
              load.push(feature2);
            });
          }
          return rbush6.prototype.load.call(this, load);
        };
        tree.remove = function(feature2, equals) {
          if (feature2.type !== "Feature")
            throw new Error("invalid feature");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          return rbush6.prototype.remove.call(this, feature2, equals);
        };
        tree.clear = function() {
          return rbush6.prototype.clear.call(this);
        };
        tree.search = function(geojson) {
          var features = rbush6.prototype.search.call(this, this.toBBox(geojson));
          return featureCollection2(features);
        };
        tree.collides = function(geojson) {
          return rbush6.prototype.collides.call(this, this.toBBox(geojson));
        };
        tree.all = function() {
          var features = rbush6.prototype.all.call(this);
          return featureCollection2(features);
        };
        tree.toJSON = function() {
          return rbush6.prototype.toJSON.call(this);
        };
        tree.fromJSON = function(json) {
          return rbush6.prototype.fromJSON.call(this, json);
        };
        tree.toBBox = function(geojson) {
          var bbox3;
          if (geojson.bbox)
            bbox3 = geojson.bbox;
          else if (Array.isArray(geojson) && geojson.length === 4)
            bbox3 = geojson;
          else if (Array.isArray(geojson) && geojson.length === 6)
            bbox3 = [geojson[0], geojson[1], geojson[3], geojson[4]];
          else if (geojson.type === "Feature")
            bbox3 = turfBBox(geojson);
          else if (geojson.type === "FeatureCollection")
            bbox3 = turfBBox(geojson);
          else
            throw new Error("invalid geojson");
          return {
            minX: bbox3[0],
            minY: bbox3[1],
            maxX: bbox3[2],
            maxY: bbox3[3]
          };
        };
        return tree;
      }
      module.exports = geojsonRbush;
      module.exports.default = geojsonRbush;
    }
  });

  // ../../../../../../../node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "../../../../../../../node_modules/object-keys/isArguments.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
          isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // ../../../../../../../node_modules/object-keys/implementation.js
  var require_implementation = __commonJS({
    "../../../../../../../node_modules/object-keys/implementation.js"(exports, module) {
      "use strict";
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object2) {
          var isObject2 = object2 !== null && typeof object2 === "object";
          var isFunction = toStr.call(object2) === "[object Function]";
          var isArguments = isArgs(object2);
          var isString = isObject2 && toStr.call(object2) === "[object String]";
          var theKeys = [];
          if (!isObject2 && !isFunction && !isArguments) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object2.length > 0 && !has.call(object2, 0)) {
            for (var i = 0; i < object2.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object2.length > 0) {
            for (var j = 0; j < object2.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object2) {
              if (!(skipProto && name === "prototype") && has.call(object2, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object2, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module.exports = keysShim;
    }
  });

  // ../../../../../../../node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "../../../../../../../node_modules/object-keys/index.js"(exports, module) {
      "use strict";
      var slice2 = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object2) {
              if (isArgs(object2)) {
                return originalKeys(slice2.call(object2));
              }
              return originalKeys(object2);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    }
  });

  // ../../../../../../../node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "../../../../../../../node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // ../../../../../../../node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "../../../../../../../node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // ../../../../../../../node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "../../../../../../../node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // ../../../../../../../node_modules/has-proto/index.js
  var require_has_proto = __commonJS({
    "../../../../../../../node_modules/has-proto/index.js"(exports, module) {
      "use strict";
      var test = {
        foo: {}
      };
      var $Object = Object;
      module.exports = function hasProto() {
        return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
      };
    }
  });

  // ../../../../../../../node_modules/function-bind/implementation.js
  var require_implementation2 = __commonJS({
    "../../../../../../../node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice2 = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice2.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              args.concat(slice2.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice2.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // ../../../../../../../node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "../../../../../../../node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      var implementation = require_implementation2();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // ../../../../../../../node_modules/has/src/index.js
  var require_src = __commonJS({
    "../../../../../../../node_modules/has/src/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // ../../../../../../../node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "../../../../../../../node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var hasProto = require_has_proto()();
      var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
        return x2.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      if (getProto) {
        try {
          null.error;
        } catch (e) {
          errorProto = getProto(getProto(e));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var errorProto;
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // ../../../../../../../node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "../../../../../../../node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // ../../../../../../../node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "../../../../../../../node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // ../../../../../../../node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "../../../../../../../node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // ../../../../../../../node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "../../../../../../../node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
            return true;
          } catch (e) {
            return false;
          }
        }
        return false;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!hasPropertyDescriptors()) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // ../../../../../../../node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "../../../../../../../node_modules/define-properties/index.js"(exports, module) {
      "use strict";
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
      };
      var hasPropertyDescriptors = require_has_property_descriptors()();
      var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
      var defineProperty = function(object2, name, value, predicate) {
        if (name in object2) {
          if (predicate === true) {
            if (object2[name] === value) {
              return;
            }
          } else if (!isFunction(predicate) || !predicate()) {
            return;
          }
        }
        if (supportsDescriptors) {
          origDefineProperty(object2, name, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object2[name] = value;
        }
      };
      var defineProperties = function(object2, map3) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map3);
        if (hasSymbols) {
          props = concat.call(props, Object.getOwnPropertySymbols(map3));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object2, props[i], map3[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    }
  });

  // ../../../../../../../node_modules/object-is/implementation.js
  var require_implementation3 = __commonJS({
    "../../../../../../../node_modules/object-is/implementation.js"(exports, module) {
      "use strict";
      var numberIsNaN = function(value) {
        return value !== value;
      };
      module.exports = function is(a, b) {
        if (a === 0 && b === 0) {
          return 1 / a === 1 / b;
        }
        if (a === b) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b)) {
          return true;
        }
        return false;
      };
    }
  });

  // ../../../../../../../node_modules/object-is/polyfill.js
  var require_polyfill = __commonJS({
    "../../../../../../../node_modules/object-is/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation3();
      module.exports = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation;
      };
    }
  });

  // ../../../../../../../node_modules/object-is/shim.js
  var require_shim = __commonJS({
    "../../../../../../../node_modules/object-is/shim.js"(exports, module) {
      "use strict";
      var getPolyfill = require_polyfill();
      var define2 = require_define_properties();
      module.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define2(Object, { is: polyfill }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // ../../../../../../../node_modules/object-is/index.js
  var require_object_is = __commonJS({
    "../../../../../../../node_modules/object-is/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation3();
      var getPolyfill = require_polyfill();
      var shim = require_shim();
      var polyfill = callBind(getPolyfill(), Object);
      define2(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // ../../../../../../../node_modules/is-regex/index.js
  var require_is_regex = __commonJS({
    "../../../../../../../node_modules/is-regex/index.js"(exports, module) {
      "use strict";
      var callBound = require_callBound();
      var hasToStringTag = require_shams2()();
      var has;
      var $exec;
      var isRegexMarker;
      var badStringifier;
      if (hasToStringTag) {
        has = callBound("Object.prototype.hasOwnProperty");
        $exec = callBound("RegExp.prototype.exec");
        isRegexMarker = {};
        throwRegexMarker = function() {
          throw isRegexMarker;
        };
        badStringifier = {
          toString: throwRegexMarker,
          valueOf: throwRegexMarker
        };
        if (typeof Symbol.toPrimitive === "symbol") {
          badStringifier[Symbol.toPrimitive] = throwRegexMarker;
        }
      }
      var throwRegexMarker;
      var $toString = callBound("Object.prototype.toString");
      var gOPD = Object.getOwnPropertyDescriptor;
      var regexClass = "[object RegExp]";
      module.exports = hasToStringTag ? function isRegex(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = gOPD(value, "lastIndex");
        var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(value, badStringifier);
        } catch (e) {
          return e === isRegexMarker;
        }
      } : function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString(value) === regexClass;
      };
    }
  });

  // ../../../../../../../node_modules/functions-have-names/index.js
  var require_functions_have_names = __commonJS({
    "../../../../../../../node_modules/functions-have-names/index.js"(exports, module) {
      "use strict";
      var functionsHaveNames = function functionsHaveNames2() {
        return typeof function f() {
        }.name === "string";
      };
      var gOPD = Object.getOwnPropertyDescriptor;
      if (gOPD) {
        try {
          gOPD([], "length");
        } catch (e) {
          gOPD = null;
        }
      }
      functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
        if (!functionsHaveNames() || !gOPD) {
          return false;
        }
        var desc = gOPD(function() {
        }, "name");
        return !!desc && !!desc.configurable;
      };
      var $bind = Function.prototype.bind;
      functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
        return functionsHaveNames() && typeof $bind === "function" && function f() {
        }.bind().name !== "";
      };
      module.exports = functionsHaveNames;
    }
  });

  // ../../../../../../../node_modules/regexp.prototype.flags/implementation.js
  var require_implementation4 = __commonJS({
    "../../../../../../../node_modules/regexp.prototype.flags/implementation.js"(exports, module) {
      "use strict";
      var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
      var $Object = Object;
      var $TypeError = TypeError;
      module.exports = function flags() {
        if (this != null && this !== $Object(this)) {
          throw new $TypeError("RegExp.prototype.flags getter called on non-object");
        }
        var result = "";
        if (this.hasIndices) {
          result += "d";
        }
        if (this.global) {
          result += "g";
        }
        if (this.ignoreCase) {
          result += "i";
        }
        if (this.multiline) {
          result += "m";
        }
        if (this.dotAll) {
          result += "s";
        }
        if (this.unicode) {
          result += "u";
        }
        if (this.unicodeSets) {
          result += "v";
        }
        if (this.sticky) {
          result += "y";
        }
        return result;
      };
      if (functionsHaveConfigurableNames && Object.defineProperty) {
        Object.defineProperty(module.exports, "name", { value: "get flags" });
      }
    }
  });

  // ../../../../../../../node_modules/regexp.prototype.flags/polyfill.js
  var require_polyfill2 = __commonJS({
    "../../../../../../../node_modules/regexp.prototype.flags/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation4();
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var $gOPD = Object.getOwnPropertyDescriptor;
      module.exports = function getPolyfill() {
        if (supportsDescriptors && /a/mig.flags === "gim") {
          var descriptor = $gOPD(RegExp.prototype, "flags");
          if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
            var calls = "";
            var o = {};
            Object.defineProperty(o, "hasIndices", {
              get: function() {
                calls += "d";
              }
            });
            Object.defineProperty(o, "sticky", {
              get: function() {
                calls += "y";
              }
            });
            if (calls === "dy") {
              return descriptor.get;
            }
          }
        }
        return implementation;
      };
    }
  });

  // ../../../../../../../node_modules/regexp.prototype.flags/shim.js
  var require_shim2 = __commonJS({
    "../../../../../../../node_modules/regexp.prototype.flags/shim.js"(exports, module) {
      "use strict";
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var getPolyfill = require_polyfill2();
      var gOPD = Object.getOwnPropertyDescriptor;
      var defineProperty = Object.defineProperty;
      var TypeErr = TypeError;
      var getProto = Object.getPrototypeOf;
      var regex = /a/;
      module.exports = function shimFlags() {
        if (!supportsDescriptors || !getProto) {
          throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
        }
        var polyfill = getPolyfill();
        var proto = getProto(regex);
        var descriptor = gOPD(proto, "flags");
        if (!descriptor || descriptor.get !== polyfill) {
          defineProperty(proto, "flags", {
            configurable: true,
            enumerable: false,
            get: polyfill
          });
        }
        return polyfill;
      };
    }
  });

  // ../../../../../../../node_modules/regexp.prototype.flags/index.js
  var require_regexp_prototype = __commonJS({
    "../../../../../../../node_modules/regexp.prototype.flags/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation4();
      var getPolyfill = require_polyfill2();
      var shim = require_shim2();
      var flagsBound = callBind(getPolyfill());
      define2(flagsBound, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = flagsBound;
    }
  });

  // ../../../../../../../node_modules/is-date-object/index.js
  var require_is_date_object = __commonJS({
    "../../../../../../../node_modules/is-date-object/index.js"(exports, module) {
      "use strict";
      var getDay = Date.prototype.getDay;
      var tryDateObject = function tryDateGetDayCall(value) {
        try {
          getDay.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var dateClass = "[object Date]";
      var hasToStringTag = require_shams2()();
      module.exports = function isDateObject(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
      };
    }
  });

  // ../../../../../../../node_modules/deep-equal/index.js
  var require_deep_equal = __commonJS({
    "../../../../../../../node_modules/deep-equal/index.js"(exports, module) {
      var objectKeys = require_object_keys();
      var isArguments = require_is_arguments();
      var is = require_object_is();
      var isRegex = require_is_regex();
      var flags = require_regexp_prototype();
      var isDate = require_is_date_object();
      var getTime = Date.prototype.getTime;
      function deepEqual(actual, expected, options) {
        var opts = options || {};
        if (opts.strict ? is(actual, expected) : actual === expected) {
          return true;
        }
        if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
          return opts.strict ? is(actual, expected) : actual == expected;
        }
        return objEquiv(actual, expected, opts);
      }
      function isUndefinedOrNull(value) {
        return value === null || value === void 0;
      }
      function isBuffer(x2) {
        if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
          return false;
        }
        if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
          return false;
        }
        if (x2.length > 0 && typeof x2[0] !== "number") {
          return false;
        }
        return true;
      }
      function objEquiv(a, b, opts) {
        var i, key;
        if (typeof a !== typeof b) {
          return false;
        }
        if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
          return false;
        }
        if (a.prototype !== b.prototype) {
          return false;
        }
        if (isArguments(a) !== isArguments(b)) {
          return false;
        }
        var aIsRegex = isRegex(a);
        var bIsRegex = isRegex(b);
        if (aIsRegex !== bIsRegex) {
          return false;
        }
        if (aIsRegex || bIsRegex) {
          return a.source === b.source && flags(a) === flags(b);
        }
        if (isDate(a) && isDate(b)) {
          return getTime.call(a) === getTime.call(b);
        }
        var aIsBuffer = isBuffer(a);
        var bIsBuffer = isBuffer(b);
        if (aIsBuffer !== bIsBuffer) {
          return false;
        }
        if (aIsBuffer || bIsBuffer) {
          if (a.length !== b.length) {
            return false;
          }
          for (i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
              return false;
            }
          }
          return true;
        }
        if (typeof a !== typeof b) {
          return false;
        }
        try {
          var ka = objectKeys(a);
          var kb = objectKeys(b);
        } catch (e) {
          return false;
        }
        if (ka.length !== kb.length) {
          return false;
        }
        ka.sort();
        kb.sort();
        for (i = ka.length - 1; i >= 0; i--) {
          if (ka[i] != kb[i]) {
            return false;
          }
        }
        for (i = ka.length - 1; i >= 0; i--) {
          key = ka[i];
          if (!deepEqual(a[key], b[key], opts)) {
            return false;
          }
        }
        return true;
      }
      module.exports = deepEqual;
    }
  });

  // ../../../../../../../node_modules/geojson-equality/index.js
  var require_geojson_equality = __commonJS({
    "../../../../../../../node_modules/geojson-equality/index.js"(exports, module) {
      var deepEqual = require_deep_equal();
      var Equality = function(opt) {
        this.precision = opt && opt.precision ? opt.precision : 17;
        this.direction = opt && opt.direction ? opt.direction : false;
        this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
        this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
      };
      Equality.prototype.compare = function(g1, g2) {
        if (g1.type !== g2.type || !sameLength(g1, g2))
          return false;
        switch (g1.type) {
          case "Point":
            return this.compareCoord(g1.coordinates, g2.coordinates);
            break;
          case "LineString":
            return this.compareLine(g1.coordinates, g2.coordinates, 0, false);
            break;
          case "Polygon":
            return this.comparePolygon(g1, g2);
            break;
          case "Feature":
            return this.compareFeature(g1, g2);
          default:
            if (g1.type.indexOf("Multi") === 0) {
              var context = this;
              var g1s = explode(g1);
              var g2s = explode(g2);
              return g1s.every(function(g1part) {
                return this.some(function(g2part) {
                  return context.compare(g1part, g2part);
                });
              }, g2s);
            }
        }
        return false;
      };
      function explode(g) {
        return g.coordinates.map(function(part) {
          return {
            type: g.type.replace("Multi", ""),
            coordinates: part
          };
        });
      }
      function sameLength(g1, g2) {
        return g1.hasOwnProperty("coordinates") ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
      }
      Equality.prototype.compareCoord = function(c1, c2) {
        if (c1.length !== c2.length) {
          return false;
        }
        for (var i = 0; i < c1.length; i++) {
          if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
            return false;
          }
        }
        return true;
      };
      Equality.prototype.compareLine = function(path1, path2, ind, isPoly) {
        if (!sameLength(path1, path2))
          return false;
        var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
        var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
        if (isPoly && !this.compareCoord(p1[0], p2[0])) {
          p2 = this.fixStartIndex(p2, p1);
          if (!p2)
            return;
        }
        var sameDirection = this.compareCoord(p1[ind], p2[ind]);
        if (this.direction || sameDirection) {
          return this.comparePath(p1, p2);
        } else {
          if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
            return this.comparePath(p1.slice().reverse(), p2);
          }
          return false;
        }
      };
      Equality.prototype.fixStartIndex = function(sourcePath, targetPath) {
        var correctPath, ind = -1;
        for (var i = 0; i < sourcePath.length; i++) {
          if (this.compareCoord(sourcePath[i], targetPath[0])) {
            ind = i;
            break;
          }
        }
        if (ind >= 0) {
          correctPath = [].concat(
            sourcePath.slice(ind, sourcePath.length),
            sourcePath.slice(1, ind + 1)
          );
        }
        return correctPath;
      };
      Equality.prototype.comparePath = function(p1, p2) {
        var cont = this;
        return p1.every(function(c, i) {
          return cont.compareCoord(c, this[i]);
        }, p2);
      };
      Equality.prototype.comparePolygon = function(g1, g2) {
        if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
          var holes1 = g1.coordinates.slice(1, g1.coordinates.length);
          var holes2 = g2.coordinates.slice(1, g2.coordinates.length);
          var cont = this;
          return holes1.every(function(h1) {
            return this.some(function(h2) {
              return cont.compareLine(h1, h2, 1, true);
            });
          }, holes2);
        } else {
          return false;
        }
      };
      Equality.prototype.compareFeature = function(g1, g2) {
        if (g1.id !== g2.id || !this.objectComparator(g1.properties, g2.properties) || !this.compareBBox(g1, g2)) {
          return false;
        }
        return this.compare(g1.geometry, g2.geometry);
      };
      Equality.prototype.compareBBox = function(g1, g2) {
        if (!g1.bbox && !g2.bbox || g1.bbox && g2.bbox && this.compareCoord(g1.bbox, g2.bbox)) {
          return true;
        }
        return false;
      };
      Equality.prototype.removePseudo = function(path) {
        return path;
      };
      function objectComparator(obj1, obj2) {
        return deepEqual(obj1, obj2, { strict: true });
      }
      module.exports = Equality;
    }
  });

  // ../../../../../../../node_modules/density-clustering/lib/DBSCAN.js
  var require_DBSCAN = __commonJS({
    "../../../../../../../node_modules/density-clustering/lib/DBSCAN.js"(exports, module) {
      function DBSCAN(dataset, epsilon4, minPts, distanceFunction) {
        this.dataset = [];
        this.epsilon = 1;
        this.minPts = 2;
        this.distance = this._euclideanDistance;
        this.clusters = [];
        this.noise = [];
        this._visited = [];
        this._assigned = [];
        this._datasetLength = 0;
        this._init(dataset, epsilon4, minPts, distanceFunction);
      }
      DBSCAN.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
        this._init(dataset, epsilon4, minPts, distanceFunction);
        for (var pointId = 0; pointId < this._datasetLength; pointId++) {
          if (this._visited[pointId] !== 1) {
            this._visited[pointId] = 1;
            var neighbors = this._regionQuery(pointId);
            if (neighbors.length < this.minPts) {
              this.noise.push(pointId);
            } else {
              var clusterId = this.clusters.length;
              this.clusters.push([]);
              this._addToCluster(pointId, clusterId);
              this._expandCluster(clusterId, neighbors);
            }
          }
        }
        return this.clusters;
      };
      DBSCAN.prototype._init = function(dataset, epsilon4, minPts, distance2) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this.noise = [];
          this._datasetLength = dataset.length;
          this._visited = new Array(this._datasetLength);
          this._assigned = new Array(this._datasetLength);
        }
        if (epsilon4) {
          this.epsilon = epsilon4;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance2) {
          this.distance = distance2;
        }
      };
      DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {
        for (var i = 0; i < neighbors.length; i++) {
          var pointId2 = neighbors[i];
          if (this._visited[pointId2] !== 1) {
            this._visited[pointId2] = 1;
            var neighbors2 = this._regionQuery(pointId2);
            if (neighbors2.length >= this.minPts) {
              neighbors = this._mergeArrays(neighbors, neighbors2);
            }
          }
          if (this._assigned[pointId2] !== 1) {
            this._addToCluster(pointId2, clusterId);
          }
        }
      };
      DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
        this.clusters[clusterId].push(pointId);
        this._assigned[pointId] = 1;
      };
      DBSCAN.prototype._regionQuery = function(pointId) {
        var neighbors = [];
        for (var id = 0; id < this._datasetLength; id++) {
          var dist = this.distance(this.dataset[pointId], this.dataset[id]);
          if (dist < this.epsilon) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      DBSCAN.prototype._mergeArrays = function(a, b) {
        var len = b.length;
        for (var i = 0; i < len; i++) {
          var P = b[i];
          if (a.indexOf(P) < 0) {
            a.push(P);
          }
        }
        return a;
      };
      DBSCAN.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = DBSCAN;
      }
    }
  });

  // ../../../../../../../node_modules/density-clustering/lib/KMEANS.js
  var require_KMEANS = __commonJS({
    "../../../../../../../node_modules/density-clustering/lib/KMEANS.js"(exports, module) {
      function KMEANS(dataset, k, distance2) {
        this.k = 3;
        this.dataset = [];
        this.assignments = [];
        this.centroids = [];
        this.init(dataset, k, distance2);
      }
      KMEANS.prototype.init = function(dataset, k, distance2) {
        this.assignments = [];
        this.centroids = [];
        if (typeof dataset !== "undefined") {
          this.dataset = dataset;
        }
        if (typeof k !== "undefined") {
          this.k = k;
        }
        if (typeof distance2 !== "undefined") {
          this.distance = distance2;
        }
      };
      KMEANS.prototype.run = function(dataset, k) {
        this.init(dataset, k);
        var len = this.dataset.length;
        for (var i = 0; i < this.k; i++) {
          this.centroids[i] = this.randomCentroid();
        }
        var change = true;
        while (change) {
          change = this.assign();
          for (var centroidId = 0; centroidId < this.k; centroidId++) {
            var mean = new Array(maxDim);
            var count = 0;
            for (var dim = 0; dim < maxDim; dim++) {
              mean[dim] = 0;
            }
            for (var j = 0; j < len; j++) {
              var maxDim = this.dataset[j].length;
              if (centroidId === this.assignments[j]) {
                for (var dim = 0; dim < maxDim; dim++) {
                  mean[dim] += this.dataset[j][dim];
                }
                count++;
              }
            }
            if (count > 0) {
              for (var dim = 0; dim < maxDim; dim++) {
                mean[dim] /= count;
              }
              this.centroids[centroidId] = mean;
            } else {
              this.centroids[centroidId] = this.randomCentroid();
              change = true;
            }
          }
        }
        return this.getClusters();
      };
      KMEANS.prototype.randomCentroid = function() {
        var maxId = this.dataset.length - 1;
        var centroid;
        var id;
        do {
          id = Math.round(Math.random() * maxId);
          centroid = this.dataset[id];
        } while (this.centroids.indexOf(centroid) >= 0);
        return centroid;
      };
      KMEANS.prototype.assign = function() {
        var change = false;
        var len = this.dataset.length;
        var closestCentroid;
        for (var i = 0; i < len; i++) {
          closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);
          if (closestCentroid != this.assignments[i]) {
            this.assignments[i] = closestCentroid;
            change = true;
          }
        }
        return change;
      };
      KMEANS.prototype.getClusters = function() {
        var clusters = new Array(this.k);
        var centroidId;
        for (var pointId = 0; pointId < this.assignments.length; pointId++) {
          centroidId = this.assignments[pointId];
          if (typeof clusters[centroidId] === "undefined") {
            clusters[centroidId] = [];
          }
          clusters[centroidId].push(pointId);
        }
        return clusters;
      };
      KMEANS.prototype.argmin = function(point2, set, f) {
        var min = Number.MAX_VALUE;
        var arg = 0;
        var len = set.length;
        var d;
        for (var i = 0; i < len; i++) {
          d = f(point2, set[i]);
          if (d < min) {
            min = d;
            arg = i;
          }
        }
        return arg;
      };
      KMEANS.prototype.distance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          var diff = p[i] - q[i];
          sum2 += diff * diff;
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = KMEANS;
      }
    }
  });

  // ../../../../../../../node_modules/density-clustering/lib/PriorityQueue.js
  var require_PriorityQueue = __commonJS({
    "../../../../../../../node_modules/density-clustering/lib/PriorityQueue.js"(exports, module) {
      function PriorityQueue(elements, priorities, sorting) {
        this._queue = [];
        this._priorities = [];
        this._sorting = "desc";
        this._init(elements, priorities, sorting);
      }
      PriorityQueue.prototype.insert = function(ele, priority) {
        var indexToInsert = this._queue.length;
        var index = indexToInsert;
        while (index--) {
          var priority2 = this._priorities[index];
          if (this._sorting === "desc") {
            if (priority > priority2) {
              indexToInsert = index;
            }
          } else {
            if (priority < priority2) {
              indexToInsert = index;
            }
          }
        }
        this._insertAt(ele, priority, indexToInsert);
      };
      PriorityQueue.prototype.remove = function(ele) {
        var index = this._queue.length;
        while (index--) {
          var ele2 = this._queue[index];
          if (ele === ele2) {
            this._queue.splice(index, 1);
            this._priorities.splice(index, 1);
            break;
          }
        }
      };
      PriorityQueue.prototype.forEach = function(func) {
        this._queue.forEach(func);
      };
      PriorityQueue.prototype.getElements = function() {
        return this._queue;
      };
      PriorityQueue.prototype.getElementPriority = function(index) {
        return this._priorities[index];
      };
      PriorityQueue.prototype.getPriorities = function() {
        return this._priorities;
      };
      PriorityQueue.prototype.getElementsWithPriorities = function() {
        var result = [];
        for (var i = 0, l = this._queue.length; i < l; i++) {
          result.push([this._queue[i], this._priorities[i]]);
        }
        return result;
      };
      PriorityQueue.prototype._init = function(elements, priorities, sorting) {
        if (elements && priorities) {
          this._queue = [];
          this._priorities = [];
          if (elements.length !== priorities.length) {
            throw new Error("Arrays must have the same length");
          }
          for (var i = 0; i < elements.length; i++) {
            this.insert(elements[i], priorities[i]);
          }
        }
        if (sorting) {
          this._sorting = sorting;
        }
      };
      PriorityQueue.prototype._insertAt = function(ele, priority, index) {
        if (this._queue.length === index) {
          this._queue.push(ele);
          this._priorities.push(priority);
        } else {
          this._queue.splice(index, 0, ele);
          this._priorities.splice(index, 0, priority);
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = PriorityQueue;
      }
    }
  });

  // ../../../../../../../node_modules/density-clustering/lib/OPTICS.js
  var require_OPTICS = __commonJS({
    "../../../../../../../node_modules/density-clustering/lib/OPTICS.js"(exports, module) {
      if (typeof module !== "undefined" && module.exports) {
        PriorityQueue = require_PriorityQueue();
      }
      var PriorityQueue;
      function OPTICS(dataset, epsilon4, minPts, distanceFunction) {
        this.epsilon = 1;
        this.minPts = 1;
        this.distance = this._euclideanDistance;
        this._reachability = [];
        this._processed = [];
        this._coreDistance = 0;
        this._orderedList = [];
        this._init(dataset, epsilon4, minPts, distanceFunction);
      }
      OPTICS.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
        this._init(dataset, epsilon4, minPts, distanceFunction);
        for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
          if (this._processed[pointId] !== 1) {
            this._processed[pointId] = 1;
            this.clusters.push([pointId]);
            var clusterId = this.clusters.length - 1;
            this._orderedList.push(pointId);
            var priorityQueue = new PriorityQueue(null, null, "asc");
            var neighbors = this._regionQuery(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, priorityQueue);
              this._expandCluster(clusterId, priorityQueue);
            }
          }
        }
        return this.clusters;
      };
      OPTICS.prototype.getReachabilityPlot = function() {
        var reachabilityPlot = [];
        for (var i = 0, l = this._orderedList.length; i < l; i++) {
          var pointId = this._orderedList[i];
          var distance2 = this._reachability[pointId];
          reachabilityPlot.push([pointId, distance2]);
        }
        return reachabilityPlot;
      };
      OPTICS.prototype._init = function(dataset, epsilon4, minPts, distance2) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this._reachability = new Array(this.dataset.length);
          this._processed = new Array(this.dataset.length);
          this._coreDistance = 0;
          this._orderedList = [];
        }
        if (epsilon4) {
          this.epsilon = epsilon4;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance2) {
          this.distance = distance2;
        }
      };
      OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
        var self2 = this;
        this._coreDistance = this._distanceToCore(pointId);
        neighbors.forEach(function(pointId2) {
          if (self2._processed[pointId2] === void 0) {
            var dist = self2.distance(self2.dataset[pointId], self2.dataset[pointId2]);
            var newReachableDistance = Math.max(self2._coreDistance, dist);
            if (self2._reachability[pointId2] === void 0) {
              self2._reachability[pointId2] = newReachableDistance;
              queue.insert(pointId2, newReachableDistance);
            } else {
              if (newReachableDistance < self2._reachability[pointId2]) {
                self2._reachability[pointId2] = newReachableDistance;
                queue.remove(pointId2);
                queue.insert(pointId2, newReachableDistance);
              }
            }
          }
        });
      };
      OPTICS.prototype._expandCluster = function(clusterId, queue) {
        var queueElements = queue.getElements();
        for (var p = 0, l = queueElements.length; p < l; p++) {
          var pointId = queueElements[p];
          if (this._processed[pointId] === void 0) {
            var neighbors = this._regionQuery(pointId);
            this._processed[pointId] = 1;
            this.clusters[clusterId].push(pointId);
            this._orderedList.push(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, queue);
              this._expandCluster(clusterId, queue);
            }
          }
        }
      };
      OPTICS.prototype._distanceToCore = function(pointId) {
        var l = this.epsilon;
        for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
          var neighbors = this._regionQuery(pointId, coreDistCand);
          if (neighbors.length >= this.minPts) {
            return coreDistCand;
          }
        }
        return;
      };
      OPTICS.prototype._regionQuery = function(pointId, epsilon4) {
        epsilon4 = epsilon4 || this.epsilon;
        var neighbors = [];
        for (var id = 0, l = this.dataset.length; id < l; id++) {
          if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon4) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      OPTICS.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = OPTICS;
      }
    }
  });

  // ../../../../../../../node_modules/density-clustering/lib/index.js
  var require_lib = __commonJS({
    "../../../../../../../node_modules/density-clustering/lib/index.js"(exports, module) {
      if (typeof module !== "undefined" && module.exports) {
        module.exports = {
          DBSCAN: require_DBSCAN(),
          KMEANS: require_KMEANS(),
          OPTICS: require_OPTICS(),
          PriorityQueue: require_PriorityQueue()
        };
      }
    }
  });

  // ../../../../../../../node_modules/skmeans/dist/node/distance.js
  var require_distance = __commonJS({
    "../../../../../../../node_modules/skmeans/dist/node/distance.js"(exports, module) {
      "use strict";
      module.exports = {
        /**
         * Euclidean distance
         */
        eudist: function eudist(v1, v2, sqrt2) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            var d = (v1[i] || 0) - (v2[i] || 0);
            sum2 += d * d;
          }
          return sqrt2 ? Math.sqrt(sum2) : sum2;
        },
        mandist: function mandist(v1, v2, sqrt2) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            sum2 += Math.abs((v1[i] || 0) - (v2[i] || 0));
          }
          return sqrt2 ? Math.sqrt(sum2) : sum2;
        },
        /**
         * Unidimensional distance
         */
        dist: function dist(v1, v2, sqrt2) {
          var d = Math.abs(v1 - v2);
          return sqrt2 ? d : d * d;
        }
      };
    }
  });

  // ../../../../../../../node_modules/skmeans/dist/node/kinit.js
  var require_kinit = __commonJS({
    "../../../../../../../node_modules/skmeans/dist/node/kinit.js"(exports, module) {
      "use strict";
      var Distance = require_distance();
      var eudist = Distance.eudist;
      var dist = Distance.dist;
      module.exports = {
        kmrand: function kmrand(data, k) {
          var map3 = {}, ks = [], t = k << 2;
          var len = data.length;
          var multi = data[0].length > 0;
          while (ks.length < k && t-- > 0) {
            var d = data[Math.floor(Math.random() * len)];
            var key = multi ? d.join("_") : "" + d;
            if (!map3[key]) {
              map3[key] = true;
              ks.push(d);
            }
          }
          if (ks.length < k)
            throw new Error("Error initializating clusters");
          else
            return ks;
        },
        /**
         * K-means++ initial centroid selection
         */
        kmpp: function kmpp(data, k) {
          var distance2 = data[0].length ? eudist : dist;
          var ks = [], len = data.length;
          var multi = data[0].length > 0;
          var map3 = {};
          var c = data[Math.floor(Math.random() * len)];
          var key = multi ? c.join("_") : "" + c;
          ks.push(c);
          map3[key] = true;
          while (ks.length < k) {
            var dists = [], lk = ks.length;
            var dsum = 0, prs = [];
            for (var i = 0; i < len; i++) {
              var min = Infinity;
              for (var j = 0; j < lk; j++) {
                var _dist = distance2(data[i], ks[j]);
                if (_dist <= min)
                  min = _dist;
              }
              dists[i] = min;
            }
            for (var _i = 0; _i < len; _i++) {
              dsum += dists[_i];
            }
            for (var _i2 = 0; _i2 < len; _i2++) {
              prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
            }
            prs.sort(function(a, b) {
              return a.pr - b.pr;
            });
            prs[0].cs = prs[0].pr;
            for (var _i3 = 1; _i3 < len; _i3++) {
              prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
            }
            var rnd = Math.random();
            var idx = 0;
            while (idx < len - 1 && prs[idx++].cs < rnd) {
            }
            ks.push(prs[idx - 1].v);
          }
          return ks;
        }
      };
    }
  });

  // ../../../../../../../node_modules/skmeans/dist/node/main.js
  var require_main = __commonJS({
    "../../../../../../../node_modules/skmeans/dist/node/main.js"(exports, module) {
      "use strict";
      var Distance = require_distance();
      var ClusterInit = require_kinit();
      var eudist = Distance.eudist;
      var mandist = Distance.mandist;
      var dist = Distance.dist;
      var kmrand = ClusterInit.kmrand;
      var kmpp = ClusterInit.kmpp;
      var MAX = 1e4;
      function init(len, val, v) {
        v = v || [];
        for (var i = 0; i < len; i++) {
          v[i] = val;
        }
        return v;
      }
      function skmeans2(data, k, initial, maxit) {
        var ks = [], old = [], idxs = [], dist2 = [];
        var conv = false, it = maxit || MAX;
        var len = data.length, vlen = data[0].length, multi = vlen > 0;
        var count = [];
        if (!initial) {
          var _idxs = {};
          while (ks.length < k) {
            var idx = Math.floor(Math.random() * len);
            if (!_idxs[idx]) {
              _idxs[idx] = true;
              ks.push(data[idx]);
            }
          }
        } else if (initial == "kmrand") {
          ks = kmrand(data, k);
        } else if (initial == "kmpp") {
          ks = kmpp(data, k);
        } else {
          ks = initial;
        }
        do {
          init(k, 0, count);
          for (var i = 0; i < len; i++) {
            var min = Infinity, _idx = 0;
            for (var j = 0; j < k; j++) {
              var dist2 = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
              if (dist2 <= min) {
                min = dist2;
                _idx = j;
              }
            }
            idxs[i] = _idx;
            count[_idx]++;
          }
          var sum2 = [], old = [], dif = 0;
          for (var _j = 0; _j < k; _j++) {
            sum2[_j] = multi ? init(vlen, 0, sum2[_j]) : 0;
            old[_j] = ks[_j];
          }
          if (multi) {
            for (var _j2 = 0; _j2 < k; _j2++) {
              ks[_j2] = [];
            }
            for (var _i = 0; _i < len; _i++) {
              var _idx2 = idxs[_i], vsum = sum2[_idx2], vect = data[_i];
              for (var h = 0; h < vlen; h++) {
                vsum[h] += vect[h];
              }
            }
            conv = true;
            for (var _j3 = 0; _j3 < k; _j3++) {
              var ksj = ks[_j3], sumj = sum2[_j3], oldj = old[_j3], cj = count[_j3];
              for (var _h = 0; _h < vlen; _h++) {
                ksj[_h] = sumj[_h] / cj || 0;
              }
              if (conv) {
                for (var _h2 = 0; _h2 < vlen; _h2++) {
                  if (oldj[_h2] != ksj[_h2]) {
                    conv = false;
                    break;
                  }
                }
              }
            }
          } else {
            for (var _i2 = 0; _i2 < len; _i2++) {
              var _idx3 = idxs[_i2];
              sum2[_idx3] += data[_i2];
            }
            for (var _j4 = 0; _j4 < k; _j4++) {
              ks[_j4] = sum2[_j4] / count[_j4] || 0;
            }
            conv = true;
            for (var _j5 = 0; _j5 < k; _j5++) {
              if (old[_j5] != ks[_j5]) {
                conv = false;
                break;
              }
            }
          }
          conv = conv || --it <= 0;
        } while (!conv);
        return {
          it: MAX - it,
          k,
          idxs,
          centroids: ks
        };
      }
      module.exports = skmeans2;
    }
  });

  // ../../../../../../../node_modules/polygon-clipping/dist/polygon-clipping.umd.js
  var require_polygon_clipping_umd = __commonJS({
    "../../../../../../../node_modules/polygon-clipping/dist/polygon-clipping.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.polygonClipping = factory());
      })(exports, function() {
        "use strict";
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        var Node2 = (
          /** @class */
          function() {
            function Node3(key, data) {
              this.next = null;
              this.key = key;
              this.data = data;
              this.left = null;
              this.right = null;
            }
            return Node3;
          }()
        );
        function DEFAULT_COMPARE(a, b) {
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function splay(i, t, comparator) {
          var N = new Node2(null, null);
          var l = N;
          var r = N;
          while (true) {
            var cmp2 = comparator(i, t.key);
            if (cmp2 < 0) {
              if (t.left === null)
                break;
              if (comparator(i, t.left.key) < 0) {
                var y2 = t.left;
                t.left = y2.right;
                y2.right = t;
                t = y2;
                if (t.left === null)
                  break;
              }
              r.left = t;
              r = t;
              t = t.left;
            } else if (cmp2 > 0) {
              if (t.right === null)
                break;
              if (comparator(i, t.right.key) > 0) {
                var y2 = t.right;
                t.right = y2.left;
                y2.left = t;
                t = y2;
                if (t.right === null)
                  break;
              }
              l.right = t;
              l = t;
              t = t.right;
            } else
              break;
          }
          l.right = t.left;
          r.left = t.right;
          t.left = N.right;
          t.right = N.left;
          return t;
        }
        function insert(i, data, t, comparator) {
          var node = new Node2(i, data);
          if (t === null) {
            node.left = node.right = null;
            return node;
          }
          t = splay(i, t, comparator);
          var cmp2 = comparator(i, t.key);
          if (cmp2 < 0) {
            node.left = t.left;
            node.right = t;
            t.left = null;
          } else if (cmp2 >= 0) {
            node.right = t.right;
            node.left = t;
            t.right = null;
          }
          return node;
        }
        function split(key, v, comparator) {
          var left = null;
          var right = null;
          if (v) {
            v = splay(key, v, comparator);
            var cmp2 = comparator(v.key, key);
            if (cmp2 === 0) {
              left = v.left;
              right = v.right;
            } else if (cmp2 < 0) {
              right = v.right;
              v.right = null;
              left = v;
            } else {
              left = v.left;
              v.left = null;
              right = v;
            }
          }
          return {
            left,
            right
          };
        }
        function merge(left, right, comparator) {
          if (right === null)
            return left;
          if (left === null)
            return right;
          right = splay(left.key, right, comparator);
          right.left = left;
          return right;
        }
        function printRow(root, prefix, isTail, out, printNode) {
          if (root) {
            out("" + prefix + (isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + printNode(root) + "\n");
            var indent = prefix + (isTail ? "    " : "\u2502   ");
            if (root.left)
              printRow(root.left, indent, false, out, printNode);
            if (root.right)
              printRow(root.right, indent, true, out, printNode);
          }
        }
        var Tree = (
          /** @class */
          function() {
            function Tree2(comparator) {
              if (comparator === void 0) {
                comparator = DEFAULT_COMPARE;
              }
              this._root = null;
              this._size = 0;
              this._comparator = comparator;
            }
            Tree2.prototype.insert = function(key, data) {
              this._size++;
              return this._root = insert(key, data, this._root, this._comparator);
            };
            Tree2.prototype.add = function(key, data) {
              var node = new Node2(key, data);
              if (this._root === null) {
                node.left = node.right = null;
                this._size++;
                this._root = node;
              }
              var comparator = this._comparator;
              var t = splay(key, this._root, comparator);
              var cmp2 = comparator(key, t.key);
              if (cmp2 === 0)
                this._root = t;
              else {
                if (cmp2 < 0) {
                  node.left = t.left;
                  node.right = t;
                  t.left = null;
                } else if (cmp2 > 0) {
                  node.right = t.right;
                  node.left = t;
                  t.right = null;
                }
                this._size++;
                this._root = node;
              }
              return this._root;
            };
            Tree2.prototype.remove = function(key) {
              this._root = this._remove(key, this._root, this._comparator);
            };
            Tree2.prototype._remove = function(i, t, comparator) {
              var x2;
              if (t === null)
                return null;
              t = splay(i, t, comparator);
              var cmp2 = comparator(i, t.key);
              if (cmp2 === 0) {
                if (t.left === null) {
                  x2 = t.right;
                } else {
                  x2 = splay(i, t.left, comparator);
                  x2.right = t.right;
                }
                this._size--;
                return x2;
              }
              return t;
            };
            Tree2.prototype.pop = function() {
              var node = this._root;
              if (node) {
                while (node.left) {
                  node = node.left;
                }
                this._root = splay(node.key, this._root, this._comparator);
                this._root = this._remove(node.key, this._root, this._comparator);
                return {
                  key: node.key,
                  data: node.data
                };
              }
              return null;
            };
            Tree2.prototype.findStatic = function(key) {
              var current = this._root;
              var compare = this._comparator;
              while (current) {
                var cmp2 = compare(key, current.key);
                if (cmp2 === 0)
                  return current;
                else if (cmp2 < 0)
                  current = current.left;
                else
                  current = current.right;
              }
              return null;
            };
            Tree2.prototype.find = function(key) {
              if (this._root) {
                this._root = splay(key, this._root, this._comparator);
                if (this._comparator(key, this._root.key) !== 0)
                  return null;
              }
              return this._root;
            };
            Tree2.prototype.contains = function(key) {
              var current = this._root;
              var compare = this._comparator;
              while (current) {
                var cmp2 = compare(key, current.key);
                if (cmp2 === 0)
                  return true;
                else if (cmp2 < 0)
                  current = current.left;
                else
                  current = current.right;
              }
              return false;
            };
            Tree2.prototype.forEach = function(visitor, ctx) {
              var current = this._root;
              var Q = [];
              var done = false;
              while (!done) {
                if (current !== null) {
                  Q.push(current);
                  current = current.left;
                } else {
                  if (Q.length !== 0) {
                    current = Q.pop();
                    visitor.call(ctx, current);
                    current = current.right;
                  } else
                    done = true;
                }
              }
              return this;
            };
            Tree2.prototype.range = function(low, high, fn, ctx) {
              var Q = [];
              var compare = this._comparator;
              var node = this._root;
              var cmp2;
              while (Q.length !== 0 || node) {
                if (node) {
                  Q.push(node);
                  node = node.left;
                } else {
                  node = Q.pop();
                  cmp2 = compare(node.key, high);
                  if (cmp2 > 0) {
                    break;
                  } else if (compare(node.key, low) >= 0) {
                    if (fn.call(ctx, node))
                      return this;
                  }
                  node = node.right;
                }
              }
              return this;
            };
            Tree2.prototype.keys = function() {
              var keys = [];
              this.forEach(function(_a) {
                var key = _a.key;
                return keys.push(key);
              });
              return keys;
            };
            Tree2.prototype.values = function() {
              var values = [];
              this.forEach(function(_a) {
                var data = _a.data;
                return values.push(data);
              });
              return values;
            };
            Tree2.prototype.min = function() {
              if (this._root)
                return this.minNode(this._root).key;
              return null;
            };
            Tree2.prototype.max = function() {
              if (this._root)
                return this.maxNode(this._root).key;
              return null;
            };
            Tree2.prototype.minNode = function(t) {
              if (t === void 0) {
                t = this._root;
              }
              if (t)
                while (t.left) {
                  t = t.left;
                }
              return t;
            };
            Tree2.prototype.maxNode = function(t) {
              if (t === void 0) {
                t = this._root;
              }
              if (t)
                while (t.right) {
                  t = t.right;
                }
              return t;
            };
            Tree2.prototype.at = function(index2) {
              var current = this._root;
              var done = false;
              var i = 0;
              var Q = [];
              while (!done) {
                if (current) {
                  Q.push(current);
                  current = current.left;
                } else {
                  if (Q.length > 0) {
                    current = Q.pop();
                    if (i === index2)
                      return current;
                    i++;
                    current = current.right;
                  } else
                    done = true;
                }
              }
              return null;
            };
            Tree2.prototype.next = function(d) {
              var root = this._root;
              var successor = null;
              if (d.right) {
                successor = d.right;
                while (successor.left) {
                  successor = successor.left;
                }
                return successor;
              }
              var comparator = this._comparator;
              while (root) {
                var cmp2 = comparator(d.key, root.key);
                if (cmp2 === 0)
                  break;
                else if (cmp2 < 0) {
                  successor = root;
                  root = root.left;
                } else
                  root = root.right;
              }
              return successor;
            };
            Tree2.prototype.prev = function(d) {
              var root = this._root;
              var predecessor = null;
              if (d.left !== null) {
                predecessor = d.left;
                while (predecessor.right) {
                  predecessor = predecessor.right;
                }
                return predecessor;
              }
              var comparator = this._comparator;
              while (root) {
                var cmp2 = comparator(d.key, root.key);
                if (cmp2 === 0)
                  break;
                else if (cmp2 < 0)
                  root = root.left;
                else {
                  predecessor = root;
                  root = root.right;
                }
              }
              return predecessor;
            };
            Tree2.prototype.clear = function() {
              this._root = null;
              this._size = 0;
              return this;
            };
            Tree2.prototype.toList = function() {
              return toList(this._root);
            };
            Tree2.prototype.load = function(keys, values, presort) {
              if (values === void 0) {
                values = [];
              }
              if (presort === void 0) {
                presort = false;
              }
              var size = keys.length;
              var comparator = this._comparator;
              if (presort)
                sort(keys, values, 0, size - 1, comparator);
              if (this._root === null) {
                this._root = loadRecursive(keys, values, 0, size);
                this._size = size;
              } else {
                var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
                size = this._size + size;
                this._root = sortedListToBST({
                  head: mergedList
                }, 0, size);
              }
              return this;
            };
            Tree2.prototype.isEmpty = function() {
              return this._root === null;
            };
            Object.defineProperty(Tree2.prototype, "size", {
              get: function get() {
                return this._size;
              },
              enumerable: true,
              configurable: true
            });
            Object.defineProperty(Tree2.prototype, "root", {
              get: function get() {
                return this._root;
              },
              enumerable: true,
              configurable: true
            });
            Tree2.prototype.toString = function(printNode) {
              if (printNode === void 0) {
                printNode = function printNode2(n) {
                  return String(n.key);
                };
              }
              var out = [];
              printRow(this._root, "", true, function(v) {
                return out.push(v);
              }, printNode);
              return out.join("");
            };
            Tree2.prototype.update = function(key, newKey, newData) {
              var comparator = this._comparator;
              var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
              if (comparator(key, newKey) < 0) {
                right = insert(newKey, newData, right, comparator);
              } else {
                left = insert(newKey, newData, left, comparator);
              }
              this._root = merge(left, right, comparator);
            };
            Tree2.prototype.split = function(key) {
              return split(key, this._root, this._comparator);
            };
            return Tree2;
          }()
        );
        function loadRecursive(keys, values, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var key = keys[middle];
            var data = values[middle];
            var node = new Node2(key, data);
            node.left = loadRecursive(keys, values, start, middle);
            node.right = loadRecursive(keys, values, middle + 1, end);
            return node;
          }
          return null;
        }
        function createList(keys, values) {
          var head = new Node2(null, null);
          var p = head;
          for (var i = 0; i < keys.length; i++) {
            p = p.next = new Node2(keys[i], values[i]);
          }
          p.next = null;
          return head.next;
        }
        function toList(root) {
          var current = root;
          var Q = [];
          var done = false;
          var head = new Node2(null, null);
          var p = head;
          while (!done) {
            if (current) {
              Q.push(current);
              current = current.left;
            } else {
              if (Q.length > 0) {
                current = p = p.next = Q.pop();
                current = current.right;
              } else
                done = true;
            }
          }
          p.next = null;
          return head.next;
        }
        function sortedListToBST(list, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var left = sortedListToBST(list, start, middle);
            var root = list.head;
            root.left = left;
            list.head = list.head.next;
            root.right = sortedListToBST(list, middle + 1, end);
            return root;
          }
          return null;
        }
        function mergeLists(l1, l2, compare) {
          var head = new Node2(null, null);
          var p = head;
          var p1 = l1;
          var p2 = l2;
          while (p1 !== null && p2 !== null) {
            if (compare(p1.key, p2.key) < 0) {
              p.next = p1;
              p1 = p1.next;
            } else {
              p.next = p2;
              p2 = p2.next;
            }
            p = p.next;
          }
          if (p1 !== null) {
            p.next = p1;
          } else if (p2 !== null) {
            p.next = p2;
          }
          return head.next;
        }
        function sort(keys, values, left, right, compare) {
          if (left >= right)
            return;
          var pivot = keys[left + right >> 1];
          var i = left - 1;
          var j = right + 1;
          while (true) {
            do {
              i++;
            } while (compare(keys[i], pivot) < 0);
            do {
              j--;
            } while (compare(keys[j], pivot) > 0);
            if (i >= j)
              break;
            var tmp = keys[i];
            keys[i] = keys[j];
            keys[j] = tmp;
            tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
          }
          sort(keys, values, left, j, compare);
          sort(keys, values, j + 1, right, compare);
        }
        var isInBbox = function isInBbox2(bbox3, point2) {
          return bbox3.ll.x <= point2.x && point2.x <= bbox3.ur.x && bbox3.ll.y <= point2.y && point2.y <= bbox3.ur.y;
        };
        var getBboxOverlap = function getBboxOverlap2(b1, b2) {
          if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
            return null;
          var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
          var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
          var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
          var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
          return {
            ll: {
              x: lowerX,
              y: lowerY
            },
            ur: {
              x: upperX,
              y: upperY
            }
          };
        };
        var epsilon4 = Number.EPSILON;
        if (epsilon4 === void 0)
          epsilon4 = Math.pow(2, -52);
        var EPSILON_SQ = epsilon4 * epsilon4;
        var cmp = function cmp2(a, b) {
          if (-epsilon4 < a && a < epsilon4) {
            if (-epsilon4 < b && b < epsilon4) {
              return 0;
            }
          }
          var ab = a - b;
          if (ab * ab < EPSILON_SQ * a * b) {
            return 0;
          }
          return a < b ? -1 : 1;
        };
        var PtRounder = /* @__PURE__ */ function() {
          function PtRounder2() {
            _classCallCheck(this, PtRounder2);
            this.reset();
          }
          _createClass(PtRounder2, [{
            key: "reset",
            value: function reset() {
              this.xRounder = new CoordRounder();
              this.yRounder = new CoordRounder();
            }
          }, {
            key: "round",
            value: function round2(x2, y2) {
              return {
                x: this.xRounder.round(x2),
                y: this.yRounder.round(y2)
              };
            }
          }]);
          return PtRounder2;
        }();
        var CoordRounder = /* @__PURE__ */ function() {
          function CoordRounder2() {
            _classCallCheck(this, CoordRounder2);
            this.tree = new Tree();
            this.round(0);
          }
          _createClass(CoordRounder2, [{
            key: "round",
            value: function round2(coord) {
              var node = this.tree.add(coord);
              var prevNode = this.tree.prev(node);
              if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
                this.tree.remove(coord);
                return prevNode.key;
              }
              var nextNode = this.tree.next(node);
              if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
                this.tree.remove(coord);
                return nextNode.key;
              }
              return coord;
            }
          }]);
          return CoordRounder2;
        }();
        var rounder = new PtRounder();
        var crossProduct = function crossProduct2(a, b) {
          return a.x * b.y - a.y * b.x;
        };
        var dotProduct = function dotProduct2(a, b) {
          return a.x * b.x + a.y * b.y;
        };
        var compareVectorAngles = function compareVectorAngles2(basePt, endPt1, endPt2) {
          var v1 = {
            x: endPt1.x - basePt.x,
            y: endPt1.y - basePt.y
          };
          var v2 = {
            x: endPt2.x - basePt.x,
            y: endPt2.y - basePt.y
          };
          var kross = crossProduct(v1, v2);
          return cmp(kross, 0);
        };
        var length2 = function length3(v) {
          return Math.sqrt(dotProduct(v, v));
        };
        var sineOfAngle = function sineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return crossProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var cosineOfAngle = function cosineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return dotProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var horizontalIntersection = function horizontalIntersection2(pt, v, y2) {
          if (v.y === 0)
            return null;
          return {
            x: pt.x + v.x / v.y * (y2 - pt.y),
            y: y2
          };
        };
        var verticalIntersection = function verticalIntersection2(pt, v, x2) {
          if (v.x === 0)
            return null;
          return {
            x: x2,
            y: pt.y + v.y / v.x * (x2 - pt.x)
          };
        };
        var intersection = function intersection2(pt1, v1, pt2, v2) {
          if (v1.x === 0)
            return verticalIntersection(pt2, v2, pt1.x);
          if (v2.x === 0)
            return verticalIntersection(pt1, v1, pt2.x);
          if (v1.y === 0)
            return horizontalIntersection(pt2, v2, pt1.y);
          if (v2.y === 0)
            return horizontalIntersection(pt1, v1, pt2.y);
          var kross = crossProduct(v1, v2);
          if (kross == 0)
            return null;
          var ve = {
            x: pt2.x - pt1.x,
            y: pt2.y - pt1.y
          };
          var d1 = crossProduct(ve, v1) / kross;
          var d2 = crossProduct(ve, v2) / kross;
          var x12 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
          var y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
          var x3 = (x12 + x2) / 2;
          var y3 = (y1 + y2) / 2;
          return {
            x: x3,
            y: y3
          };
        };
        var SweepEvent = /* @__PURE__ */ function() {
          _createClass(SweepEvent2, null, [{
            key: "compare",
            // for ordering sweep events in the sweep event queue
            value: function compare(a, b) {
              var ptCmp = SweepEvent2.comparePoints(a.point, b.point);
              if (ptCmp !== 0)
                return ptCmp;
              if (a.point !== b.point)
                a.link(b);
              if (a.isLeft !== b.isLeft)
                return a.isLeft ? 1 : -1;
              return Segment.compare(a.segment, b.segment);
            }
            // for ordering points in sweep line order
          }, {
            key: "comparePoints",
            value: function comparePoints(aPt, bPt) {
              if (aPt.x < bPt.x)
                return -1;
              if (aPt.x > bPt.x)
                return 1;
              if (aPt.y < bPt.y)
                return -1;
              if (aPt.y > bPt.y)
                return 1;
              return 0;
            }
            // Warning: 'point' input will be modified and re-used (for performance)
          }]);
          function SweepEvent2(point2, isLeft) {
            _classCallCheck(this, SweepEvent2);
            if (point2.events === void 0)
              point2.events = [this];
            else
              point2.events.push(this);
            this.point = point2;
            this.isLeft = isLeft;
          }
          _createClass(SweepEvent2, [{
            key: "link",
            value: function link2(other) {
              if (other.point === this.point) {
                throw new Error("Tried to link already linked events");
              }
              var otherEvents = other.point.events;
              for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
                var evt = otherEvents[i];
                this.point.events.push(evt);
                evt.point = this.point;
              }
              this.checkForConsuming();
            }
            /* Do a pass over our linked events and check to see if any pair
             * of segments match, and should be consumed. */
          }, {
            key: "checkForConsuming",
            value: function checkForConsuming() {
              var numEvents = this.point.events.length;
              for (var i = 0; i < numEvents; i++) {
                var evt1 = this.point.events[i];
                if (evt1.segment.consumedBy !== void 0)
                  continue;
                for (var j = i + 1; j < numEvents; j++) {
                  var evt2 = this.point.events[j];
                  if (evt2.consumedBy !== void 0)
                    continue;
                  if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
                    continue;
                  evt1.segment.consume(evt2.segment);
                }
              }
            }
          }, {
            key: "getAvailableLinkedEvents",
            value: function getAvailableLinkedEvents() {
              var events = [];
              for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
                var evt = this.point.events[i];
                if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                  events.push(evt);
                }
              }
              return events;
            }
            /**
             * Returns a comparator function for sorting linked events that will
             * favor the event that will give us the smallest left-side angle.
             * All ring construction starts as low as possible heading to the right,
             * so by always turning left as sharp as possible we'll get polygons
             * without uncessary loops & holes.
             *
             * The comparator function has a compute cache such that it avoids
             * re-computing already-computed values.
             */
          }, {
            key: "getLeftmostComparator",
            value: function getLeftmostComparator(baseEvent) {
              var _this = this;
              var cache = /* @__PURE__ */ new Map();
              var fillCache = function fillCache2(linkedEvent) {
                var nextEvent = linkedEvent.otherSE;
                cache.set(linkedEvent, {
                  sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
                  cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
                });
              };
              return function(a, b) {
                if (!cache.has(a))
                  fillCache(a);
                if (!cache.has(b))
                  fillCache(b);
                var _cache$get = cache.get(a), asine = _cache$get.sine, acosine = _cache$get.cosine;
                var _cache$get2 = cache.get(b), bsine = _cache$get2.sine, bcosine = _cache$get2.cosine;
                if (asine >= 0 && bsine >= 0) {
                  if (acosine < bcosine)
                    return 1;
                  if (acosine > bcosine)
                    return -1;
                  return 0;
                }
                if (asine < 0 && bsine < 0) {
                  if (acosine < bcosine)
                    return -1;
                  if (acosine > bcosine)
                    return 1;
                  return 0;
                }
                if (bsine < asine)
                  return -1;
                if (bsine > asine)
                  return 1;
                return 0;
              };
            }
          }]);
          return SweepEvent2;
        }();
        var segmentId = 0;
        var Segment = /* @__PURE__ */ function() {
          _createClass(Segment2, null, [{
            key: "compare",
            /* This compare() function is for ordering segments in the sweep
             * line tree, and does so according to the following criteria:
             *
             * Consider the vertical line that lies an infinestimal step to the
             * right of the right-more of the two left endpoints of the input
             * segments. Imagine slowly moving a point up from negative infinity
             * in the increasing y direction. Which of the two segments will that
             * point intersect first? That segment comes 'before' the other one.
             *
             * If neither segment would be intersected by such a line, (if one
             * or more of the segments are vertical) then the line to be considered
             * is directly on the right-more of the two left inputs.
             */
            value: function compare(a, b) {
              var alx = a.leftSE.point.x;
              var blx = b.leftSE.point.x;
              var arx = a.rightSE.point.x;
              var brx = b.rightSE.point.x;
              if (brx < alx)
                return 1;
              if (arx < blx)
                return -1;
              var aly = a.leftSE.point.y;
              var bly = b.leftSE.point.y;
              var ary = a.rightSE.point.y;
              var bry = b.rightSE.point.y;
              if (alx < blx) {
                if (bly < aly && bly < ary)
                  return 1;
                if (bly > aly && bly > ary)
                  return -1;
                var aCmpBLeft = a.comparePoint(b.leftSE.point);
                if (aCmpBLeft < 0)
                  return 1;
                if (aCmpBLeft > 0)
                  return -1;
                var bCmpARight = b.comparePoint(a.rightSE.point);
                if (bCmpARight !== 0)
                  return bCmpARight;
                return -1;
              }
              if (alx > blx) {
                if (aly < bly && aly < bry)
                  return -1;
                if (aly > bly && aly > bry)
                  return 1;
                var bCmpALeft = b.comparePoint(a.leftSE.point);
                if (bCmpALeft !== 0)
                  return bCmpALeft;
                var aCmpBRight = a.comparePoint(b.rightSE.point);
                if (aCmpBRight < 0)
                  return 1;
                if (aCmpBRight > 0)
                  return -1;
                return 1;
              }
              if (aly < bly)
                return -1;
              if (aly > bly)
                return 1;
              if (arx < brx) {
                var _bCmpARight = b.comparePoint(a.rightSE.point);
                if (_bCmpARight !== 0)
                  return _bCmpARight;
              }
              if (arx > brx) {
                var _aCmpBRight = a.comparePoint(b.rightSE.point);
                if (_aCmpBRight < 0)
                  return 1;
                if (_aCmpBRight > 0)
                  return -1;
              }
              if (arx !== brx) {
                var ay = ary - aly;
                var ax = arx - alx;
                var by = bry - bly;
                var bx = brx - blx;
                if (ay > ax && by < bx)
                  return 1;
                if (ay < ax && by > bx)
                  return -1;
              }
              if (arx > brx)
                return 1;
              if (arx < brx)
                return -1;
              if (ary < bry)
                return -1;
              if (ary > bry)
                return 1;
              if (a.id < b.id)
                return -1;
              if (a.id > b.id)
                return 1;
              return 0;
            }
            /* Warning: a reference to ringWindings input will be stored,
             *  and possibly will be later modified */
          }]);
          function Segment2(leftSE, rightSE, rings, windings) {
            _classCallCheck(this, Segment2);
            this.id = ++segmentId;
            this.leftSE = leftSE;
            leftSE.segment = this;
            leftSE.otherSE = rightSE;
            this.rightSE = rightSE;
            rightSE.segment = this;
            rightSE.otherSE = leftSE;
            this.rings = rings;
            this.windings = windings;
          }
          _createClass(Segment2, [{
            key: "replaceRightSE",
            /* When a segment is split, the rightSE is replaced with a new sweep event */
            value: function replaceRightSE(newRightSE) {
              this.rightSE = newRightSE;
              this.rightSE.segment = this;
              this.rightSE.otherSE = this.leftSE;
              this.leftSE.otherSE = this.rightSE;
            }
          }, {
            key: "bbox",
            value: function bbox3() {
              var y1 = this.leftSE.point.y;
              var y2 = this.rightSE.point.y;
              return {
                ll: {
                  x: this.leftSE.point.x,
                  y: y1 < y2 ? y1 : y2
                },
                ur: {
                  x: this.rightSE.point.x,
                  y: y1 > y2 ? y1 : y2
                }
              };
            }
            /* A vector from the left point to the right */
          }, {
            key: "vector",
            value: function vector() {
              return {
                x: this.rightSE.point.x - this.leftSE.point.x,
                y: this.rightSE.point.y - this.leftSE.point.y
              };
            }
          }, {
            key: "isAnEndpoint",
            value: function isAnEndpoint(pt) {
              return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
            }
            /* Compare this segment with a point.
             *
             * A point P is considered to be colinear to a segment if there
             * exists a distance D such that if we travel along the segment
             * from one * endpoint towards the other a distance D, we find
             * ourselves at point P.
             *
             * Return value indicates:
             *
             *   1: point lies above the segment (to the left of vertical)
             *   0: point is colinear to segment
             *  -1: point lies below the segment (to the right of vertical)
             */
          }, {
            key: "comparePoint",
            value: function comparePoint(point2) {
              if (this.isAnEndpoint(point2))
                return 0;
              var lPt = this.leftSE.point;
              var rPt = this.rightSE.point;
              var v = this.vector();
              if (lPt.x === rPt.x) {
                if (point2.x === lPt.x)
                  return 0;
                return point2.x < lPt.x ? 1 : -1;
              }
              var yDist = (point2.y - lPt.y) / v.y;
              var xFromYDist = lPt.x + yDist * v.x;
              if (point2.x === xFromYDist)
                return 0;
              var xDist = (point2.x - lPt.x) / v.x;
              var yFromXDist = lPt.y + xDist * v.y;
              if (point2.y === yFromXDist)
                return 0;
              return point2.y < yFromXDist ? -1 : 1;
            }
            /**
             * Given another segment, returns the first non-trivial intersection
             * between the two segments (in terms of sweep line ordering), if it exists.
             *
             * A 'non-trivial' intersection is one that will cause one or both of the
             * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
             *
             *   * endpoint of segA with endpoint of segB --> trivial
             *   * endpoint of segA with point along segB --> non-trivial
             *   * endpoint of segB with point along segA --> non-trivial
             *   * point along segA with point along segB --> non-trivial
             *
             * If no non-trivial intersection exists, return null
             * Else, return null.
             */
          }, {
            key: "getIntersection",
            value: function getIntersection(other) {
              var tBbox = this.bbox();
              var oBbox = other.bbox();
              var bboxOverlap = getBboxOverlap(tBbox, oBbox);
              if (bboxOverlap === null)
                return null;
              var tlp = this.leftSE.point;
              var trp = this.rightSE.point;
              var olp = other.leftSE.point;
              var orp = other.rightSE.point;
              var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
              var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
              var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
              var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
              if (touchesThisLSE && touchesOtherLSE) {
                if (touchesThisRSE && !touchesOtherRSE)
                  return trp;
                if (!touchesThisRSE && touchesOtherRSE)
                  return orp;
                return null;
              }
              if (touchesThisLSE) {
                if (touchesOtherRSE) {
                  if (tlp.x === orp.x && tlp.y === orp.y)
                    return null;
                }
                return tlp;
              }
              if (touchesOtherLSE) {
                if (touchesThisRSE) {
                  if (trp.x === olp.x && trp.y === olp.y)
                    return null;
                }
                return olp;
              }
              if (touchesThisRSE && touchesOtherRSE)
                return null;
              if (touchesThisRSE)
                return trp;
              if (touchesOtherRSE)
                return orp;
              var pt = intersection(tlp, this.vector(), olp, other.vector());
              if (pt === null)
                return null;
              if (!isInBbox(bboxOverlap, pt))
                return null;
              return rounder.round(pt.x, pt.y);
            }
            /**
             * Split the given segment into multiple segments on the given points.
             *  * Each existing segment will retain its leftSE and a new rightSE will be
             *    generated for it.
             *  * A new segment will be generated which will adopt the original segment's
             *    rightSE, and a new leftSE will be generated for it.
             *  * If there are more than two points given to split on, new segments
             *    in the middle will be generated with new leftSE and rightSE's.
             *  * An array of the newly generated SweepEvents will be returned.
             *
             * Warning: input array of points is modified
             */
          }, {
            key: "split",
            value: function split2(point2) {
              var newEvents = [];
              var alreadyLinked = point2.events !== void 0;
              var newLeftSE = new SweepEvent(point2, true);
              var newRightSE = new SweepEvent(point2, false);
              var oldRightSE = this.rightSE;
              this.replaceRightSE(newRightSE);
              newEvents.push(newRightSE);
              newEvents.push(newLeftSE);
              var newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
              if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
                newSeg.swapEvents();
              }
              if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
                this.swapEvents();
              }
              if (alreadyLinked) {
                newLeftSE.checkForConsuming();
                newRightSE.checkForConsuming();
              }
              return newEvents;
            }
            /* Swap which event is left and right */
          }, {
            key: "swapEvents",
            value: function swapEvents() {
              var tmpEvt = this.rightSE;
              this.rightSE = this.leftSE;
              this.leftSE = tmpEvt;
              this.leftSE.isLeft = true;
              this.rightSE.isLeft = false;
              for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
                this.windings[i] *= -1;
              }
            }
            /* Consume another segment. We take their rings under our wing
             * and mark them as consumed. Use for perfectly overlapping segments */
          }, {
            key: "consume",
            value: function consume(other) {
              var consumer = this;
              var consumee = other;
              while (consumer.consumedBy) {
                consumer = consumer.consumedBy;
              }
              while (consumee.consumedBy) {
                consumee = consumee.consumedBy;
              }
              var cmp2 = Segment2.compare(consumer, consumee);
              if (cmp2 === 0)
                return;
              if (cmp2 > 0) {
                var tmp = consumer;
                consumer = consumee;
                consumee = tmp;
              }
              if (consumer.prev === consumee) {
                var _tmp = consumer;
                consumer = consumee;
                consumee = _tmp;
              }
              for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
                var ring = consumee.rings[i];
                var winding = consumee.windings[i];
                var index2 = consumer.rings.indexOf(ring);
                if (index2 === -1) {
                  consumer.rings.push(ring);
                  consumer.windings.push(winding);
                } else
                  consumer.windings[index2] += winding;
              }
              consumee.rings = null;
              consumee.windings = null;
              consumee.consumedBy = consumer;
              consumee.leftSE.consumedBy = consumer.leftSE;
              consumee.rightSE.consumedBy = consumer.rightSE;
            }
            /* The first segment previous segment chain that is in the result */
          }, {
            key: "prevInResult",
            value: function prevInResult() {
              if (this._prevInResult !== void 0)
                return this._prevInResult;
              if (!this.prev)
                this._prevInResult = null;
              else if (this.prev.isInResult())
                this._prevInResult = this.prev;
              else
                this._prevInResult = this.prev.prevInResult();
              return this._prevInResult;
            }
          }, {
            key: "beforeState",
            value: function beforeState() {
              if (this._beforeState !== void 0)
                return this._beforeState;
              if (!this.prev)
                this._beforeState = {
                  rings: [],
                  windings: [],
                  multiPolys: []
                };
              else {
                var seg = this.prev.consumedBy || this.prev;
                this._beforeState = seg.afterState();
              }
              return this._beforeState;
            }
          }, {
            key: "afterState",
            value: function afterState() {
              if (this._afterState !== void 0)
                return this._afterState;
              var beforeState = this.beforeState();
              this._afterState = {
                rings: beforeState.rings.slice(0),
                windings: beforeState.windings.slice(0),
                multiPolys: []
              };
              var ringsAfter = this._afterState.rings;
              var windingsAfter = this._afterState.windings;
              var mpsAfter = this._afterState.multiPolys;
              for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
                var ring = this.rings[i];
                var winding = this.windings[i];
                var index2 = ringsAfter.indexOf(ring);
                if (index2 === -1) {
                  ringsAfter.push(ring);
                  windingsAfter.push(winding);
                } else
                  windingsAfter[index2] += winding;
              }
              var polysAfter = [];
              var polysExclude = [];
              for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
                if (windingsAfter[_i] === 0)
                  continue;
                var _ring = ringsAfter[_i];
                var poly = _ring.poly;
                if (polysExclude.indexOf(poly) !== -1)
                  continue;
                if (_ring.isExterior)
                  polysAfter.push(poly);
                else {
                  if (polysExclude.indexOf(poly) === -1)
                    polysExclude.push(poly);
                  var _index = polysAfter.indexOf(_ring.poly);
                  if (_index !== -1)
                    polysAfter.splice(_index, 1);
                }
              }
              for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
                var mp = polysAfter[_i2].multiPoly;
                if (mpsAfter.indexOf(mp) === -1)
                  mpsAfter.push(mp);
              }
              return this._afterState;
            }
            /* Is this segment part of the final result? */
          }, {
            key: "isInResult",
            value: function isInResult() {
              if (this.consumedBy)
                return false;
              if (this._isInResult !== void 0)
                return this._isInResult;
              var mpsBefore = this.beforeState().multiPolys;
              var mpsAfter = this.afterState().multiPolys;
              switch (operation.type) {
                case "union": {
                  var noBefores = mpsBefore.length === 0;
                  var noAfters = mpsAfter.length === 0;
                  this._isInResult = noBefores !== noAfters;
                  break;
                }
                case "intersection": {
                  var least;
                  var most;
                  if (mpsBefore.length < mpsAfter.length) {
                    least = mpsBefore.length;
                    most = mpsAfter.length;
                  } else {
                    least = mpsAfter.length;
                    most = mpsBefore.length;
                  }
                  this._isInResult = most === operation.numMultiPolys && least < most;
                  break;
                }
                case "xor": {
                  var diff = Math.abs(mpsBefore.length - mpsAfter.length);
                  this._isInResult = diff % 2 === 1;
                  break;
                }
                case "difference": {
                  var isJustSubject = function isJustSubject2(mps) {
                    return mps.length === 1 && mps[0].isSubject;
                  };
                  this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                  break;
                }
                default:
                  throw new Error("Unrecognized operation type found ".concat(operation.type));
              }
              return this._isInResult;
            }
          }], [{
            key: "fromRing",
            value: function fromRing(pt1, pt2, ring) {
              var leftPt, rightPt, winding;
              var cmpPts = SweepEvent.comparePoints(pt1, pt2);
              if (cmpPts < 0) {
                leftPt = pt1;
                rightPt = pt2;
                winding = 1;
              } else if (cmpPts > 0) {
                leftPt = pt2;
                rightPt = pt1;
                winding = -1;
              } else
                throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
              var leftSE = new SweepEvent(leftPt, true);
              var rightSE = new SweepEvent(rightPt, false);
              return new Segment2(leftSE, rightSE, [ring], [winding]);
            }
          }]);
          return Segment2;
        }();
        var RingIn = /* @__PURE__ */ function() {
          function RingIn2(geomRing, poly, isExterior) {
            _classCallCheck(this, RingIn2);
            if (!Array.isArray(geomRing) || geomRing.length === 0) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.poly = poly;
            this.isExterior = isExterior;
            this.segments = [];
            if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
            this.bbox = {
              ll: {
                x: firstPoint.x,
                y: firstPoint.y
              },
              ur: {
                x: firstPoint.x,
                y: firstPoint.y
              }
            };
            var prevPoint = firstPoint;
            for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
              if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
                throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
              }
              var point2 = rounder.round(geomRing[i][0], geomRing[i][1]);
              if (point2.x === prevPoint.x && point2.y === prevPoint.y)
                continue;
              this.segments.push(Segment.fromRing(prevPoint, point2, this));
              if (point2.x < this.bbox.ll.x)
                this.bbox.ll.x = point2.x;
              if (point2.y < this.bbox.ll.y)
                this.bbox.ll.y = point2.y;
              if (point2.x > this.bbox.ur.x)
                this.bbox.ur.x = point2.x;
              if (point2.y > this.bbox.ur.y)
                this.bbox.ur.y = point2.y;
              prevPoint = point2;
            }
            if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
              this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
            }
          }
          _createClass(RingIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
                var segment = this.segments[i];
                sweepEvents.push(segment.leftSE);
                sweepEvents.push(segment.rightSE);
              }
              return sweepEvents;
            }
          }]);
          return RingIn2;
        }();
        var PolyIn = /* @__PURE__ */ function() {
          function PolyIn2(geomPoly, multiPoly) {
            _classCallCheck(this, PolyIn2);
            if (!Array.isArray(geomPoly)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.exteriorRing = new RingIn(geomPoly[0], this, true);
            this.bbox = {
              ll: {
                x: this.exteriorRing.bbox.ll.x,
                y: this.exteriorRing.bbox.ll.y
              },
              ur: {
                x: this.exteriorRing.bbox.ur.x,
                y: this.exteriorRing.bbox.ur.y
              }
            };
            this.interiorRings = [];
            for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
              var ring = new RingIn(geomPoly[i], this, false);
              if (ring.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = ring.bbox.ll.x;
              if (ring.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = ring.bbox.ll.y;
              if (ring.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = ring.bbox.ur.x;
              if (ring.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = ring.bbox.ur.y;
              this.interiorRings.push(ring);
            }
            this.multiPoly = multiPoly;
          }
          _createClass(PolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = this.exteriorRing.getSweepEvents();
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringSweepEvents = this.interiorRings[i].getSweepEvents();
                for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(ringSweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return PolyIn2;
        }();
        var MultiPolyIn = /* @__PURE__ */ function() {
          function MultiPolyIn2(geom, isSubject) {
            _classCallCheck(this, MultiPolyIn2);
            if (!Array.isArray(geom)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            try {
              if (typeof geom[0][0][0] === "number")
                geom = [geom];
            } catch (ex) {
            }
            this.polys = [];
            this.bbox = {
              ll: {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
              },
              ur: {
                x: Number.NEGATIVE_INFINITY,
                y: Number.NEGATIVE_INFINITY
              }
            };
            for (var i = 0, iMax = geom.length; i < iMax; i++) {
              var poly = new PolyIn(geom[i], this);
              if (poly.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = poly.bbox.ll.x;
              if (poly.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = poly.bbox.ll.y;
              if (poly.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = poly.bbox.ur.x;
              if (poly.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = poly.bbox.ur.y;
              this.polys.push(poly);
            }
            this.isSubject = isSubject;
          }
          _createClass(MultiPolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polySweepEvents = this.polys[i].getSweepEvents();
                for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(polySweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return MultiPolyIn2;
        }();
        var RingOut = /* @__PURE__ */ function() {
          _createClass(RingOut2, null, [{
            key: "factory",
            /* Given the segments from the sweep line pass, compute & return a series
             * of closed rings from all the segments marked to be part of the result */
            value: function factory(allSegments) {
              var ringsOut = [];
              for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
                var segment = allSegments[i];
                if (!segment.isInResult() || segment.ringOut)
                  continue;
                var prevEvent = null;
                var event = segment.leftSE;
                var nextEvent = segment.rightSE;
                var events = [event];
                var startingPoint = event.point;
                var intersectionLEs = [];
                while (true) {
                  prevEvent = event;
                  event = nextEvent;
                  events.push(event);
                  if (event.point === startingPoint)
                    break;
                  while (true) {
                    var availableLEs = event.getAvailableLinkedEvents();
                    if (availableLEs.length === 0) {
                      var firstPt = events[0].point;
                      var lastPt = events[events.length - 1].point;
                      throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
                    }
                    if (availableLEs.length === 1) {
                      nextEvent = availableLEs[0].otherSE;
                      break;
                    }
                    var indexLE = null;
                    for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                      if (intersectionLEs[j].point === event.point) {
                        indexLE = j;
                        break;
                      }
                    }
                    if (indexLE !== null) {
                      var intersectionLE = intersectionLEs.splice(indexLE)[0];
                      var ringEvents = events.splice(intersectionLE.index);
                      ringEvents.unshift(ringEvents[0].otherSE);
                      ringsOut.push(new RingOut2(ringEvents.reverse()));
                      continue;
                    }
                    intersectionLEs.push({
                      index: events.length,
                      point: event.point
                    });
                    var comparator = event.getLeftmostComparator(prevEvent);
                    nextEvent = availableLEs.sort(comparator)[0].otherSE;
                    break;
                  }
                }
                ringsOut.push(new RingOut2(events));
              }
              return ringsOut;
            }
          }]);
          function RingOut2(events) {
            _classCallCheck(this, RingOut2);
            this.events = events;
            for (var i = 0, iMax = events.length; i < iMax; i++) {
              events[i].segment.ringOut = this;
            }
            this.poly = null;
          }
          _createClass(RingOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var prevPt = this.events[0].point;
              var points = [prevPt];
              for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
                var _pt = this.events[i].point;
                var _nextPt = this.events[i + 1].point;
                if (compareVectorAngles(_pt, prevPt, _nextPt) === 0)
                  continue;
                points.push(_pt);
                prevPt = _pt;
              }
              if (points.length === 1)
                return null;
              var pt = points[0];
              var nextPt = points[1];
              if (compareVectorAngles(pt, prevPt, nextPt) === 0)
                points.shift();
              points.push(points[0]);
              var step = this.isExteriorRing() ? 1 : -1;
              var iStart = this.isExteriorRing() ? 0 : points.length - 1;
              var iEnd = this.isExteriorRing() ? points.length : -1;
              var orderedPoints = [];
              for (var _i = iStart; _i != iEnd; _i += step) {
                orderedPoints.push([points[_i].x, points[_i].y]);
              }
              return orderedPoints;
            }
          }, {
            key: "isExteriorRing",
            value: function isExteriorRing() {
              if (this._isExteriorRing === void 0) {
                var enclosing = this.enclosingRing();
                this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
              }
              return this._isExteriorRing;
            }
          }, {
            key: "enclosingRing",
            value: function enclosingRing() {
              if (this._enclosingRing === void 0) {
                this._enclosingRing = this._calcEnclosingRing();
              }
              return this._enclosingRing;
            }
            /* Returns the ring that encloses this one, if any */
          }, {
            key: "_calcEnclosingRing",
            value: function _calcEnclosingRing() {
              var leftMostEvt = this.events[0];
              for (var i = 1, iMax = this.events.length; i < iMax; i++) {
                var evt = this.events[i];
                if (SweepEvent.compare(leftMostEvt, evt) > 0)
                  leftMostEvt = evt;
              }
              var prevSeg = leftMostEvt.segment.prevInResult();
              var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              while (true) {
                if (!prevSeg)
                  return null;
                if (!prevPrevSeg)
                  return prevSeg.ringOut;
                if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                  if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                    return prevSeg.ringOut;
                  } else
                    return prevSeg.ringOut.enclosingRing();
                }
                prevSeg = prevPrevSeg.prevInResult();
                prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              }
            }
          }]);
          return RingOut2;
        }();
        var PolyOut = /* @__PURE__ */ function() {
          function PolyOut2(exteriorRing) {
            _classCallCheck(this, PolyOut2);
            this.exteriorRing = exteriorRing;
            exteriorRing.poly = this;
            this.interiorRings = [];
          }
          _createClass(PolyOut2, [{
            key: "addInterior",
            value: function addInterior(ring) {
              this.interiorRings.push(ring);
              ring.poly = this;
            }
          }, {
            key: "getGeom",
            value: function getGeom2() {
              var geom = [this.exteriorRing.getGeom()];
              if (geom[0] === null)
                return null;
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringGeom = this.interiorRings[i].getGeom();
                if (ringGeom === null)
                  continue;
                geom.push(ringGeom);
              }
              return geom;
            }
          }]);
          return PolyOut2;
        }();
        var MultiPolyOut = /* @__PURE__ */ function() {
          function MultiPolyOut2(rings) {
            _classCallCheck(this, MultiPolyOut2);
            this.rings = rings;
            this.polys = this._composePolys(rings);
          }
          _createClass(MultiPolyOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var geom = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polyGeom = this.polys[i].getGeom();
                if (polyGeom === null)
                  continue;
                geom.push(polyGeom);
              }
              return geom;
            }
          }, {
            key: "_composePolys",
            value: function _composePolys(rings) {
              var polys = [];
              for (var i = 0, iMax = rings.length; i < iMax; i++) {
                var ring = rings[i];
                if (ring.poly)
                  continue;
                if (ring.isExteriorRing())
                  polys.push(new PolyOut(ring));
                else {
                  var enclosingRing = ring.enclosingRing();
                  if (!enclosingRing.poly)
                    polys.push(new PolyOut(enclosingRing));
                  enclosingRing.poly.addInterior(ring);
                }
              }
              return polys;
            }
          }]);
          return MultiPolyOut2;
        }();
        var SweepLine = /* @__PURE__ */ function() {
          function SweepLine2(queue) {
            var comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
            _classCallCheck(this, SweepLine2);
            this.queue = queue;
            this.tree = new Tree(comparator);
            this.segments = [];
          }
          _createClass(SweepLine2, [{
            key: "process",
            value: function process2(event) {
              var segment = event.segment;
              var newEvents = [];
              if (event.consumedBy) {
                if (event.isLeft)
                  this.queue.remove(event.otherSE);
                else
                  this.tree.remove(segment);
                return newEvents;
              }
              var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
              if (!node)
                throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
              var prevNode = node;
              var nextNode = node;
              var prevSeg = void 0;
              var nextSeg = void 0;
              while (prevSeg === void 0) {
                prevNode = this.tree.prev(prevNode);
                if (prevNode === null)
                  prevSeg = null;
                else if (prevNode.key.consumedBy === void 0)
                  prevSeg = prevNode.key;
              }
              while (nextSeg === void 0) {
                nextNode = this.tree.next(nextNode);
                if (nextNode === null)
                  nextSeg = null;
                else if (nextNode.key.consumedBy === void 0)
                  nextSeg = nextNode.key;
              }
              if (event.isLeft) {
                var prevMySplitter = null;
                if (prevSeg) {
                  var prevInter = prevSeg.getIntersection(segment);
                  if (prevInter !== null) {
                    if (!segment.isAnEndpoint(prevInter))
                      prevMySplitter = prevInter;
                    if (!prevSeg.isAnEndpoint(prevInter)) {
                      var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                      for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                        newEvents.push(newEventsFromSplit[i]);
                      }
                    }
                  }
                }
                var nextMySplitter = null;
                if (nextSeg) {
                  var nextInter = nextSeg.getIntersection(segment);
                  if (nextInter !== null) {
                    if (!segment.isAnEndpoint(nextInter))
                      nextMySplitter = nextInter;
                    if (!nextSeg.isAnEndpoint(nextInter)) {
                      var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                      for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                        newEvents.push(_newEventsFromSplit[_i]);
                      }
                    }
                  }
                }
                if (prevMySplitter !== null || nextMySplitter !== null) {
                  var mySplitter = null;
                  if (prevMySplitter === null)
                    mySplitter = nextMySplitter;
                  else if (nextMySplitter === null)
                    mySplitter = prevMySplitter;
                  else {
                    var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                    mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                  }
                  this.queue.remove(segment.rightSE);
                  newEvents.push(segment.rightSE);
                  var _newEventsFromSplit2 = segment.split(mySplitter);
                  for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
                    newEvents.push(_newEventsFromSplit2[_i2]);
                  }
                }
                if (newEvents.length > 0) {
                  this.tree.remove(segment);
                  newEvents.push(event);
                } else {
                  this.segments.push(segment);
                  segment.prev = prevSeg;
                }
              } else {
                if (prevSeg && nextSeg) {
                  var inter = prevSeg.getIntersection(nextSeg);
                  if (inter !== null) {
                    if (!prevSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);
                      for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                        newEvents.push(_newEventsFromSplit3[_i3]);
                      }
                    }
                    if (!nextSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);
                      for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                        newEvents.push(_newEventsFromSplit4[_i4]);
                      }
                    }
                  }
                }
                this.tree.remove(segment);
              }
              return newEvents;
            }
            /* Safely split a segment that is currently in the datastructures
             * IE - a segment other than the one that is currently being processed. */
          }, {
            key: "_splitSafely",
            value: function _splitSafely(seg, pt) {
              this.tree.remove(seg);
              var rightSE = seg.rightSE;
              this.queue.remove(rightSE);
              var newEvents = seg.split(pt);
              newEvents.push(rightSE);
              if (seg.consumedBy === void 0)
                this.tree.insert(seg);
              return newEvents;
            }
          }]);
          return SweepLine2;
        }();
        var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
        var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
        var Operation = /* @__PURE__ */ function() {
          function Operation2() {
            _classCallCheck(this, Operation2);
          }
          _createClass(Operation2, [{
            key: "run",
            value: function run(type, geom, moreGeoms) {
              operation.type = type;
              rounder.reset();
              var multipolys = [new MultiPolyIn(geom, true)];
              for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
                multipolys.push(new MultiPolyIn(moreGeoms[i], false));
              }
              operation.numMultiPolys = multipolys.length;
              if (operation.type === "difference") {
                var subject = multipolys[0];
                var _i = 1;
                while (_i < multipolys.length) {
                  if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null)
                    _i++;
                  else
                    multipolys.splice(_i, 1);
                }
              }
              if (operation.type === "intersection") {
                for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
                  var mpA = multipolys[_i2];
                  for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
                    if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
                      return [];
                  }
                }
              }
              var queue = new Tree(SweepEvent.compare);
              for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
                var sweepEvents = multipolys[_i3].getSweepEvents();
                for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
                  queue.insert(sweepEvents[_j]);
                  if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                    throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
                  }
                }
              }
              var sweepLine = new SweepLine(queue);
              var prevQueueSize = queue.size;
              var node = queue.pop();
              while (node) {
                var evt = node.key;
                if (queue.size === prevQueueSize) {
                  var seg = evt.segment;
                  throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
                }
                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
                }
                if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
                }
                var newEvents = sweepLine.process(evt);
                for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
                  var _evt = newEvents[_i4];
                  if (_evt.consumedBy === void 0)
                    queue.insert(_evt);
                }
                prevQueueSize = queue.size;
                node = queue.pop();
              }
              rounder.reset();
              var ringsOut = RingOut.factory(sweepLine.segments);
              var result = new MultiPolyOut(ringsOut);
              return result.getGeom();
            }
          }]);
          return Operation2;
        }();
        var operation = new Operation();
        var union = function union2(geom) {
          for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            moreGeoms[_key - 1] = arguments[_key];
          }
          return operation.run("union", geom, moreGeoms);
        };
        var intersection$1 = function intersection2(geom) {
          for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            moreGeoms[_key2 - 1] = arguments[_key2];
          }
          return operation.run("intersection", geom, moreGeoms);
        };
        var xor = function xor2(geom) {
          for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            moreGeoms[_key3 - 1] = arguments[_key3];
          }
          return operation.run("xor", geom, moreGeoms);
        };
        var difference = function difference2(subjectGeom) {
          for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            clippingGeoms[_key4 - 1] = arguments[_key4];
          }
          return operation.run("difference", subjectGeom, clippingGeoms);
        };
        var index = {
          union,
          intersection: intersection$1,
          xor,
          difference
        };
        return index;
      });
    }
  });

  // ../../../../../../../node_modules/turf-jsts/jsts.min.js
  var require_jsts_min = __commonJS({
    "../../../../../../../node_modules/turf-jsts/jsts.min.js"(exports, module) {
      !function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.jsts = {});
      }(exports, function(t) {
        "use strict";
        function e() {
        }
        function n(t2) {
          this.message = t2 || "";
        }
        function i(t2) {
          this.message = t2 || "";
        }
        function r(t2) {
          this.message = t2 || "";
        }
        function o() {
        }
        function s(t2) {
          return null === t2 ? Mt : t2.color;
        }
        function a(t2) {
          return null === t2 ? null : t2.parent;
        }
        function u(t2, e3) {
          null !== t2 && (t2.color = e3);
        }
        function l(t2) {
          return null === t2 ? null : t2.left;
        }
        function c(t2) {
          return null === t2 ? null : t2.right;
        }
        function p() {
          this.root_ = null, this.size_ = 0;
        }
        function h() {
        }
        function f() {
          this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
        }
        function g() {
        }
        function d(t2) {
          this.message = t2 || "";
        }
        function y2() {
          this.array_ = [];
        }
        "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: true, value: function(t2) {
          if (void 0 === this || null === this)
            throw new TypeError(this + " is not an object");
          var e3 = Object(this), n2 = Math.max(Math.min(e3.length, 9007199254740991), 0) || 0, i2 = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
          i2 = i2 < 0 ? Math.max(n2 + i2, 0) : Math.min(i2, n2);
          var r2 = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n2;
          for (r2 = r2 < 0 ? Math.max(n2 + arguments[2], 0) : Math.min(r2, n2); i2 < r2; )
            e3[i2] = t2, ++i2;
          return e3;
        }, writable: true }), Number.isFinite = Number.isFinite || function(t2) {
          return "number" == typeof t2 && isFinite(t2);
        }, Number.isInteger = Number.isInteger || function(t2) {
          return "number" == typeof t2 && isFinite(t2) && Math.floor(t2) === t2;
        }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(t2) {
          return t2 != t2;
        }, Math.trunc = Math.trunc || function(t2) {
          return t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
        };
        var _ = function() {
        };
        _.prototype.interfaces_ = function() {
          return [];
        }, _.prototype.getClass = function() {
          return _;
        }, _.prototype.equalsWithTolerance = function(t2, e3, n2) {
          return Math.abs(t2 - e3) <= n2;
        };
        var m = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "IllegalArgumentException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), v = function() {
        }, I = { MAX_VALUE: { configurable: true } };
        v.isNaN = function(t2) {
          return Number.isNaN(t2);
        }, v.doubleToLongBits = function(t2) {
          return t2;
        }, v.longBitsToDouble = function(t2) {
          return t2;
        }, v.isInfinite = function(t2) {
          return !Number.isFinite(t2);
        }, I.MAX_VALUE.get = function() {
          return Number.MAX_VALUE;
        }, Object.defineProperties(v, I);
        var E = function() {
        }, x2 = function() {
        }, N = function() {
        }, C = function t2() {
          if (this.x = null, this.y = null, this.z = null, 0 === arguments.length)
            this.x = 0, this.y = 0, this.z = t2.NULL_ORDINATE;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.z = e3.z;
          } else
            2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t2.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
        }, S = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
        C.prototype.setOrdinate = function(t2, e3) {
          switch (t2) {
            case C.X:
              this.x = e3;
              break;
            case C.Y:
              this.y = e3;
              break;
            case C.Z:
              this.z = e3;
              break;
            default:
              throw new m("Invalid ordinate index: " + t2);
          }
        }, C.prototype.equals2D = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.x === t2.x && this.y === t2.y;
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return !!_.equalsWithTolerance(this.x, e3.x, n2) && !!_.equalsWithTolerance(this.y, e3.y, n2);
          }
        }, C.prototype.getOrdinate = function(t2) {
          switch (t2) {
            case C.X:
              return this.x;
            case C.Y:
              return this.y;
            case C.Z:
              return this.z;
          }
          throw new m("Invalid ordinate index: " + t2);
        }, C.prototype.equals3D = function(t2) {
          return this.x === t2.x && this.y === t2.y && (this.z === t2.z || v.isNaN(this.z)) && v.isNaN(t2.z);
        }, C.prototype.equals = function(t2) {
          return t2 instanceof C && this.equals2D(t2);
        }, C.prototype.equalInZ = function(t2, e3) {
          return _.equalsWithTolerance(this.z, t2.z, e3);
        }, C.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.x < e3.x ? -1 : this.x > e3.x ? 1 : this.y < e3.y ? -1 : this.y > e3.y ? 1 : 0;
        }, C.prototype.clone = function() {
        }, C.prototype.copy = function() {
          return new C(this);
        }, C.prototype.toString = function() {
          return "(" + this.x + ", " + this.y + ", " + this.z + ")";
        }, C.prototype.distance3D = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y, i2 = this.z - t2.z;
          return Math.sqrt(e3 * e3 + n2 * n2 + i2 * i2);
        }, C.prototype.distance = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y;
          return Math.sqrt(e3 * e3 + n2 * n2);
        }, C.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this.x), t2 = 37 * t2 + C.hashCode(this.y);
        }, C.prototype.setCoordinate = function(t2) {
          this.x = t2.x, this.y = t2.y, this.z = t2.z;
        }, C.prototype.interfaces_ = function() {
          return [E, x2, e];
        }, C.prototype.getClass = function() {
          return C;
        }, C.hashCode = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = v.doubleToLongBits(t2);
            return Math.trunc((e3 ^ e3) >>> 32);
          }
        }, S.DimensionalComparator.get = function() {
          return L3;
        }, S.serialVersionUID.get = function() {
          return 6683108902428367e3;
        }, S.NULL_ORDINATE.get = function() {
          return v.NaN;
        }, S.X.get = function() {
          return 0;
        }, S.Y.get = function() {
          return 1;
        }, S.Z.get = function() {
          return 2;
        }, Object.defineProperties(C, S);
        var L3 = function(t2) {
          if (this._dimensionsToTest = 2, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            if (2 !== e3 && 3 !== e3)
              throw new m("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = e3;
          }
        };
        L3.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = L3.compare(n2.x, i2.x);
          if (0 !== r2)
            return r2;
          var o2 = L3.compare(n2.y, i2.y);
          if (0 !== o2)
            return o2;
          if (this._dimensionsToTest <= 2)
            return 0;
          return L3.compare(n2.z, i2.z);
        }, L3.prototype.interfaces_ = function() {
          return [N];
        }, L3.prototype.getClass = function() {
          return L3;
        }, L3.compare = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : v.isNaN(t2) ? v.isNaN(e3) ? 0 : -1 : v.isNaN(e3) ? 1 : 0;
        };
        var b = function() {
        };
        b.prototype.create = function() {
        }, b.prototype.interfaces_ = function() {
          return [];
        }, b.prototype.getClass = function() {
          return b;
        };
        var w = function() {
        }, O = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
        w.prototype.interfaces_ = function() {
          return [];
        }, w.prototype.getClass = function() {
          return w;
        }, w.toLocationSymbol = function(t2) {
          switch (t2) {
            case w.EXTERIOR:
              return "e";
            case w.BOUNDARY:
              return "b";
            case w.INTERIOR:
              return "i";
            case w.NONE:
              return "-";
          }
          throw new m("Unknown location value: " + t2);
        }, O.INTERIOR.get = function() {
          return 0;
        }, O.BOUNDARY.get = function() {
          return 1;
        }, O.EXTERIOR.get = function() {
          return 2;
        }, O.NONE.get = function() {
          return -1;
        }, Object.defineProperties(w, O);
        var T = function(t2, e3) {
          return t2.interfaces_ && t2.interfaces_().indexOf(e3) > -1;
        }, R = function() {
        }, P = { LOG_10: { configurable: true } };
        R.prototype.interfaces_ = function() {
          return [];
        }, R.prototype.getClass = function() {
          return R;
        }, R.log10 = function(t2) {
          var e3 = Math.log(t2);
          return v.isInfinite(e3) ? e3 : v.isNaN(e3) ? e3 : e3 / R.LOG_10;
        }, R.min = function(t2, e3, n2, i2) {
          var r2 = t2;
          return e3 < r2 && (r2 = e3), n2 < r2 && (r2 = n2), i2 < r2 && (r2 = i2), r2;
        }, R.clamp = function() {
          if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return t2 < e3 ? e3 : t2 > n2 ? n2 : t2;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return i2 < r2 ? r2 : i2 > o2 ? o2 : i2;
          }
        }, R.wrap = function(t2, e3) {
          return t2 < 0 ? e3 - -t2 % e3 : t2 % e3;
        }, R.max = function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2;
            return e3 > i2 && (i2 = e3), n2 > i2 && (i2 = n2), i2;
          }
          if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = r2;
            return o2 > u2 && (u2 = o2), s2 > u2 && (u2 = s2), a2 > u2 && (u2 = a2), u2;
          }
        }, R.average = function(t2, e3) {
          return (t2 + e3) / 2;
        }, P.LOG_10.get = function() {
          return Math.log(10);
        }, Object.defineProperties(R, P);
        var D = function(t2) {
          this.str = t2;
        };
        D.prototype.append = function(t2) {
          this.str += t2;
        }, D.prototype.setCharAt = function(t2, e3) {
          this.str = this.str.substr(0, t2) + e3 + this.str.substr(t2 + 1);
        }, D.prototype.toString = function(t2) {
          return this.str;
        };
        var M = function(t2) {
          this.value = t2;
        };
        M.prototype.intValue = function() {
          return this.value;
        }, M.prototype.compareTo = function(t2) {
          return this.value < t2 ? -1 : this.value > t2 ? 1 : 0;
        }, M.isNaN = function(t2) {
          return Number.isNaN(t2);
        };
        var A = function() {
        };
        A.isWhitespace = function(t2) {
          return t2 <= 32 && t2 >= 0 || 127 === t2;
        }, A.toUpperCase = function(t2) {
          return t2.toUpperCase();
        };
        var F = function t2() {
          if (this._hi = 0, this._lo = 0, 0 === arguments.length)
            this.init(0);
          else if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              this.init(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            } else if ("string" == typeof arguments[0]) {
              var i2 = arguments[0];
              t2.call(this, t2.parse(i2));
            }
          } else if (2 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            this.init(r2, o2);
          }
        }, G = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
        F.prototype.le = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo <= t2._lo;
        }, F.prototype.extractSignificantDigits = function(t2, e3) {
          var n2 = this.abs(), i2 = F.magnitude(n2._hi), r2 = F.TEN.pow(i2);
          (n2 = n2.divide(r2)).gt(F.TEN) ? (n2 = n2.divide(F.TEN), i2 += 1) : n2.lt(F.ONE) && (n2 = n2.multiply(F.TEN), i2 -= 1);
          for (var o2 = i2 + 1, s2 = new D(), a2 = F.MAX_PRINT_DIGITS - 1, u2 = 0; u2 <= a2; u2++) {
            t2 && u2 === o2 && s2.append(".");
            var l2 = Math.trunc(n2._hi);
            if (l2 < 0)
              break;
            var c2 = false, p2 = 0;
            l2 > 9 ? (c2 = true, p2 = "9") : p2 = "0" + l2, s2.append(p2), n2 = n2.subtract(F.valueOf(l2)).multiply(F.TEN), c2 && n2.selfAdd(F.TEN);
            var h2 = true, f2 = F.magnitude(n2._hi);
            if (f2 < 0 && Math.abs(f2) >= a2 - u2 && (h2 = false), !h2)
              break;
          }
          return e3[0] = i2, s2.toString();
        }, F.prototype.sqr = function() {
          return this.multiply(this);
        }, F.prototype.doubleValue = function() {
          return this._hi + this._lo;
        }, F.prototype.subtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.add(t2.negate());
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.add(-e3);
          }
        }, F.prototype.equals = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this._hi === t2._hi && this._lo === t2._lo;
          }
        }, F.prototype.isZero = function() {
          return 0 === this._hi && 0 === this._lo;
        }, F.prototype.selfSubtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-t2._hi, -t2._lo);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-e3, 0);
          }
        }, F.prototype.getSpecialNumberString = function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        }, F.prototype.min = function(t2) {
          return this.le(t2) ? this : t2;
        }, F.prototype.selfDivide = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfDivide(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              return this.selfDivide(e3, 0);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null, c2 = null, p2 = null;
            return u2 = this._hi / n2, l2 = F.SPLIT * u2, r2 = l2 - u2, p2 = F.SPLIT * n2, r2 = l2 - r2, o2 = u2 - r2, s2 = p2 - n2, c2 = u2 * n2, s2 = p2 - s2, a2 = n2 - s2, p2 = r2 * s2 - c2 + r2 * a2 + o2 * s2 + o2 * a2, l2 = (this._hi - c2 - p2 + this._lo - u2 * i2) / n2, p2 = u2 + l2, this._hi = p2, this._lo = u2 - p2 + l2, this;
          }
        }, F.prototype.dump = function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        }, F.prototype.divide = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0], e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null, u2 = null;
            n2 = (o2 = this._hi / t2._hi) - (e3 = (s2 = F.SPLIT * o2) - (e3 = s2 - o2)), u2 = e3 * (i2 = (u2 = F.SPLIT * t2._hi) - (i2 = u2 - t2._hi)) - (a2 = o2 * t2._hi) + e3 * (r2 = t2._hi - i2) + n2 * i2 + n2 * r2, s2 = (this._hi - a2 - u2 + this._lo - o2 * t2._lo) / t2._hi;
            return new F(u2 = o2 + s2, o2 - u2 + s2);
          }
          if ("number" == typeof arguments[0]) {
            var l2 = arguments[0];
            return v.isNaN(l2) ? F.createNaN() : F.copy(this).selfDivide(l2, 0);
          }
        }, F.prototype.ge = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo >= t2._lo;
        }, F.prototype.pow = function(t2) {
          if (0 === t2)
            return F.valueOf(1);
          var e3 = new F(this), n2 = F.valueOf(1), i2 = Math.abs(t2);
          if (i2 > 1)
            for (; i2 > 0; )
              i2 % 2 == 1 && n2.selfMultiply(e3), (i2 /= 2) > 0 && (e3 = e3.sqr());
          else
            n2 = e3;
          return t2 < 0 ? n2.reciprocal() : n2;
        }, F.prototype.ceil = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.ceil(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.ceil(this._lo)), new F(t2, e3);
        }, F.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._hi < e3._hi ? -1 : this._hi > e3._hi ? 1 : this._lo < e3._lo ? -1 : this._lo > e3._lo ? 1 : 0;
        }, F.prototype.rint = function() {
          if (this.isNaN())
            return this;
          return this.add(0.5).floor();
        }, F.prototype.setValue = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.init(t2), this;
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.init(e3), this;
          }
        }, F.prototype.max = function(t2) {
          return this.ge(t2) ? this : t2;
        }, F.prototype.sqrt = function() {
          if (this.isZero())
            return F.valueOf(0);
          if (this.isNegative())
            return F.NaN;
          var t2 = 1 / Math.sqrt(this._hi), e3 = this._hi * t2, n2 = F.valueOf(e3), i2 = this.subtract(n2.sqr())._hi * (0.5 * t2);
          return n2.add(i2);
        }, F.prototype.selfAdd = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfAdd(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0], n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
              return r2 = this._hi + e3, s2 = r2 - this._hi, o2 = r2 - s2, o2 = e3 - s2 + (this._hi - o2), a2 = o2 + this._lo, n2 = r2 + a2, i2 = a2 + (r2 - n2), this._hi = n2 + i2, this._lo = i2 + (n2 - this._hi), this;
            }
          } else if (2 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = null, p2 = null, h2 = null, f2 = null, g2 = null, d2 = null, y3 = null;
            f2 = this._hi + u2, p2 = this._lo + l2, g2 = f2 - (d2 = f2 - this._hi), h2 = p2 - (y3 = p2 - this._lo);
            var _2 = (c2 = f2 + (d2 = (g2 = u2 - d2 + (this._hi - g2)) + p2)) + (d2 = (h2 = l2 - y3 + (this._lo - h2)) + (d2 + (f2 - c2))), m2 = d2 + (c2 - _2);
            return this._hi = _2, this._lo = m2, this;
          }
        }, F.prototype.selfMultiply = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfMultiply(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              return this.selfMultiply(e3, 0);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null;
            r2 = (u2 = F.SPLIT * this._hi) - this._hi, l2 = F.SPLIT * n2, r2 = u2 - r2, o2 = this._hi - r2, s2 = l2 - n2;
            var c2 = (u2 = this._hi * n2) + (l2 = r2 * (s2 = l2 - s2) - u2 + r2 * (a2 = n2 - s2) + o2 * s2 + o2 * a2 + (this._hi * i2 + this._lo * n2)), p2 = l2 + (r2 = u2 - c2);
            return this._hi = c2, this._lo = p2, this;
          }
        }, F.prototype.selfSqr = function() {
          return this.selfMultiply(this);
        }, F.prototype.floor = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.floor(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.floor(this._lo)), new F(t2, e3);
        }, F.prototype.negate = function() {
          return this.isNaN() ? this : new F(-this._hi, -this._lo);
        }, F.prototype.clone = function() {
        }, F.prototype.multiply = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return t2.isNaN() ? F.createNaN() : F.copy(this).selfMultiply(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return v.isNaN(e3) ? F.createNaN() : F.copy(this).selfMultiply(e3, 0);
          }
        }, F.prototype.isNaN = function() {
          return v.isNaN(this._hi);
        }, F.prototype.intValue = function() {
          return Math.trunc(this._hi);
        }, F.prototype.toString = function() {
          var t2 = F.magnitude(this._hi);
          return t2 >= -3 && t2 <= 20 ? this.toStandardNotation() : this.toSciNotation();
        }, F.prototype.toStandardNotation = function() {
          var t2 = this.getSpecialNumberString();
          if (null !== t2)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(true, e3), i2 = e3[0] + 1, r2 = n2;
          if ("." === n2.charAt(0))
            r2 = "0" + n2;
          else if (i2 < 0)
            r2 = "0." + F.stringOfChar("0", -i2) + n2;
          else if (-1 === n2.indexOf(".")) {
            var o2 = i2 - n2.length;
            r2 = n2 + F.stringOfChar("0", o2) + ".0";
          }
          return this.isNegative() ? "-" + r2 : r2;
        }, F.prototype.reciprocal = function() {
          var t2 = null, e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
          e3 = (r2 = 1 / this._hi) - (t2 = (o2 = F.SPLIT * r2) - (t2 = o2 - r2)), n2 = (a2 = F.SPLIT * this._hi) - this._hi;
          var u2 = r2 + (o2 = (1 - (s2 = r2 * this._hi) - (a2 = t2 * (n2 = a2 - n2) - s2 + t2 * (i2 = this._hi - n2) + e3 * n2 + e3 * i2) - r2 * this._lo) / this._hi);
          return new F(u2, r2 - u2 + o2);
        }, F.prototype.toSciNotation = function() {
          if (this.isZero())
            return F.SCI_NOT_ZERO;
          var t2 = this.getSpecialNumberString();
          if (null !== t2)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(false, e3), i2 = F.SCI_NOT_EXPONENT_CHAR + e3[0];
          if ("0" === n2.charAt(0))
            throw new Error("Found leading zero: " + n2);
          var r2 = "";
          n2.length > 1 && (r2 = n2.substring(1));
          var o2 = n2.charAt(0) + "." + r2;
          return this.isNegative() ? "-" + o2 + i2 : o2 + i2;
        }, F.prototype.abs = function() {
          return this.isNaN() ? F.NaN : this.isNegative() ? this.negate() : new F(this);
        }, F.prototype.isPositive = function() {
          return (this._hi > 0 || 0 === this._hi) && this._lo > 0;
        }, F.prototype.lt = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo < t2._lo;
        }, F.prototype.add = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return F.copy(this).selfAdd(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return F.copy(this).selfAdd(e3);
          }
        }, F.prototype.init = function() {
          if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var t2 = arguments[0];
              this._hi = t2, this._lo = 0;
            } else if (arguments[0] instanceof F) {
              var e3 = arguments[0];
              this._hi = e3._hi, this._lo = e3._lo;
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this._hi = n2, this._lo = i2;
          }
        }, F.prototype.gt = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo > t2._lo;
        }, F.prototype.isNegative = function() {
          return (this._hi < 0 || 0 === this._hi) && this._lo < 0;
        }, F.prototype.trunc = function() {
          return this.isNaN() ? F.NaN : this.isPositive() ? this.floor() : this.ceil();
        }, F.prototype.signum = function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        }, F.prototype.interfaces_ = function() {
          return [e, E, x2];
        }, F.prototype.getClass = function() {
          return F;
        }, F.sqr = function(t2) {
          return F.valueOf(t2).selfMultiply(t2);
        }, F.valueOf = function() {
          if ("string" == typeof arguments[0]) {
            var t2 = arguments[0];
            return F.parse(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return new F(e3);
          }
        }, F.sqrt = function(t2) {
          return F.valueOf(t2).sqrt();
        }, F.parse = function(t2) {
          for (var e3 = 0, n2 = t2.length; A.isWhitespace(t2.charAt(e3)); )
            e3++;
          var i2 = false;
          if (e3 < n2) {
            var r2 = t2.charAt(e3);
            "-" !== r2 && "+" !== r2 || (e3++, "-" === r2 && (i2 = true));
          }
          for (var o2 = new F(), s2 = 0, a2 = 0, u2 = 0; !(e3 >= n2); ) {
            var l2 = t2.charAt(e3);
            if (e3++, A.isDigit(l2)) {
              var c2 = l2 - "0";
              o2.selfMultiply(F.TEN), o2.selfAdd(c2), s2++;
            } else {
              if ("." !== l2) {
                if ("e" === l2 || "E" === l2) {
                  var p2 = t2.substring(e3);
                  try {
                    u2 = M.parseInt(p2);
                  } catch (e4) {
                    throw e4 instanceof Error ? new Error("Invalid exponent " + p2 + " in string " + t2) : e4;
                  }
                  break;
                }
                throw new Error("Unexpected character '" + l2 + "' at position " + e3 + " in string " + t2);
              }
              a2 = s2;
            }
          }
          var h2 = o2, f2 = s2 - a2 - u2;
          if (0 === f2)
            h2 = o2;
          else if (f2 > 0) {
            var g2 = F.TEN.pow(f2);
            h2 = o2.divide(g2);
          } else if (f2 < 0) {
            var d2 = F.TEN.pow(-f2);
            h2 = o2.multiply(d2);
          }
          return i2 ? h2.negate() : h2;
        }, F.createNaN = function() {
          return new F(v.NaN, v.NaN);
        }, F.copy = function(t2) {
          return new F(t2);
        }, F.magnitude = function(t2) {
          var e3 = Math.abs(t2), n2 = Math.log(e3) / Math.log(10), i2 = Math.trunc(Math.floor(n2));
          return 10 * Math.pow(10, i2) <= e3 && (i2 += 1), i2;
        }, F.stringOfChar = function(t2, e3) {
          for (var n2 = new D(), i2 = 0; i2 < e3; i2++)
            n2.append(t2);
          return n2.toString();
        }, G.PI.get = function() {
          return new F(3.141592653589793, 12246467991473532e-32);
        }, G.TWO_PI.get = function() {
          return new F(6.283185307179586, 24492935982947064e-32);
        }, G.PI_2.get = function() {
          return new F(1.5707963267948966, 6123233995736766e-32);
        }, G.E.get = function() {
          return new F(2.718281828459045, 14456468917292502e-32);
        }, G.NaN.get = function() {
          return new F(v.NaN, v.NaN);
        }, G.EPS.get = function() {
          return 123259516440783e-46;
        }, G.SPLIT.get = function() {
          return 134217729;
        }, G.MAX_PRINT_DIGITS.get = function() {
          return 32;
        }, G.TEN.get = function() {
          return F.valueOf(10);
        }, G.ONE.get = function() {
          return F.valueOf(1);
        }, G.SCI_NOT_EXPONENT_CHAR.get = function() {
          return "E";
        }, G.SCI_NOT_ZERO.get = function() {
          return "0.0E0";
        }, Object.defineProperties(F, G);
        var q = function() {
        }, B2 = { DP_SAFE_EPSILON: { configurable: true } };
        q.prototype.interfaces_ = function() {
          return [];
        }, q.prototype.getClass = function() {
          return q;
        }, q.orientationIndex = function(t2, e3, n2) {
          var i2 = q.orientationIndexFilter(t2, e3, n2);
          if (i2 <= 1)
            return i2;
          var r2 = F.valueOf(e3.x).selfAdd(-t2.x), o2 = F.valueOf(e3.y).selfAdd(-t2.y), s2 = F.valueOf(n2.x).selfAdd(-e3.x), a2 = F.valueOf(n2.y).selfAdd(-e3.y);
          return r2.selfMultiply(a2).selfSubtract(o2.selfMultiply(s2)).signum();
        }, q.signOfDet2x2 = function(t2, e3, n2, i2) {
          return t2.multiply(i2).selfSubtract(e3.multiply(n2)).signum();
        }, q.intersection = function(t2, e3, n2, i2) {
          var r2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(e3.x).selfSubtract(t2.x)), o2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(e3.y).selfSubtract(t2.y)), s2 = r2.subtract(o2), a2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), u2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), l2 = a2.subtract(u2).selfDivide(s2).doubleValue(), c2 = F.valueOf(t2.x).selfAdd(F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(l2)).doubleValue(), p2 = F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), h2 = F.valueOf(e3.y).selfSubtract(t2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), f2 = p2.subtract(h2).selfDivide(s2).doubleValue(), g2 = F.valueOf(n2.y).selfAdd(F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(f2)).doubleValue();
          return new C(c2, g2);
        }, q.orientationIndexFilter = function(t2, e3, n2) {
          var i2 = null, r2 = (t2.x - n2.x) * (e3.y - n2.y), o2 = (t2.y - n2.y) * (e3.x - n2.x), s2 = r2 - o2;
          if (r2 > 0) {
            if (o2 <= 0)
              return q.signum(s2);
            i2 = r2 + o2;
          } else {
            if (!(r2 < 0))
              return q.signum(s2);
            if (o2 >= 0)
              return q.signum(s2);
            i2 = -r2 - o2;
          }
          var a2 = q.DP_SAFE_EPSILON * i2;
          return s2 >= a2 || -s2 >= a2 ? q.signum(s2) : 2;
        }, q.signum = function(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }, B2.DP_SAFE_EPSILON.get = function() {
          return 1e-15;
        }, Object.defineProperties(q, B2);
        var V = function() {
        }, U = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
        U.X.get = function() {
          return 0;
        }, U.Y.get = function() {
          return 1;
        }, U.Z.get = function() {
          return 2;
        }, U.M.get = function() {
          return 3;
        }, V.prototype.setOrdinate = function(t2, e3, n2) {
        }, V.prototype.size = function() {
        }, V.prototype.getOrdinate = function(t2, e3) {
        }, V.prototype.getCoordinate = function() {
        }, V.prototype.getCoordinateCopy = function(t2) {
        }, V.prototype.getDimension = function() {
        }, V.prototype.getX = function(t2) {
        }, V.prototype.clone = function() {
        }, V.prototype.expandEnvelope = function(t2) {
        }, V.prototype.copy = function() {
        }, V.prototype.getY = function(t2) {
        }, V.prototype.toCoordinateArray = function() {
        }, V.prototype.interfaces_ = function() {
          return [x2];
        }, V.prototype.getClass = function() {
          return V;
        }, Object.defineProperties(V, U);
        var z = function() {
        }, X = function(t2) {
          function e3() {
            t2.call(this, "Projective point not representable on the Cartesian plane.");
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(z), Y = function() {
        };
        Y.arraycopy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0, s2 = e3; s2 < e3 + r2; s2++)
            n2[i2 + o2] = t2[s2], o2++;
        }, Y.getProperty = function(t2) {
          return { "line.separator": "\n" }[t2];
        };
        var k = function t2() {
          if (this.x = null, this.y = null, this.w = null, 0 === arguments.length)
            this.x = 0, this.y = 0, this.w = 1;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.w = 1;
          } else if (2 === arguments.length) {
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1];
              this.x = n2, this.y = i2, this.w = 1;
            } else if (arguments[0] instanceof t2 && arguments[1] instanceof t2) {
              var r2 = arguments[0], o2 = arguments[1];
              this.x = r2.y * o2.w - o2.y * r2.w, this.y = o2.x * r2.w - r2.x * o2.w, this.w = r2.x * o2.y - o2.x * r2.y;
            } else if (arguments[0] instanceof C && arguments[1] instanceof C) {
              var s2 = arguments[0], a2 = arguments[1];
              this.x = s2.y - a2.y, this.y = a2.x - s2.x, this.w = s2.x * a2.y - a2.x * s2.y;
            }
          } else if (3 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
            this.x = u2, this.y = l2, this.w = c2;
          } else if (4 === arguments.length) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2], g2 = arguments[3], d2 = p2.y - h2.y, y3 = h2.x - p2.x, _2 = p2.x * h2.y - h2.x * p2.y, m2 = f2.y - g2.y, v2 = g2.x - f2.x, I2 = f2.x * g2.y - g2.x * f2.y;
            this.x = y3 * I2 - v2 * _2, this.y = m2 * _2 - d2 * I2, this.w = d2 * v2 - m2 * y3;
          }
        };
        k.prototype.getY = function() {
          var t2 = this.y / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getX = function() {
          var t2 = this.x / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getCoordinate = function() {
          var t2 = new C();
          return t2.x = this.getX(), t2.y = this.getY(), t2;
        }, k.prototype.interfaces_ = function() {
          return [];
        }, k.prototype.getClass = function() {
          return k;
        }, k.intersection = function(t2, e3, n2, i2) {
          var r2 = t2.y - e3.y, o2 = e3.x - t2.x, s2 = t2.x * e3.y - e3.x * t2.y, a2 = n2.y - i2.y, u2 = i2.x - n2.x, l2 = n2.x * i2.y - i2.x * n2.y, c2 = r2 * u2 - a2 * o2, p2 = (o2 * l2 - u2 * s2) / c2, h2 = (a2 * s2 - r2 * l2) / c2;
          if (v.isNaN(p2) || v.isInfinite(p2) || v.isNaN(h2) || v.isInfinite(h2))
            throw new X();
          return new C(p2, h2);
        };
        var j = function t2() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length)
            this.init();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              this.init(e3.x, e3.x, e3.y, e3.y);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.init(i2.x, r2.x, i2.y, r2.y);
          } else if (4 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = arguments[3];
            this.init(o2, s2, a2, u2);
          }
        }, H = { serialVersionUID: { configurable: true } };
        j.prototype.getArea = function() {
          return this.getWidth() * this.getHeight();
        }, j.prototype.equals = function(t2) {
          if (!(t2 instanceof j))
            return false;
          var e3 = t2;
          return this.isNull() ? e3.isNull() : this._maxx === e3.getMaxX() && this._maxy === e3.getMaxY() && this._minx === e3.getMinX() && this._miny === e3.getMinY();
        }, j.prototype.intersection = function(t2) {
          if (this.isNull() || t2.isNull() || !this.intersects(t2))
            return new j();
          var e3 = this._minx > t2._minx ? this._minx : t2._minx, n2 = this._miny > t2._miny ? this._miny : t2._miny, i2 = this._maxx < t2._maxx ? this._maxx : t2._maxx, r2 = this._maxy < t2._maxy ? this._maxy : t2._maxy;
          return new j(e3, i2, n2, r2);
        }, j.prototype.isNull = function() {
          return this._maxx < this._minx;
        }, j.prototype.getMaxX = function() {
          return this._maxx;
        }, j.prototype.covers = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.covers(t2.x, t2.y);
            }
            if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              return !this.isNull() && !e3.isNull() && (e3.getMinX() >= this._minx && e3.getMaxX() <= this._maxx && e3.getMinY() >= this._miny && e3.getMaxY() <= this._maxy);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && (n2 >= this._minx && n2 <= this._maxx && i2 >= this._miny && i2 <= this._maxy);
          }
        }, j.prototype.intersects = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return !this.isNull() && !t2.isNull() && !(t2._minx > this._maxx || t2._maxx < this._minx || t2._miny > this._maxy || t2._maxy < this._miny);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.intersects(e3.x, e3.y);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && !(n2 > this._maxx || n2 < this._minx || i2 > this._maxy || i2 < this._miny);
          }
        }, j.prototype.getMinY = function() {
          return this._miny;
        }, j.prototype.getMinX = function() {
          return this._minx;
        }, j.prototype.expandToInclude = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.expandToInclude(t2.x, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              if (e3.isNull())
                return null;
              this.isNull() ? (this._minx = e3.getMinX(), this._maxx = e3.getMaxX(), this._miny = e3.getMinY(), this._maxy = e3.getMaxY()) : (e3._minx < this._minx && (this._minx = e3._minx), e3._maxx > this._maxx && (this._maxx = e3._maxx), e3._miny < this._miny && (this._miny = e3._miny), e3._maxy > this._maxy && (this._maxy = e3._maxy));
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.isNull() ? (this._minx = n2, this._maxx = n2, this._miny = i2, this._maxy = i2) : (n2 < this._minx && (this._minx = n2), n2 > this._maxx && (this._maxx = n2), i2 < this._miny && (this._miny = i2), i2 > this._maxy && (this._maxy = i2));
          }
        }, j.prototype.minExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 < e3 ? t2 : e3;
        }, j.prototype.getWidth = function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        }, j.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.isNull() ? e3.isNull() ? 0 : -1 : e3.isNull() ? 1 : this._minx < e3._minx ? -1 : this._minx > e3._minx ? 1 : this._miny < e3._miny ? -1 : this._miny > e3._miny ? 1 : this._maxx < e3._maxx ? -1 : this._maxx > e3._maxx ? 1 : this._maxy < e3._maxy ? -1 : this._maxy > e3._maxy ? 1 : 0;
        }, j.prototype.translate = function(t2, e3) {
          if (this.isNull())
            return null;
          this.init(this.getMinX() + t2, this.getMaxX() + t2, this.getMinY() + e3, this.getMaxY() + e3);
        }, j.prototype.toString = function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        }, j.prototype.setToNull = function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        }, j.prototype.getHeight = function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        }, j.prototype.maxExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 > e3 ? t2 : e3;
        }, j.prototype.expandBy = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.expandBy(t2, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this.isNull())
              return null;
            this._minx -= e3, this._maxx += e3, this._miny -= n2, this._maxy += n2, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        }, j.prototype.contains = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return this.covers(t2);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.covers(e3);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.covers(n2, i2);
          }
        }, j.prototype.centre = function() {
          return this.isNull() ? null : new C((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        }, j.prototype.init = function() {
          if (0 === arguments.length)
            this.setToNull();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.init(t2.x, t2.x, t2.y, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              this._minx = e3._minx, this._maxx = e3._maxx, this._miny = e3._miny, this._maxy = e3._maxy;
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.init(n2.x, i2.x, n2.y, i2.y);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            r2 < o2 ? (this._minx = r2, this._maxx = o2) : (this._minx = o2, this._maxx = r2), s2 < a2 ? (this._miny = s2, this._maxy = a2) : (this._miny = a2, this._maxy = s2);
          }
        }, j.prototype.getMaxY = function() {
          return this._maxy;
        }, j.prototype.distance = function(t2) {
          if (this.intersects(t2))
            return 0;
          var e3 = 0;
          this._maxx < t2._minx ? e3 = t2._minx - this._maxx : this._minx > t2._maxx && (e3 = this._minx - t2._maxx);
          var n2 = 0;
          return this._maxy < t2._miny ? n2 = t2._miny - this._maxy : this._miny > t2._maxy && (n2 = this._miny - t2._maxy), 0 === e3 ? n2 : 0 === n2 ? e3 : Math.sqrt(e3 * e3 + n2 * n2);
        }, j.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this._minx), t2 = 37 * t2 + C.hashCode(this._maxx), t2 = 37 * t2 + C.hashCode(this._miny), t2 = 37 * t2 + C.hashCode(this._maxy);
        }, j.prototype.interfaces_ = function() {
          return [E, e];
        }, j.prototype.getClass = function() {
          return j;
        }, j.intersects = function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return n2.x >= (t2.x < e3.x ? t2.x : e3.x) && n2.x <= (t2.x > e3.x ? t2.x : e3.x) && n2.y >= (t2.y < e3.y ? t2.y : e3.y) && n2.y <= (t2.y > e3.y ? t2.y : e3.y);
          }
          if (4 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = Math.min(o2.x, s2.x), u2 = Math.max(o2.x, s2.x), l2 = Math.min(i2.x, r2.x), c2 = Math.max(i2.x, r2.x);
            return !(l2 > u2) && (!(c2 < a2) && (a2 = Math.min(o2.y, s2.y), u2 = Math.max(o2.y, s2.y), l2 = Math.min(i2.y, r2.y), c2 = Math.max(i2.y, r2.y), !(l2 > u2) && !(c2 < a2)));
          }
        }, H.serialVersionUID.get = function() {
          return 5873921885273102e3;
        }, Object.defineProperties(j, H);
        var W = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ }, K = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        K.prototype.read = function(t2) {
          var e3, n2, i2;
          t2 = t2.replace(/[\n\r]/g, " ");
          var r2 = W.typeStr.exec(t2);
          if (-1 !== t2.search("EMPTY") && ((r2 = W.emptyTypeStr.exec(t2))[2] = void 0), r2 && (n2 = r2[1].toLowerCase(), i2 = r2[2], Q[n2] && (e3 = Q[n2].apply(this, [i2]))), void 0 === e3)
            throw new Error("Could not parse WKT " + t2);
          return e3;
        }, K.prototype.write = function(t2) {
          return this.extractGeometry(t2);
        }, K.prototype.extractGeometry = function(t2) {
          var e3 = t2.getGeometryType().toLowerCase();
          if (!J[e3])
            return null;
          var n2 = e3.toUpperCase();
          return t2.isEmpty() ? n2 + " EMPTY" : n2 + "(" + J[e3].apply(this, [t2]) + ")";
        };
        var J = { coordinate: function(t2) {
          return t2.x + " " + t2.y;
        }, point: function(t2) {
          return J.coordinate.call(this, t2._coordinates._coordinates[0]);
        }, multipoint: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.point.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, linestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, linearring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, multilinestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, polygon: function(t2) {
          var e3 = [];
          e3.push("(" + J.linestring.apply(this, [t2._shell]) + ")");
          for (var n2 = 0, i2 = t2._holes.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._holes[n2]]) + ")");
          return e3.join(",");
        }, multipolygon: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.polygon.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, geometrycollection: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push(this.extractGeometry(t2._geometries[n2]));
          return e3.join(",");
        } }, Q = { point: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createPoint();
          var e3 = t2.trim().split(W.spaces);
          return this.geometryFactory.createPoint(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
        }, multipoint: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiPoint();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.point.apply(this, [e3]));
          return this.geometryFactory.createMultiPoint(i2);
        }, linestring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createLineString();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLineString(i2);
        }, linearring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createLinearRing();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLinearRing(i2);
        }, multilinestring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiLineString();
          for (var e3, n2 = t2.trim().split(W.parenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.linestring.apply(this, [e3]));
          return this.geometryFactory.createMultiLineString(i2);
        }, polygon: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createPolygon();
          for (var e3, n2, i2, r2, o2 = t2.trim().split(W.parenComma), s2 = [], a2 = 0, u2 = o2.length; a2 < u2; ++a2)
            e3 = o2[a2].replace(W.trimParens, "$1"), n2 = Q.linestring.apply(this, [e3]), i2 = this.geometryFactory.createLinearRing(n2._points), 0 === a2 ? r2 = i2 : s2.push(i2);
          return this.geometryFactory.createPolygon(r2, s2);
        }, multipolygon: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiPolygon();
          for (var e3, n2 = t2.trim().split(W.doubleParenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.polygon.apply(this, [e3]));
          return this.geometryFactory.createMultiPolygon(i2);
        }, geometrycollection: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createGeometryCollection();
          for (var e3 = (t2 = t2.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n2 = [], i2 = 0, r2 = e3.length; i2 < r2; ++i2)
            n2.push(this.read(e3[i2]));
          return this.geometryFactory.createGeometryCollection(n2);
        } }, Z = function(t2) {
          this.parser = new K(t2);
        };
        Z.prototype.write = function(t2) {
          return this.parser.write(t2);
        }, Z.toLineString = function(t2, e3) {
          if (2 !== arguments.length)
            throw new Error("Not implemented");
          return "LINESTRING ( " + t2.x + " " + t2.y + ", " + e3.x + " " + e3.y + " )";
        };
        var $ = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "RuntimeException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), tt = function(t2) {
          function e3() {
            if (t2.call(this), 0 === arguments.length)
              t2.call(this);
            else if (1 === arguments.length) {
              var e4 = arguments[0];
              t2.call(this, e4);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }($), et = function() {
        };
        et.prototype.interfaces_ = function() {
          return [];
        }, et.prototype.getClass = function() {
          return et;
        }, et.shouldNeverReachHere = function() {
          if (0 === arguments.length)
            et.shouldNeverReachHere(null);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            throw new tt("Should never reach here" + (null !== t2 ? ": " + t2 : ""));
          }
        }, et.isTrue = function() {
          var t2, e3;
          if (1 === arguments.length)
            t2 = arguments[0], et.isTrue(t2, null);
          else if (2 === arguments.length && (t2 = arguments[0], e3 = arguments[1], !t2))
            throw null === e3 ? new tt() : new tt(e3);
        }, et.equals = function() {
          var t2, e3, n2;
          if (2 === arguments.length)
            t2 = arguments[0], e3 = arguments[1], et.equals(t2, e3, null);
          else if (3 === arguments.length && (t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], !e3.equals(t2)))
            throw new tt("Expected " + t2 + " but encountered " + e3 + (null !== n2 ? ": " + n2 : ""));
        };
        var nt = function() {
          this._result = null, this._inputLines = Array(2).fill().map(function() {
            return Array(2);
          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new C(), this._intPt[1] = new C(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        }, it = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
        nt.prototype.getIndexAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intLineIndex[t2][e3];
        }, nt.prototype.getTopologySummary = function() {
          var t2 = new D();
          return this.isEndPoint() && t2.append(" endpoint"), this._isProper && t2.append(" proper"), this.isCollinear() && t2.append(" collinear"), t2.toString();
        }, nt.prototype.computeIntersection = function(t2, e3, n2, i2) {
          this._inputLines[0][0] = t2, this._inputLines[0][1] = e3, this._inputLines[1][0] = n2, this._inputLines[1][1] = i2, this._result = this.computeIntersect(t2, e3, n2, i2);
        }, nt.prototype.getIntersectionNum = function() {
          return this._result;
        }, nt.prototype.computeIntLineIndex = function() {
          if (0 === arguments.length)
            null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function() {
              return Array(2);
            }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.getEdgeDistance(t2, 0) > this.getEdgeDistance(t2, 1) ? (this._intLineIndex[t2][0] = 0, this._intLineIndex[t2][1] = 1) : (this._intLineIndex[t2][0] = 1, this._intLineIndex[t2][1] = 0);
          }
        }, nt.prototype.isProper = function() {
          return this.hasIntersection() && this._isProper;
        }, nt.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, nt.prototype.isInteriorIntersection = function() {
          if (0 === arguments.length)
            return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._result; e3++)
              if (!this._intPt[e3].equals2D(this._inputLines[t2][0]) && !this._intPt[e3].equals2D(this._inputLines[t2][1]))
                return true;
            return false;
          }
        }, nt.prototype.getIntersection = function(t2) {
          return this._intPt[t2];
        }, nt.prototype.isEndPoint = function() {
          return this.hasIntersection() && !this._isProper;
        }, nt.prototype.hasIntersection = function() {
          return this._result !== nt.NO_INTERSECTION;
        }, nt.prototype.getEdgeDistance = function(t2, e3) {
          return nt.computeEdgeDistance(this._intPt[e3], this._inputLines[t2][0], this._inputLines[t2][1]);
        }, nt.prototype.isCollinear = function() {
          return this._result === nt.COLLINEAR_INTERSECTION;
        }, nt.prototype.toString = function() {
          return Z.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Z.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        }, nt.prototype.getEndpoint = function(t2, e3) {
          return this._inputLines[t2][e3];
        }, nt.prototype.isIntersection = function(t2) {
          for (var e3 = 0; e3 < this._result; e3++)
            if (this._intPt[e3].equals2D(t2))
              return true;
          return false;
        }, nt.prototype.getIntersectionAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t2][e3]];
        }, nt.prototype.interfaces_ = function() {
          return [];
        }, nt.prototype.getClass = function() {
          return nt;
        }, nt.computeEdgeDistance = function(t2, e3, n2) {
          var i2 = Math.abs(n2.x - e3.x), r2 = Math.abs(n2.y - e3.y), o2 = -1;
          if (t2.equals(e3))
            o2 = 0;
          else if (t2.equals(n2))
            o2 = i2 > r2 ? i2 : r2;
          else {
            var s2 = Math.abs(t2.x - e3.x), a2 = Math.abs(t2.y - e3.y);
            0 !== (o2 = i2 > r2 ? s2 : a2) || t2.equals(e3) || (o2 = Math.max(s2, a2));
          }
          return et.isTrue(!(0 === o2 && !t2.equals(e3)), "Bad distance calculation"), o2;
        }, nt.nonRobustComputeEdgeDistance = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y, o2 = Math.sqrt(i2 * i2 + r2 * r2);
          return et.isTrue(!(0 === o2 && !t2.equals(e3)), "Invalid distance calculation"), o2;
        }, it.DONT_INTERSECT.get = function() {
          return 0;
        }, it.DO_INTERSECT.get = function() {
          return 1;
        }, it.COLLINEAR.get = function() {
          return 2;
        }, it.NO_INTERSECTION.get = function() {
          return 0;
        }, it.POINT_INTERSECTION.get = function() {
          return 1;
        }, it.COLLINEAR_INTERSECTION.get = function() {
          return 2;
        }, Object.defineProperties(nt, it);
        var rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isInSegmentEnvelopes = function(t3) {
            var e4 = new j(this._inputLines[0][0], this._inputLines[0][1]), n2 = new j(this._inputLines[1][0], this._inputLines[1][1]);
            return e4.contains(t3) && n2.contains(t3);
          }, e3.prototype.computeIntersection = function() {
            if (3 !== arguments.length)
              return t2.prototype.computeIntersection.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (this._isProper = false, j.intersects(n2, i2, e4) && 0 === at.orientationIndex(n2, i2, e4) && 0 === at.orientationIndex(i2, n2, e4))
              return this._isProper = true, (e4.equals(n2) || e4.equals(i2)) && (this._isProper = false), this._result = t2.POINT_INTERSECTION, null;
            this._result = t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToMinimum = function(t3, e4, n2, i2, r2) {
            r2.x = this.smallestInAbsValue(t3.x, e4.x, n2.x, i2.x), r2.y = this.smallestInAbsValue(t3.y, e4.y, n2.y, i2.y), t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.safeHCoordinateIntersection = function(t3, n2, i2, r2) {
            var o2 = null;
            try {
              o2 = k.intersection(t3, n2, i2, r2);
            } catch (s2) {
              if (!(s2 instanceof X))
                throw s2;
              o2 = e3.nearestEndpoint(t3, n2, i2, r2);
            }
            return o2;
          }, e3.prototype.intersection = function(t3, n2, i2, r2) {
            var o2 = this.intersectionWithNormalization(t3, n2, i2, r2);
            return this.isInSegmentEnvelopes(o2) || (o2 = new C(e3.nearestEndpoint(t3, n2, i2, r2))), null !== this._precisionModel && this._precisionModel.makePrecise(o2), o2;
          }, e3.prototype.smallestInAbsValue = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = Math.abs(r2);
            return Math.abs(e4) < o2 && (r2 = e4, o2 = Math.abs(e4)), Math.abs(n2) < o2 && (r2 = n2, o2 = Math.abs(n2)), Math.abs(i2) < o2 && (r2 = i2), r2;
          }, e3.prototype.checkDD = function(t3, e4, n2, i2, r2) {
            var o2 = q.intersection(t3, e4, n2, i2), s2 = this.isInSegmentEnvelopes(o2);
            Y.out.println("DD in env = " + s2 + "  --------------------- " + o2), r2.distance(o2) > 1e-4 && Y.out.println("Distance = " + r2.distance(o2));
          }, e3.prototype.intersectionWithNormalization = function(t3, e4, n2, i2) {
            var r2 = new C(t3), o2 = new C(e4), s2 = new C(n2), a2 = new C(i2), u2 = new C();
            this.normalizeToEnvCentre(r2, o2, s2, a2, u2);
            var l2 = this.safeHCoordinateIntersection(r2, o2, s2, a2);
            return l2.x += u2.x, l2.y += u2.y, l2;
          }, e3.prototype.computeCollinearIntersection = function(e4, n2, i2, r2) {
            var o2 = j.intersects(e4, n2, i2), s2 = j.intersects(e4, n2, r2), a2 = j.intersects(i2, r2, e4), u2 = j.intersects(i2, r2, n2);
            return o2 && s2 ? (this._intPt[0] = i2, this._intPt[1] = r2, t2.COLLINEAR_INTERSECTION) : a2 && u2 ? (this._intPt[0] = e4, this._intPt[1] = n2, t2.COLLINEAR_INTERSECTION) : o2 && a2 ? (this._intPt[0] = i2, this._intPt[1] = e4, !i2.equals(e4) || s2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : o2 && u2 ? (this._intPt[0] = i2, this._intPt[1] = n2, !i2.equals(n2) || s2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && a2 ? (this._intPt[0] = r2, this._intPt[1] = e4, !r2.equals(e4) || o2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && u2 ? (this._intPt[0] = r2, this._intPt[1] = n2, !r2.equals(n2) || o2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToEnvCentre = function(t3, e4, n2, i2, r2) {
            var o2 = t3.x < e4.x ? t3.x : e4.x, s2 = t3.y < e4.y ? t3.y : e4.y, a2 = t3.x > e4.x ? t3.x : e4.x, u2 = t3.y > e4.y ? t3.y : e4.y, l2 = n2.x < i2.x ? n2.x : i2.x, c2 = n2.y < i2.y ? n2.y : i2.y, p2 = n2.x > i2.x ? n2.x : i2.x, h2 = n2.y > i2.y ? n2.y : i2.y, f2 = ((o2 > l2 ? o2 : l2) + (a2 < p2 ? a2 : p2)) / 2, g2 = ((s2 > c2 ? s2 : c2) + (u2 < h2 ? u2 : h2)) / 2;
            r2.x = f2, r2.y = g2, t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.computeIntersect = function(e4, n2, i2, r2) {
            if (this._isProper = false, !j.intersects(e4, n2, i2, r2))
              return t2.NO_INTERSECTION;
            var o2 = at.orientationIndex(e4, n2, i2), s2 = at.orientationIndex(e4, n2, r2);
            if (o2 > 0 && s2 > 0 || o2 < 0 && s2 < 0)
              return t2.NO_INTERSECTION;
            var a2 = at.orientationIndex(i2, r2, e4), u2 = at.orientationIndex(i2, r2, n2);
            if (a2 > 0 && u2 > 0 || a2 < 0 && u2 < 0)
              return t2.NO_INTERSECTION;
            return 0 === o2 && 0 === s2 && 0 === a2 && 0 === u2 ? this.computeCollinearIntersection(e4, n2, i2, r2) : (0 === o2 || 0 === s2 || 0 === a2 || 0 === u2 ? (this._isProper = false, e4.equals2D(i2) || e4.equals2D(r2) ? this._intPt[0] = e4 : n2.equals2D(i2) || n2.equals2D(r2) ? this._intPt[0] = n2 : 0 === o2 ? this._intPt[0] = new C(i2) : 0 === s2 ? this._intPt[0] = new C(r2) : 0 === a2 ? this._intPt[0] = new C(e4) : 0 === u2 && (this._intPt[0] = new C(n2))) : (this._isProper = true, this._intPt[0] = this.intersection(e4, n2, i2, r2)), t2.POINT_INTERSECTION);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.nearestEndpoint = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = at.distancePointLine(t3, n2, i2), s2 = at.distancePointLine(e4, n2, i2);
            return s2 < o2 && (o2 = s2, r2 = e4), (s2 = at.distancePointLine(n2, t3, e4)) < o2 && (o2 = s2, r2 = n2), (s2 = at.distancePointLine(i2, t3, e4)) < o2 && (o2 = s2, r2 = i2), r2;
          }, e3;
        }(nt), ot = function() {
        };
        ot.prototype.interfaces_ = function() {
          return [];
        }, ot.prototype.getClass = function() {
          return ot;
        }, ot.orientationIndex = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = n2.x - e3.x, s2 = n2.y - e3.y;
          return ot.signOfDet2x2(i2, r2, o2, s2);
        }, ot.signOfDet2x2 = function(t2, e3, n2, i2) {
          var r2 = null, o2 = null, s2 = null;
          if (r2 = 1, 0 === t2 || 0 === i2)
            return 0 === e3 || 0 === n2 ? 0 : e3 > 0 ? n2 > 0 ? -r2 : r2 : n2 > 0 ? r2 : -r2;
          if (0 === e3 || 0 === n2)
            return i2 > 0 ? t2 > 0 ? r2 : -r2 : t2 > 0 ? -r2 : r2;
          if (e3 > 0 ? i2 > 0 ? e3 <= i2 || (r2 = -r2, o2 = t2, t2 = n2, n2 = o2, o2 = e3, e3 = i2, i2 = o2) : e3 <= -i2 ? (r2 = -r2, n2 = -n2, i2 = -i2) : (o2 = t2, t2 = -n2, n2 = o2, o2 = e3, e3 = -i2, i2 = o2) : i2 > 0 ? -e3 <= i2 ? (r2 = -r2, t2 = -t2, e3 = -e3) : (o2 = -t2, t2 = n2, n2 = o2, o2 = -e3, e3 = i2, i2 = o2) : e3 >= i2 ? (t2 = -t2, e3 = -e3, n2 = -n2, i2 = -i2) : (r2 = -r2, o2 = -t2, t2 = -n2, n2 = o2, o2 = -e3, e3 = -i2, i2 = o2), t2 > 0) {
            if (!(n2 > 0))
              return r2;
            if (!(t2 <= n2))
              return r2;
          } else {
            if (n2 > 0)
              return -r2;
            if (!(t2 >= n2))
              return -r2;
            r2 = -r2, t2 = -t2, n2 = -n2;
          }
          for (; ; ) {
            if (s2 = Math.floor(n2 / t2), n2 -= s2 * t2, (i2 -= s2 * e3) < 0)
              return -r2;
            if (i2 > e3)
              return r2;
            if (t2 > n2 + n2) {
              if (e3 < i2 + i2)
                return r2;
            } else {
              if (e3 > i2 + i2)
                return -r2;
              n2 = t2 - n2, i2 = e3 - i2, r2 = -r2;
            }
            if (0 === i2)
              return 0 === n2 ? 0 : -r2;
            if (0 === n2)
              return r2;
            if (s2 = Math.floor(t2 / n2), t2 -= s2 * n2, (e3 -= s2 * i2) < 0)
              return r2;
            if (e3 > i2)
              return -r2;
            if (n2 > t2 + t2) {
              if (i2 < e3 + e3)
                return -r2;
            } else {
              if (i2 > e3 + e3)
                return r2;
              t2 = n2 - t2, e3 = i2 - e3, r2 = -r2;
            }
            if (0 === e3)
              return 0 === t2 ? 0 : r2;
            if (0 === t2)
              return -r2;
          }
        };
        var st = function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
          var t2 = arguments[0];
          this._p = t2;
        };
        st.prototype.countSegment = function(t2, e3) {
          if (t2.x < this._p.x && e3.x < this._p.x)
            return null;
          if (this._p.x === e3.x && this._p.y === e3.y)
            return this._isPointOnSegment = true, null;
          if (t2.y === this._p.y && e3.y === this._p.y) {
            var n2 = t2.x, i2 = e3.x;
            return n2 > i2 && (n2 = e3.x, i2 = t2.x), this._p.x >= n2 && this._p.x <= i2 && (this._isPointOnSegment = true), null;
          }
          if (t2.y > this._p.y && e3.y <= this._p.y || e3.y > this._p.y && t2.y <= this._p.y) {
            var r2 = t2.x - this._p.x, o2 = t2.y - this._p.y, s2 = e3.x - this._p.x, a2 = e3.y - this._p.y, u2 = ot.signOfDet2x2(r2, o2, s2, a2);
            if (0 === u2)
              return this._isPointOnSegment = true, null;
            a2 < o2 && (u2 = -u2), u2 > 0 && this._crossingCount++;
          }
        }, st.prototype.isPointInPolygon = function() {
          return this.getLocation() !== w.EXTERIOR;
        }, st.prototype.getLocation = function() {
          return this._isPointOnSegment ? w.BOUNDARY : this._crossingCount % 2 == 1 ? w.INTERIOR : w.EXTERIOR;
        }, st.prototype.isOnSegment = function() {
          return this._isPointOnSegment;
        }, st.prototype.interfaces_ = function() {
          return [];
        }, st.prototype.getClass = function() {
          return st;
        }, st.locatePointInRing = function() {
          if (arguments[0] instanceof C && T(arguments[1], V)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new st(t2), i2 = new C(), r2 = new C(), o2 = 1; o2 < e3.size(); o2++)
              if (e3.getCoordinate(o2, i2), e3.getCoordinate(o2 - 1, r2), n2.countSegment(i2, r2), n2.isOnSegment())
                return n2.getLocation();
            return n2.getLocation();
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Array) {
            for (var s2 = arguments[0], a2 = arguments[1], u2 = new st(s2), l2 = 1; l2 < a2.length; l2++) {
              var c2 = a2[l2], p2 = a2[l2 - 1];
              if (u2.countSegment(c2, p2), u2.isOnSegment())
                return u2.getLocation();
            }
            return u2.getLocation();
          }
        };
        var at = function() {
        }, ut = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
        at.prototype.interfaces_ = function() {
          return [];
        }, at.prototype.getClass = function() {
          return at;
        }, at.orientationIndex = function(t2, e3, n2) {
          return q.orientationIndex(t2, e3, n2);
        }, at.signedArea = function() {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            if (t2.length < 3)
              return 0;
            for (var e3 = 0, n2 = t2[0].x, i2 = 1; i2 < t2.length - 1; i2++) {
              var r2 = t2[i2].x - n2, o2 = t2[i2 + 1].y;
              e3 += r2 * (t2[i2 - 1].y - o2);
            }
            return e3 / 2;
          }
          if (T(arguments[0], V)) {
            var s2 = arguments[0], a2 = s2.size();
            if (a2 < 3)
              return 0;
            var u2 = new C(), l2 = new C(), c2 = new C();
            s2.getCoordinate(0, l2), s2.getCoordinate(1, c2);
            var p2 = l2.x;
            c2.x -= p2;
            for (var h2 = 0, f2 = 1; f2 < a2 - 1; f2++)
              u2.y = l2.y, l2.x = c2.x, l2.y = c2.y, s2.getCoordinate(f2 + 1, c2), c2.x -= p2, h2 += l2.x * (u2.y - c2.y);
            return h2 / 2;
          }
        }, at.distanceLineLine = function(t2, e3, n2, i2) {
          if (t2.equals(e3))
            return at.distancePointLine(t2, n2, i2);
          if (n2.equals(i2))
            return at.distancePointLine(i2, t2, e3);
          var r2 = false;
          if (j.intersects(t2, e3, n2, i2)) {
            var o2 = (e3.x - t2.x) * (i2.y - n2.y) - (e3.y - t2.y) * (i2.x - n2.x);
            if (0 === o2)
              r2 = true;
            else {
              var s2 = (t2.y - n2.y) * (i2.x - n2.x) - (t2.x - n2.x) * (i2.y - n2.y), a2 = ((t2.y - n2.y) * (e3.x - t2.x) - (t2.x - n2.x) * (e3.y - t2.y)) / o2, u2 = s2 / o2;
              (u2 < 0 || u2 > 1 || a2 < 0 || a2 > 1) && (r2 = true);
            }
          } else
            r2 = true;
          return r2 ? R.min(at.distancePointLine(t2, n2, i2), at.distancePointLine(e3, n2, i2), at.distancePointLine(n2, t2, e3), at.distancePointLine(i2, t2, e3)) : 0;
        }, at.isPointInRing = function(t2, e3) {
          return at.locatePointInRing(t2, e3) !== w.EXTERIOR;
        }, at.computeLength = function(t2) {
          var e3 = t2.size();
          if (e3 <= 1)
            return 0;
          var n2 = 0, i2 = new C();
          t2.getCoordinate(0, i2);
          for (var r2 = i2.x, o2 = i2.y, s2 = 1; s2 < e3; s2++) {
            t2.getCoordinate(s2, i2);
            var a2 = i2.x, u2 = i2.y, l2 = a2 - r2, c2 = u2 - o2;
            n2 += Math.sqrt(l2 * l2 + c2 * c2), r2 = a2, o2 = u2;
          }
          return n2;
        }, at.isCCW = function(t2) {
          var e3 = t2.length - 1;
          if (e3 < 3)
            throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
          for (var n2 = t2[0], i2 = 0, r2 = 1; r2 <= e3; r2++) {
            var o2 = t2[r2];
            o2.y > n2.y && (n2 = o2, i2 = r2);
          }
          var s2 = i2;
          do {
            (s2 -= 1) < 0 && (s2 = e3);
          } while (t2[s2].equals2D(n2) && s2 !== i2);
          var a2 = i2;
          do {
            a2 = (a2 + 1) % e3;
          } while (t2[a2].equals2D(n2) && a2 !== i2);
          var u2 = t2[s2], l2 = t2[a2];
          if (u2.equals2D(n2) || l2.equals2D(n2) || u2.equals2D(l2))
            return false;
          var c2 = at.computeOrientation(u2, n2, l2), p2 = false;
          return p2 = 0 === c2 ? u2.x > l2.x : c2 > 0, p2;
        }, at.locatePointInRing = function(t2, e3) {
          return st.locatePointInRing(t2, e3);
        }, at.distancePointLinePerpendicular = function(t2, e3, n2) {
          var i2 = (n2.x - e3.x) * (n2.x - e3.x) + (n2.y - e3.y) * (n2.y - e3.y), r2 = ((e3.y - t2.y) * (n2.x - e3.x) - (e3.x - t2.x) * (n2.y - e3.y)) / i2;
          return Math.abs(r2) * Math.sqrt(i2);
        }, at.computeOrientation = function(t2, e3, n2) {
          return at.orientationIndex(t2, e3, n2);
        }, at.distancePointLine = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === e3.length)
              throw new m("Line array must contain at least one vertex");
            for (var n2 = t2.distance(e3[0]), i2 = 0; i2 < e3.length - 1; i2++) {
              var r2 = at.distancePointLine(t2, e3[i2], e3[i2 + 1]);
              r2 < n2 && (n2 = r2);
            }
            return n2;
          }
          if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            if (s2.x === a2.x && s2.y === a2.y)
              return o2.distance(s2);
            var u2 = (a2.x - s2.x) * (a2.x - s2.x) + (a2.y - s2.y) * (a2.y - s2.y), l2 = ((o2.x - s2.x) * (a2.x - s2.x) + (o2.y - s2.y) * (a2.y - s2.y)) / u2;
            if (l2 <= 0)
              return o2.distance(s2);
            if (l2 >= 1)
              return o2.distance(a2);
            var c2 = ((s2.y - o2.y) * (a2.x - s2.x) - (s2.x - o2.x) * (a2.y - s2.y)) / u2;
            return Math.abs(c2) * Math.sqrt(u2);
          }
        }, at.isOnLine = function(t2, e3) {
          for (var n2 = new rt(), i2 = 1; i2 < e3.length; i2++) {
            var r2 = e3[i2 - 1], o2 = e3[i2];
            if (n2.computeIntersection(t2, r2, o2), n2.hasIntersection())
              return true;
          }
          return false;
        }, ut.CLOCKWISE.get = function() {
          return -1;
        }, ut.RIGHT.get = function() {
          return at.CLOCKWISE;
        }, ut.COUNTERCLOCKWISE.get = function() {
          return 1;
        }, ut.LEFT.get = function() {
          return at.COUNTERCLOCKWISE;
        }, ut.COLLINEAR.get = function() {
          return 0;
        }, ut.STRAIGHT.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(at, ut);
        var lt = function() {
        };
        lt.prototype.filter = function(t2) {
        }, lt.prototype.interfaces_ = function() {
          return [];
        }, lt.prototype.getClass = function() {
          return lt;
        };
        var ct = function() {
          var t2 = arguments[0];
          this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t2, this._SRID = t2.getSRID();
        }, pt = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
        ct.prototype.isGeometryCollection = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION;
        }, ct.prototype.getFactory = function() {
          return this._factory;
        }, ct.prototype.getGeometryN = function(t2) {
          return this;
        }, ct.prototype.getArea = function() {
          return 0;
        }, ct.prototype.isRectangle = function() {
          return false;
        }, ct.prototype.equals = function() {
          if (arguments[0] instanceof ct) {
            var t2 = arguments[0];
            return null !== t2 && this.equalsTopo(t2);
          }
          if (arguments[0] instanceof Object) {
            var e3 = arguments[0];
            if (!(e3 instanceof ct))
              return false;
            var n2 = e3;
            return this.equalsExact(n2);
          }
        }, ct.prototype.equalsExact = function(t2) {
          return this === t2 || this.equalsExact(t2, 0);
        }, ct.prototype.geometryChanged = function() {
          this.apply(ct.geometryChangedFilter);
        }, ct.prototype.geometryChangedAction = function() {
          this._envelope = null;
        }, ct.prototype.equalsNorm = function(t2) {
          return null !== t2 && this.norm().equalsExact(t2.norm());
        }, ct.prototype.getLength = function() {
          return 0;
        }, ct.prototype.getNumGeometries = function() {
          return 1;
        }, ct.prototype.compareTo = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = t2;
            return this.getSortIndex() !== e3.getSortIndex() ? this.getSortIndex() - e3.getSortIndex() : this.isEmpty() && e3.isEmpty() ? 0 : this.isEmpty() ? -1 : e3.isEmpty() ? 1 : this.compareToSameClass(t2);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.getSortIndex() !== n2.getSortIndex() ? this.getSortIndex() - n2.getSortIndex() : this.isEmpty() && n2.isEmpty() ? 0 : this.isEmpty() ? -1 : n2.isEmpty() ? 1 : this.compareToSameClass(n2, i2);
          }
        }, ct.prototype.getUserData = function() {
          return this._userData;
        }, ct.prototype.getSRID = function() {
          return this._SRID;
        }, ct.prototype.getEnvelope = function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        }, ct.prototype.checkNotGeometryCollection = function(t2) {
          if (t2.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION)
            throw new m("This method does not support GeometryCollection arguments");
        }, ct.prototype.equal = function(t2, e3, n2) {
          return 0 === n2 ? t2.equals(e3) : t2.distance(e3) <= n2;
        }, ct.prototype.norm = function() {
          var t2 = this.copy();
          return t2.normalize(), t2;
        }, ct.prototype.getPrecisionModel = function() {
          return this._factory.getPrecisionModel();
        }, ct.prototype.getEnvelopeInternal = function() {
          return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new j(this._envelope);
        }, ct.prototype.setSRID = function(t2) {
          this._SRID = t2;
        }, ct.prototype.setUserData = function(t2) {
          this._userData = t2;
        }, ct.prototype.compare = function(t2, e3) {
          for (var n2 = t2.iterator(), i2 = e3.iterator(); n2.hasNext() && i2.hasNext(); ) {
            var r2 = n2.next(), o2 = i2.next(), s2 = r2.compareTo(o2);
            if (0 !== s2)
              return s2;
          }
          return n2.hasNext() ? 1 : i2.hasNext() ? -1 : 0;
        }, ct.prototype.hashCode = function() {
          return this.getEnvelopeInternal().hashCode();
        }, ct.prototype.isGeometryCollectionOrDerived = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === ct.SORTINDEX_MULTIPOINT || this.getSortIndex() === ct.SORTINDEX_MULTILINESTRING || this.getSortIndex() === ct.SORTINDEX_MULTIPOLYGON;
        }, ct.prototype.interfaces_ = function() {
          return [x2, E, e];
        }, ct.prototype.getClass = function() {
          return ct;
        }, ct.hasNonEmptyElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (!t2[e3].isEmpty())
              return true;
          return false;
        }, ct.hasNullElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (null === t2[e3])
              return true;
          return false;
        }, pt.serialVersionUID.get = function() {
          return 8763622679187377e3;
        }, pt.SORTINDEX_POINT.get = function() {
          return 0;
        }, pt.SORTINDEX_MULTIPOINT.get = function() {
          return 1;
        }, pt.SORTINDEX_LINESTRING.get = function() {
          return 2;
        }, pt.SORTINDEX_LINEARRING.get = function() {
          return 3;
        }, pt.SORTINDEX_MULTILINESTRING.get = function() {
          return 4;
        }, pt.SORTINDEX_POLYGON.get = function() {
          return 5;
        }, pt.SORTINDEX_MULTIPOLYGON.get = function() {
          return 6;
        }, pt.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
          return 7;
        }, pt.geometryChangedFilter.get = function() {
          return ht;
        }, Object.defineProperties(ct, pt);
        var ht = function() {
        };
        ht.interfaces_ = function() {
          return [lt];
        }, ht.filter = function(t2) {
          t2.geometryChangedAction();
        };
        var ft = function() {
        };
        ft.prototype.filter = function(t2) {
        }, ft.prototype.interfaces_ = function() {
          return [];
        }, ft.prototype.getClass = function() {
          return ft;
        };
        var gt = function() {
        }, dt = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
        gt.prototype.isInBoundary = function(t2) {
        }, gt.prototype.interfaces_ = function() {
          return [];
        }, gt.prototype.getClass = function() {
          return gt;
        }, dt.Mod2BoundaryNodeRule.get = function() {
          return yt;
        }, dt.EndPointBoundaryNodeRule.get = function() {
          return _t;
        }, dt.MultiValentEndPointBoundaryNodeRule.get = function() {
          return mt;
        }, dt.MonoValentEndPointBoundaryNodeRule.get = function() {
          return vt;
        }, dt.MOD2_BOUNDARY_RULE.get = function() {
          return new yt();
        }, dt.ENDPOINT_BOUNDARY_RULE.get = function() {
          return new _t();
        }, dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new mt();
        }, dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new vt();
        }, dt.OGC_SFS_BOUNDARY_RULE.get = function() {
          return gt.MOD2_BOUNDARY_RULE;
        }, Object.defineProperties(gt, dt);
        var yt = function() {
        };
        yt.prototype.isInBoundary = function(t2) {
          return t2 % 2 == 1;
        }, yt.prototype.interfaces_ = function() {
          return [gt];
        }, yt.prototype.getClass = function() {
          return yt;
        };
        var _t = function() {
        };
        _t.prototype.isInBoundary = function(t2) {
          return t2 > 0;
        }, _t.prototype.interfaces_ = function() {
          return [gt];
        }, _t.prototype.getClass = function() {
          return _t;
        };
        var mt = function() {
        };
        mt.prototype.isInBoundary = function(t2) {
          return t2 > 1;
        }, mt.prototype.interfaces_ = function() {
          return [gt];
        }, mt.prototype.getClass = function() {
          return mt;
        };
        var vt = function() {
        };
        vt.prototype.isInBoundary = function(t2) {
          return 1 === t2;
        }, vt.prototype.interfaces_ = function() {
          return [gt];
        }, vt.prototype.getClass = function() {
          return vt;
        };
        var It = function() {
        };
        It.prototype.add = function() {
        }, It.prototype.addAll = function() {
        }, It.prototype.isEmpty = function() {
        }, It.prototype.iterator = function() {
        }, It.prototype.size = function() {
        }, It.prototype.toArray = function() {
        }, It.prototype.remove = function() {
        }, (n.prototype = new Error()).name = "IndexOutOfBoundsException";
        var Et = function() {
        };
        Et.prototype.hasNext = function() {
        }, Et.prototype.next = function() {
        }, Et.prototype.remove = function() {
        };
        var xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function() {
          }, e3.prototype.set = function() {
          }, e3.prototype.isEmpty = function() {
          }, e3;
        }(It);
        (i.prototype = new Error()).name = "NoSuchElementException";
        var Nt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.ensureCapacity = function() {
          }, e3.prototype.interfaces_ = function() {
            return [t2, It];
          }, e3.prototype.add = function(t3) {
            return 1 === arguments.length ? this.array_.push(t3) : this.array_.splice(arguments[0], arguments[1]), true;
          }, e3.prototype.clear = function() {
            this.array_ = [];
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.set = function(t3, e4) {
            var n2 = this.array_[t3];
            return this.array_[t3] = e4, n2;
          }, e3.prototype.iterator = function() {
            return new Ct(this);
          }, e3.prototype.get = function(t3) {
            if (t3 < 0 || t3 >= this.size())
              throw new n();
            return this.array_[t3];
          }, e3.prototype.isEmpty = function() {
            return 0 === this.array_.length;
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.remove = function(t3) {
            for (var e4 = false, n2 = 0, i2 = this.array_.length; n2 < i2; n2++)
              if (this.array_[n2] === t3) {
                this.array_.splice(n2, 1), e4 = true;
                break;
              }
            return e4;
          }, e3;
        }(xt), Ct = function(t2) {
          function e3(e4) {
            t2.call(this), this.arrayList_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.arrayList_.size())
              throw new i();
            return this.arrayList_.get(this.position_++);
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.arrayList_.size();
          }, e3.prototype.set = function(t3) {
            return this.arrayList_.set(this.position_ - 1, t3);
          }, e3.prototype.remove = function() {
            this.arrayList_.remove(this.arrayList_.get(this.position_));
          }, e3;
        }(Et), St = function(t2) {
          function e3() {
            if (t2.call(this), 0 === arguments.length)
              ;
            else if (1 === arguments.length) {
              var e4 = arguments[0];
              this.ensureCapacity(e4.length), this.add(e4, true);
            } else if (2 === arguments.length) {
              var n3 = arguments[0], i2 = arguments[1];
              this.ensureCapacity(n3.length), this.add(n3, i2);
            }
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { coordArrayType: { configurable: true } };
          return n2.coordArrayType.get = function() {
            return new Array(0).fill(null);
          }, e3.prototype.getCoordinate = function(t3) {
            return this.get(t3);
          }, e3.prototype.addAll = function() {
            if (2 === arguments.length) {
              for (var e4 = arguments[0], n3 = arguments[1], i2 = false, r2 = e4.iterator(); r2.hasNext(); )
                this.add(r2.next(), n3), i2 = true;
              return i2;
            }
            return t2.prototype.addAll.apply(this, arguments);
          }, e3.prototype.clone = function() {
            for (var e4 = t2.prototype.clone.call(this), n3 = 0; n3 < this.size(); n3++)
              e4.add(n3, this.get(n3).copy());
            return e4;
          }, e3.prototype.toCoordinateArray = function() {
            return this.toArray(e3.coordArrayType);
          }, e3.prototype.add = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              t2.prototype.add.call(this, e4);
            } else if (2 === arguments.length) {
              if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                var n3 = arguments[0], i2 = arguments[1];
                return this.add(n3, i2, true), true;
              }
              if (arguments[0] instanceof C && "boolean" == typeof arguments[1]) {
                var r2 = arguments[0];
                if (!arguments[1] && this.size() >= 1) {
                  if (this.get(this.size() - 1).equals2D(r2))
                    return null;
                }
                t2.prototype.add.call(this, r2);
              } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
                var o2 = arguments[0], s2 = arguments[1];
                return this.add(o2, s2), true;
              }
            } else if (3 === arguments.length) {
              if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                var a2 = arguments[0], u2 = arguments[1];
                if (arguments[2])
                  for (var l2 = 0; l2 < a2.length; l2++)
                    this.add(a2[l2], u2);
                else
                  for (var c2 = a2.length - 1; c2 >= 0; c2--)
                    this.add(a2[c2], u2);
                return true;
              }
              if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof C) {
                var p2 = arguments[0], h2 = arguments[1];
                if (!arguments[2]) {
                  var f2 = this.size();
                  if (f2 > 0) {
                    if (p2 > 0) {
                      if (this.get(p2 - 1).equals2D(h2))
                        return null;
                    }
                    if (p2 < f2) {
                      if (this.get(p2).equals2D(h2))
                        return null;
                    }
                  }
                }
                t2.prototype.add.call(this, p2, h2);
              }
            } else if (4 === arguments.length) {
              var g2 = arguments[0], d2 = arguments[1], y3 = arguments[2], _2 = arguments[3], m2 = 1;
              y3 > _2 && (m2 = -1);
              for (var v2 = y3; v2 !== _2; v2 += m2)
                this.add(g2[v2], d2);
              return true;
            }
          }, e3.prototype.closeRing = function() {
            this.size() > 0 && this.add(new C(this.get(0)), false);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, Object.defineProperties(e3, n2), e3;
        }(Nt), Lt = function() {
        }, bt = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
        bt.ForwardComparator.get = function() {
          return wt;
        }, bt.BidirectionalComparator.get = function() {
          return Ot;
        }, bt.coordArrayType.get = function() {
          return new Array(0).fill(null);
        }, Lt.prototype.interfaces_ = function() {
          return [];
        }, Lt.prototype.getClass = function() {
          return Lt;
        }, Lt.isRing = function(t2) {
          return !(t2.length < 4) && !!t2[0].equals2D(t2[t2.length - 1]);
        }, Lt.ptNotInList = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            if (Lt.indexOf(i2, e3) < 0)
              return i2;
          }
          return null;
        }, Lt.scroll = function(t2, e3) {
          var n2 = Lt.indexOf(e3, t2);
          if (n2 < 0)
            return null;
          var i2 = new Array(t2.length).fill(null);
          Y.arraycopy(t2, n2, i2, 0, t2.length - n2), Y.arraycopy(t2, 0, i2, t2.length - n2, n2), Y.arraycopy(i2, 0, t2, 0, t2.length);
        }, Lt.equals = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            if (t2 === e3)
              return true;
            if (null === t2 || null === e3)
              return false;
            if (t2.length !== e3.length)
              return false;
            for (var n2 = 0; n2 < t2.length; n2++)
              if (!t2[n2].equals(e3[n2]))
                return false;
            return true;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            if (i2 === r2)
              return true;
            if (null === i2 || null === r2)
              return false;
            if (i2.length !== r2.length)
              return false;
            for (var s2 = 0; s2 < i2.length; s2++)
              if (0 !== o2.compare(i2[s2], r2[s2]))
                return false;
            return true;
          }
        }, Lt.intersection = function(t2, e3) {
          for (var n2 = new St(), i2 = 0; i2 < t2.length; i2++)
            e3.intersects(t2[i2]) && n2.add(t2[i2], true);
          return n2.toCoordinateArray();
        }, Lt.hasRepeatedPoints = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++)
            if (t2[e3 - 1].equals(t2[e3]))
              return true;
          return false;
        }, Lt.removeRepeatedPoints = function(t2) {
          if (!Lt.hasRepeatedPoints(t2))
            return t2;
          return new St(t2, false).toCoordinateArray();
        }, Lt.reverse = function(t2) {
          for (var e3 = t2.length - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++) {
            var r2 = t2[i2];
            t2[i2] = t2[e3 - i2], t2[e3 - i2] = r2;
          }
        }, Lt.removeNull = function(t2) {
          for (var e3 = 0, n2 = 0; n2 < t2.length; n2++)
            null !== t2[n2] && e3++;
          var i2 = new Array(e3).fill(null);
          if (0 === e3)
            return i2;
          for (var r2 = 0, o2 = 0; o2 < t2.length; o2++)
            null !== t2[o2] && (i2[r2++] = t2[o2]);
          return i2;
        }, Lt.copyDeep = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = new Array(t2.length).fill(null), n2 = 0; n2 < t2.length; n2++)
              e3[n2] = new C(t2[n2]);
            return e3;
          }
          if (5 === arguments.length)
            for (var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = arguments[4], u2 = 0; u2 < a2; u2++)
              o2[s2 + u2] = new C(i2[r2 + u2]);
        }, Lt.isEqualReversed = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2], r2 = e3[t2.length - n2 - 1];
            if (0 !== i2.compareTo(r2))
              return false;
          }
          return true;
        }, Lt.envelope = function(t2) {
          for (var e3 = new j(), n2 = 0; n2 < t2.length; n2++)
            e3.expandToInclude(t2[n2]);
          return e3;
        }, Lt.toCoordinateArray = function(t2) {
          return t2.toArray(Lt.coordArrayType);
        }, Lt.atLeastNCoordinatesOrNothing = function(t2, e3) {
          return e3.length >= t2 ? e3 : [];
        }, Lt.indexOf = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++)
            if (t2.equals(e3[n2]))
              return n2;
          return -1;
        }, Lt.increasingDirection = function(t2) {
          for (var e3 = 0; e3 < Math.trunc(t2.length / 2); e3++) {
            var n2 = t2.length - 1 - e3, i2 = t2[e3].compareTo(t2[n2]);
            if (0 !== i2)
              return i2;
          }
          return 1;
        }, Lt.compare = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length && n2 < e3.length; ) {
            var i2 = t2[n2].compareTo(e3[n2]);
            if (0 !== i2)
              return i2;
            n2++;
          }
          return n2 < e3.length ? -1 : n2 < t2.length ? 1 : 0;
        }, Lt.minCoordinate = function(t2) {
          for (var e3 = null, n2 = 0; n2 < t2.length; n2++)
            (null === e3 || e3.compareTo(t2[n2]) > 0) && (e3 = t2[n2]);
          return e3;
        }, Lt.extract = function(t2, e3, n2) {
          e3 = R.clamp(e3, 0, t2.length);
          var i2 = (n2 = R.clamp(n2, -1, t2.length)) - e3 + 1;
          n2 < 0 && (i2 = 0), e3 >= t2.length && (i2 = 0), n2 < e3 && (i2 = 0);
          var r2 = new Array(i2).fill(null);
          if (0 === i2)
            return r2;
          for (var o2 = 0, s2 = e3; s2 <= n2; s2++)
            r2[o2++] = t2[s2];
          return r2;
        }, Object.defineProperties(Lt, bt);
        var wt = function() {
        };
        wt.prototype.compare = function(t2, e3) {
          return Lt.compare(t2, e3);
        }, wt.prototype.interfaces_ = function() {
          return [N];
        }, wt.prototype.getClass = function() {
          return wt;
        };
        var Ot = function() {
        };
        Ot.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (0 === n2.length)
            return 0;
          var r2 = Lt.compare(n2, i2);
          return Lt.isEqualReversed(n2, i2) ? 0 : r2;
        }, Ot.prototype.OLDcompare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (0 === n2.length)
            return 0;
          for (var r2 = Lt.increasingDirection(n2), o2 = Lt.increasingDirection(i2), s2 = r2 > 0 ? 0 : n2.length - 1, a2 = o2 > 0 ? 0 : n2.length - 1, u2 = 0; u2 < n2.length; u2++) {
            var l2 = n2[s2].compareTo(i2[a2]);
            if (0 !== l2)
              return l2;
            s2 += r2, a2 += o2;
          }
          return 0;
        }, Ot.prototype.interfaces_ = function() {
          return [N];
        }, Ot.prototype.getClass = function() {
          return Ot;
        };
        var Tt = function() {
        };
        Tt.prototype.get = function() {
        }, Tt.prototype.put = function() {
        }, Tt.prototype.size = function() {
        }, Tt.prototype.values = function() {
        }, Tt.prototype.entrySet = function() {
        };
        var Rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Tt);
        (r.prototype = new Error()).name = "OperationNotSupported", (o.prototype = new It()).contains = function() {
        };
        var Pt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.contains = function(t3) {
            for (var e4 = 0, n2 = this.array_.length; e4 < n2; e4++) {
              if (this.array_[e4] === t3)
                return true;
            }
            return false;
          }, e3.prototype.add = function(t3) {
            return !this.contains(t3) && (this.array_.push(t3), true);
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.remove = function(t3) {
            throw new Error();
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.isEmpty = function() {
            return 0 === this.array_.length;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.iterator = function() {
            return new Dt(this);
          }, e3;
        }(o), Dt = function(t2) {
          function e3(e4) {
            t2.call(this), this.hashSet_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.hashSet_.size())
              throw new i();
            return this.hashSet_.array_[this.position_++];
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.hashSet_.size();
          }, e3.prototype.remove = function() {
            throw new r();
          }, e3;
        }(Et), Mt = 0;
        (p.prototype = new Rt()).get = function(t2) {
          for (var e3 = this.root_; null !== e3; ) {
            var n2 = t2.compareTo(e3.key);
            if (n2 < 0)
              e3 = e3.left;
            else {
              if (!(n2 > 0))
                return e3.value;
              e3 = e3.right;
            }
          }
          return null;
        }, p.prototype.put = function(t2, e3) {
          if (null === this.root_)
            return this.root_ = { key: t2, value: e3, left: null, right: null, parent: null, color: Mt, getValue: function() {
              return this.value;
            }, getKey: function() {
              return this.key;
            } }, this.size_ = 1, null;
          var n2, i2, r2 = this.root_;
          do {
            if (n2 = r2, (i2 = t2.compareTo(r2.key)) < 0)
              r2 = r2.left;
            else {
              if (!(i2 > 0)) {
                var o2 = r2.value;
                return r2.value = e3, o2;
              }
              r2 = r2.right;
            }
          } while (null !== r2);
          var s2 = { key: t2, left: null, right: null, value: e3, parent: n2, color: Mt, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return i2 < 0 ? n2.left = s2 : n2.right = s2, this.fixAfterInsertion(s2), this.size_++, null;
        }, p.prototype.fixAfterInsertion = function(t2) {
          for (t2.color = 1; null != t2 && t2 !== this.root_ && 1 === t2.parent.color; )
            if (a(t2) === l(a(a(t2)))) {
              var e3 = c(a(a(t2)));
              1 === s(e3) ? (u(a(t2), Mt), u(e3, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === c(a(t2)) && (t2 = a(t2), this.rotateLeft(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateRight(a(a(t2))));
            } else {
              var n2 = l(a(a(t2)));
              1 === s(n2) ? (u(a(t2), Mt), u(n2, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === l(a(t2)) && (t2 = a(t2), this.rotateRight(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateLeft(a(a(t2))));
            }
          this.root_.color = Mt;
        }, p.prototype.values = function() {
          var t2 = new Nt(), e3 = this.getFirstEntry();
          if (null !== e3)
            for (t2.add(e3.value); null !== (e3 = p.successor(e3)); )
              t2.add(e3.value);
          return t2;
        }, p.prototype.entrySet = function() {
          var t2 = new Pt(), e3 = this.getFirstEntry();
          if (null !== e3)
            for (t2.add(e3); null !== (e3 = p.successor(e3)); )
              t2.add(e3);
          return t2;
        }, p.prototype.rotateLeft = function(t2) {
          if (null != t2) {
            var e3 = t2.right;
            t2.right = e3.left, null != e3.left && (e3.left.parent = t2), e3.parent = t2.parent, null === t2.parent ? this.root_ = e3 : t2.parent.left === t2 ? t2.parent.left = e3 : t2.parent.right = e3, e3.left = t2, t2.parent = e3;
          }
        }, p.prototype.rotateRight = function(t2) {
          if (null != t2) {
            var e3 = t2.left;
            t2.left = e3.right, null != e3.right && (e3.right.parent = t2), e3.parent = t2.parent, null === t2.parent ? this.root_ = e3 : t2.parent.right === t2 ? t2.parent.right = e3 : t2.parent.left = e3, e3.right = t2, t2.parent = e3;
          }
        }, p.prototype.getFirstEntry = function() {
          var t2 = this.root_;
          if (null != t2)
            for (; null != t2.left; )
              t2 = t2.left;
          return t2;
        }, p.successor = function(t2) {
          if (null === t2)
            return null;
          if (null !== t2.right) {
            for (var e3 = t2.right; null !== e3.left; )
              e3 = e3.left;
            return e3;
          }
          for (var n2 = t2.parent, i2 = t2; null !== n2 && i2 === n2.right; )
            i2 = n2, n2 = n2.parent;
          return n2;
        }, p.prototype.size = function() {
          return this.size_;
        };
        var At = function() {
        };
        At.prototype.interfaces_ = function() {
          return [];
        }, At.prototype.getClass = function() {
          return At;
        }, h.prototype = new o(), (f.prototype = new h()).contains = function(t2) {
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (0 === this.array_[e3].compareTo(t2))
              return true;
          }
          return false;
        }, f.prototype.add = function(t2) {
          if (this.contains(t2))
            return false;
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (1 === this.array_[e3].compareTo(t2))
              return this.array_.splice(e3, 0, t2), true;
          }
          return this.array_.push(t2), true;
        }, f.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
          return true;
        }, f.prototype.remove = function(t2) {
          throw new r();
        }, f.prototype.size = function() {
          return this.array_.length;
        }, f.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        }, f.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        }, f.prototype.iterator = function() {
          return new Ft(this);
        };
        var Ft = function(t2) {
          this.treeSet_ = t2, this.position_ = 0;
        };
        Ft.prototype.next = function() {
          if (this.position_ === this.treeSet_.size())
            throw new i();
          return this.treeSet_.array_[this.position_++];
        }, Ft.prototype.hasNext = function() {
          return this.position_ < this.treeSet_.size();
        }, Ft.prototype.remove = function() {
          throw new r();
        };
        var Gt = function() {
        };
        Gt.sort = function() {
          var t2, e3, n2, i2, r2 = arguments[0];
          if (1 === arguments.length)
            i2 = function(t3, e4) {
              return t3.compareTo(e4);
            }, r2.sort(i2);
          else if (2 === arguments.length)
            n2 = arguments[1], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, r2.sort(i2);
          else if (3 === arguments.length) {
            (e3 = r2.slice(arguments[1], arguments[2])).sort();
            var o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length));
            for (r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
          } else if (4 === arguments.length)
            for (e3 = r2.slice(arguments[1], arguments[2]), n2 = arguments[3], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, e3.sort(i2), o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length)), r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
        }, Gt.asList = function(t2) {
          for (var e3 = new Nt(), n2 = 0, i2 = t2.length; n2 < i2; n2++)
            e3.add(t2[n2]);
          return e3;
        };
        var qt = function() {
        }, Bt = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
        Bt.P.get = function() {
          return 0;
        }, Bt.L.get = function() {
          return 1;
        }, Bt.A.get = function() {
          return 2;
        }, Bt.FALSE.get = function() {
          return -1;
        }, Bt.TRUE.get = function() {
          return -2;
        }, Bt.DONTCARE.get = function() {
          return -3;
        }, Bt.SYM_FALSE.get = function() {
          return "F";
        }, Bt.SYM_TRUE.get = function() {
          return "T";
        }, Bt.SYM_DONTCARE.get = function() {
          return "*";
        }, Bt.SYM_P.get = function() {
          return "0";
        }, Bt.SYM_L.get = function() {
          return "1";
        }, Bt.SYM_A.get = function() {
          return "2";
        }, qt.prototype.interfaces_ = function() {
          return [];
        }, qt.prototype.getClass = function() {
          return qt;
        }, qt.toDimensionSymbol = function(t2) {
          switch (t2) {
            case qt.FALSE:
              return qt.SYM_FALSE;
            case qt.TRUE:
              return qt.SYM_TRUE;
            case qt.DONTCARE:
              return qt.SYM_DONTCARE;
            case qt.P:
              return qt.SYM_P;
            case qt.L:
              return qt.SYM_L;
            case qt.A:
              return qt.SYM_A;
          }
          throw new m("Unknown dimension value: " + t2);
        }, qt.toDimensionValue = function(t2) {
          switch (A.toUpperCase(t2)) {
            case qt.SYM_FALSE:
              return qt.FALSE;
            case qt.SYM_TRUE:
              return qt.TRUE;
            case qt.SYM_DONTCARE:
              return qt.DONTCARE;
            case qt.SYM_P:
              return qt.P;
            case qt.SYM_L:
              return qt.L;
            case qt.SYM_A:
              return qt.A;
          }
          throw new m("Unknown dimension symbol: " + t2);
        }, Object.defineProperties(qt, Bt);
        var Vt = function() {
        };
        Vt.prototype.filter = function(t2) {
        }, Vt.prototype.interfaces_ = function() {
          return [];
        }, Vt.prototype.getClass = function() {
          return Vt;
        };
        var Ut = function() {
        };
        Ut.prototype.filter = function(t2, e3) {
        }, Ut.prototype.isDone = function() {
        }, Ut.prototype.isGeometryChanged = function() {
        }, Ut.prototype.interfaces_ = function() {
          return [];
        }, Ut.prototype.getClass = function() {
          return Ut;
        };
        var zt = function(t2) {
          function e3(e4, n3) {
            if (t2.call(this, n3), this._geometries = e4 || [], t2.hasNullElements(this._geometries))
              throw new m("geometries must not contain null elements");
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            for (var t3 = new j(), e4 = 0; e4 < this._geometries.length; e4++)
              t3.expandToInclude(this._geometries[e4].getEnvelopeInternal());
            return t3;
          }, e3.prototype.getGeometryN = function(t3) {
            return this._geometries[t3];
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_GEOMETRYCOLLECTION;
          }, e3.prototype.getCoordinates = function() {
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = 0; n3 < this._geometries.length; n3++)
              for (var i2 = this._geometries[n3].getCoordinates(), r2 = 0; r2 < i2.length; r2++)
                t3[++e4] = i2[r2];
            return t3;
          }, e3.prototype.getArea = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getArea();
            return t3;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._geometries.length !== i2._geometries.length)
                return false;
              for (var r2 = 0; r2 < this._geometries.length; r2++)
                if (!this._geometries[r2].equalsExact(i2._geometries[r2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              this._geometries[t3].normalize();
            Gt.sort(this._geometries);
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._geometries[0].getCoordinate();
          }, e3.prototype.getBoundaryDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getBoundaryDimension());
            return t3;
          }, e3.prototype.getDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getDimension());
            return t3;
          }, e3.prototype.getLength = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getNumPoints();
            return t3;
          }, e3.prototype.getNumGeometries = function() {
            return this._geometries.length;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createGeometryCollection(e4);
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = new f(Gt.asList(this._geometries)), n3 = new f(Gt.asList(t3._geometries));
              return this.compare(e4, n3);
            }
            if (2 === arguments.length) {
              for (var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this.getNumGeometries(), a2 = o2.getNumGeometries(), u2 = 0; u2 < s2 && u2 < a2; ) {
                var l2 = this.getGeometryN(u2), c2 = o2.getGeometryN(u2), p2 = l2.compareToSameClass(c2, r2);
                if (0 !== p2)
                  return p2;
                u2++;
              }
              return u2 < s2 ? 1 : u2 < a2 ? -1 : 0;
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._geometries.length; e4++)
                this._geometries[e4].apply(t3);
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (0 === this._geometries.length)
                return null;
              for (var i2 = 0; i2 < this._geometries.length && (this._geometries[i2].apply(n3), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              var r2 = arguments[0];
              r2.filter(this);
              for (var o2 = 0; o2 < this._geometries.length; o2++)
                this._geometries[o2].apply(r2);
            } else if (T(arguments[0], lt)) {
              var s2 = arguments[0];
              s2.filter(this);
              for (var a2 = 0; a2 < this._geometries.length; a2++)
                this._geometries[a2].apply(s2);
            }
          }, e3.prototype.getBoundary = function() {
            return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._geometries = new Array(this._geometries.length).fill(null);
            for (var n3 = 0; n3 < this._geometries.length; n3++)
              e4._geometries[n3] = this._geometries[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "GeometryCollection";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.isEmpty = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isEmpty())
                return false;
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -5694727726395021e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTILINESTRING;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            if (this.isEmpty())
              return false;
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isClosed())
                return false;
            return true;
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[t3 - 1 - n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiLineString(e4);
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.getGeometryType = function() {
            return "MultiLineString";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 8166665132445434e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), Yt = function() {
          if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
            var t2 = arguments[0], e3 = gt.MOD2_BOUNDARY_RULE;
            this._geom = t2, this._geomFact = t2.getFactory(), this._bnRule = e3;
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this._geom = n2, this._geomFact = n2.getFactory(), this._bnRule = i2;
          }
        };
        Yt.prototype.boundaryMultiLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          var e3 = this.computeBoundaryCoordinates(t2);
          return 1 === e3.length ? this._geomFact.createPoint(e3[0]) : this._geomFact.createMultiPointFromCoords(e3);
        }, Yt.prototype.getBoundary = function() {
          return this._geom instanceof Kt ? this.boundaryLineString(this._geom) : this._geom instanceof Xt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
        }, Yt.prototype.boundaryLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          if (t2.isClosed()) {
            return this._bnRule.isInBoundary(2) ? t2.getStartPoint() : this._geomFact.createMultiPoint();
          }
          return this._geomFact.createMultiPoint([t2.getStartPoint(), t2.getEndPoint()]);
        }, Yt.prototype.getEmptyMultiPoint = function() {
          return this._geomFact.createMultiPoint();
        }, Yt.prototype.computeBoundaryCoordinates = function(t2) {
          var e3 = new Nt();
          this._endpointMap = new p();
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            0 !== i2.getNumPoints() && (this.addEndpoint(i2.getCoordinateN(0)), this.addEndpoint(i2.getCoordinateN(i2.getNumPoints() - 1)));
          }
          for (var r2 = this._endpointMap.entrySet().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getValue().count;
            this._bnRule.isInBoundary(s2) && e3.add(o2.getKey());
          }
          return Lt.toCoordinateArray(e3);
        }, Yt.prototype.addEndpoint = function(t2) {
          var e3 = this._endpointMap.get(t2);
          null === e3 && (e3 = new kt(), this._endpointMap.put(t2, e3)), e3.count++;
        }, Yt.prototype.interfaces_ = function() {
          return [];
        }, Yt.prototype.getClass = function() {
          return Yt;
        }, Yt.getBoundary = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Yt(t2).getBoundary();
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Yt(e3, n2).getBoundary();
          }
        };
        var kt = function() {
          this.count = null;
        };
        kt.prototype.interfaces_ = function() {
          return [];
        }, kt.prototype.getClass = function() {
          return kt;
        };
        var jt = function() {
        }, Ht = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
        jt.prototype.interfaces_ = function() {
          return [];
        }, jt.prototype.getClass = function() {
          return jt;
        }, jt.chars = function(t2, e3) {
          for (var n2 = new Array(e3).fill(null), i2 = 0; i2 < e3; i2++)
            n2[i2] = t2;
          return String(n2);
        }, jt.getStackTrace = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new function() {
            }(), n2 = new function() {
            }(e3);
            return t2.printStackTrace(n2), e3.toString();
          }
          if (2 === arguments.length) {
            for (var i2 = arguments[0], r2 = arguments[1], o2 = "", s2 = new function() {
            }(new function() {
            }(jt.getStackTrace(i2))), a2 = 0; a2 < r2; a2++)
              try {
                o2 += s2.readLine() + jt.NEWLINE;
              } catch (t3) {
                if (!(t3 instanceof g))
                  throw t3;
                et.shouldNeverReachHere();
              }
            return o2;
          }
        }, jt.split = function(t2, e3) {
          for (var n2 = e3.length, i2 = new Nt(), r2 = "" + t2, o2 = r2.indexOf(e3); o2 >= 0; ) {
            var s2 = r2.substring(0, o2);
            i2.add(s2), o2 = (r2 = r2.substring(o2 + n2)).indexOf(e3);
          }
          r2.length > 0 && i2.add(r2);
          for (var a2 = new Array(i2.size()).fill(null), u2 = 0; u2 < a2.length; u2++)
            a2[u2] = i2.get(u2);
          return a2;
        }, jt.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return jt.SIMPLE_ORDINATE_FORMAT.format(t2);
          }
        }, jt.spaces = function(t2) {
          return jt.chars(" ", t2);
        }, Ht.NEWLINE.get = function() {
          return Y.getProperty("line.separator");
        }, Ht.SIMPLE_ORDINATE_FORMAT.get = function() {
          return new function() {
          }("0.#");
        }, Object.defineProperties(jt, Ht);
        var Wt = function() {
        };
        Wt.prototype.interfaces_ = function() {
          return [];
        }, Wt.prototype.getClass = function() {
          return Wt;
        }, Wt.copyCoord = function(t2, e3, n2, i2) {
          for (var r2 = Math.min(t2.getDimension(), n2.getDimension()), o2 = 0; o2 < r2; o2++)
            n2.setOrdinate(i2, o2, t2.getOrdinate(e3, o2));
        }, Wt.isRing = function(t2) {
          var e3 = t2.size();
          return 0 === e3 || !(e3 <= 3) && (t2.getOrdinate(0, V.X) === t2.getOrdinate(e3 - 1, V.X) && t2.getOrdinate(0, V.Y) === t2.getOrdinate(e3 - 1, V.Y));
        }, Wt.isEqual = function(t2, e3) {
          var n2 = t2.size();
          if (n2 !== e3.size())
            return false;
          for (var i2 = Math.min(t2.getDimension(), e3.getDimension()), r2 = 0; r2 < n2; r2++)
            for (var o2 = 0; o2 < i2; o2++) {
              var s2 = t2.getOrdinate(r2, o2), a2 = e3.getOrdinate(r2, o2);
              if (t2.getOrdinate(r2, o2) !== e3.getOrdinate(r2, o2) && (!v.isNaN(s2) || !v.isNaN(a2)))
                return false;
            }
          return true;
        }, Wt.extend = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          if (Wt.copy(e3, 0, i2, 0, r2), r2 > 0)
            for (var o2 = r2; o2 < n2; o2++)
              Wt.copy(e3, r2 - 1, i2, o2, 1);
          return i2;
        }, Wt.reverse = function(t2) {
          for (var e3 = t2.size() - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++)
            Wt.swap(t2, i2, e3 - i2);
        }, Wt.swap = function(t2, e3, n2) {
          if (e3 === n2)
            return null;
          for (var i2 = 0; i2 < t2.getDimension(); i2++) {
            var r2 = t2.getOrdinate(e3, i2);
            t2.setOrdinate(e3, i2, t2.getOrdinate(n2, i2)), t2.setOrdinate(n2, i2, r2);
          }
        }, Wt.copy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0; o2 < r2; o2++)
            Wt.copyCoord(t2, e3 + o2, n2, i2 + o2);
        }, Wt.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = t2.size();
            if (0 === e3)
              return "()";
            var n2 = t2.getDimension(), i2 = new D();
            i2.append("(");
            for (var r2 = 0; r2 < e3; r2++) {
              r2 > 0 && i2.append(" ");
              for (var o2 = 0; o2 < n2; o2++)
                o2 > 0 && i2.append(","), i2.append(jt.toString(t2.getOrdinate(r2, o2)));
            }
            return i2.append(")"), i2.toString();
          }
        }, Wt.ensureValidRing = function(t2, e3) {
          var n2 = e3.size();
          if (0 === n2)
            return e3;
          if (n2 <= 3)
            return Wt.createClosedRing(t2, e3, 4);
          return e3.getOrdinate(0, V.X) === e3.getOrdinate(n2 - 1, V.X) && e3.getOrdinate(0, V.Y) === e3.getOrdinate(n2 - 1, V.Y) ? e3 : Wt.createClosedRing(t2, e3, n2 + 1);
        }, Wt.createClosedRing = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          Wt.copy(e3, 0, i2, 0, r2);
          for (var o2 = r2; o2 < n2; o2++)
            Wt.copy(e3, 0, i2, o2, 1);
          return i2;
        };
        var Kt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._points = null, this.init(e4);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this.isEmpty() ? new j() : this._points.expandEnvelope(new j());
          }, e3.prototype.isRing = function() {
            return this.isClosed() && this.isSimple();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_LINESTRING;
          }, e3.prototype.getCoordinates = function() {
            return this._points.toCoordinateArray();
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._points.size() !== i2._points.size())
                return false;
              for (var r2 = 0; r2 < this._points.size(); r2++)
                if (!this.equal(this._points.getCoordinate(r2), i2._points.getCoordinate(r2), n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < Math.trunc(this._points.size() / 2); t3++) {
              var e4 = this._points.size() - 1 - t3;
              if (!this._points.getCoordinate(t3).equals(this._points.getCoordinate(e4)))
                return this._points.getCoordinate(t3).compareTo(this._points.getCoordinate(e4)) > 0 && Wt.reverse(this._points), null;
            }
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._points.getCoordinate(0);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
          }, e3.prototype.getEndPoint = function() {
            return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.getLength = function() {
            return at.computeLength(this._points);
          }, e3.prototype.getNumPoints = function() {
            return this._points.size();
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLineString(t3);
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              for (var t3 = arguments[0], e4 = 0, n3 = 0; e4 < this._points.size() && n3 < t3._points.size(); ) {
                var i2 = this._points.getCoordinate(e4).compareTo(t3._points.getCoordinate(n3));
                if (0 !== i2)
                  return i2;
                e4++, n3++;
              }
              return e4 < this._points.size() ? 1 : n3 < t3._points.size() ? -1 : 0;
            }
            if (2 === arguments.length) {
              var r2 = arguments[0];
              return arguments[1].compare(this._points, r2._points);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._points.size(); e4++)
                t3.filter(this._points.getCoordinate(e4));
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (0 === this._points.size())
                return null;
              for (var i2 = 0; i2 < this._points.size() && (n3.filter(this._points, i2), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.isEquivalentClass = function(t3) {
            return t3 instanceof e3;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._points = this._points.clone(), e4;
          }, e3.prototype.getCoordinateN = function(t3) {
            return this._points.getCoordinate(t3);
          }, e3.prototype.getGeometryType = function() {
            return "LineString";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._points;
          }, e3.prototype.isEmpty = function() {
            return 0 === this._points.size();
          }, e3.prototype.init = function(t3) {
            if (null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t3.size())
              throw new m("Invalid number of points in LineString (found " + t3.size() + " - must be 0 or >= 2)");
            this._points = t3;
          }, e3.prototype.isCoordinate = function(t3) {
            for (var e4 = 0; e4 < this._points.size(); e4++)
              if (this._points.getCoordinate(e4).equals(t3))
                return true;
            return false;
          }, e3.prototype.getStartPoint = function() {
            return this.isEmpty() ? null : this.getPointN(0);
          }, e3.prototype.getPointN = function(t3) {
            return this.getFactory().createPoint(this._points.getCoordinate(t3));
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 3110669828065365500;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Jt = function() {
        };
        Jt.prototype.interfaces_ = function() {
          return [];
        }, Jt.prototype.getClass = function() {
          return Jt;
        };
        var Qt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._coordinates = e4 || null, this.init(this._coordinates);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            if (this.isEmpty())
              return new j();
            var t3 = new j();
            return t3.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t3;
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POINT;
          }, e3.prototype.getCoordinates = function() {
            return this.isEmpty() ? [] : [this.getCoordinate()];
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && (!(!this.isEmpty() || !e4.isEmpty()) || this.isEmpty() === e4.isEmpty() && this.equal(e4.getCoordinate(), this.getCoordinate(), n3));
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
          }, e3.prototype.getCoordinate = function() {
            return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getNumPoints = function() {
            return this.isEmpty() ? 0 : 1;
          }, e3.prototype.reverse = function() {
            return this.copy();
          }, e3.prototype.getX = function() {
            if (null === this.getCoordinate())
              throw new Error("getX called on empty Point");
            return this.getCoordinate().x;
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0];
              return this.getCoordinate().compareTo(t3.getCoordinate());
            }
            if (2 === arguments.length) {
              var e4 = arguments[0];
              return arguments[1].compare(this._coordinates, e4._coordinates);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft)) {
              var t3 = arguments[0];
              if (this.isEmpty())
                return null;
              t3.filter(this.getCoordinate());
            } else if (T(arguments[0], Ut)) {
              var e4 = arguments[0];
              if (this.isEmpty())
                return null;
              e4.filter(this._coordinates, 0), e4.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._coordinates = this._coordinates.clone(), e4;
          }, e3.prototype.getGeometryType = function() {
            return "Point";
          }, e3.prototype.copy = function() {
            return new e3(this._coordinates.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._coordinates;
          }, e3.prototype.getY = function() {
            if (null === this.getCoordinate())
              throw new Error("getY called on empty Point");
            return this.getCoordinate().y;
          }, e3.prototype.isEmpty = function() {
            return 0 === this._coordinates.size();
          }, e3.prototype.init = function(t3) {
            null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t3.size() <= 1), this._coordinates = t3;
          }, e3.prototype.isSimple = function() {
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 4902022702746615e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Zt = function() {
        };
        Zt.prototype.interfaces_ = function() {
          return [];
        }, Zt.prototype.getClass = function() {
          return Zt;
        };
        var $t = function(t2) {
          function e3(e4, n3, i2) {
            if (t2.call(this, i2), this._shell = null, this._holes = null, null === e4 && (e4 = this.getFactory().createLinearRing()), null === n3 && (n3 = []), t2.hasNullElements(n3))
              throw new m("holes must not contain null elements");
            if (e4.isEmpty() && t2.hasNonEmptyElements(n3))
              throw new m("shell is empty but holes are not");
            this._shell = e4, this._holes = n3;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this._shell.getEnvelopeInternal();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POLYGON;
          }, e3.prototype.getCoordinates = function() {
            if (this.isEmpty())
              return [];
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = this._shell.getCoordinates(), i2 = 0; i2 < n3.length; i2++)
              t3[++e4] = n3[i2];
            for (var r2 = 0; r2 < this._holes.length; r2++)
              for (var o2 = this._holes[r2].getCoordinates(), s2 = 0; s2 < o2.length; s2++)
                t3[++e4] = o2[s2];
            return t3;
          }, e3.prototype.getArea = function() {
            var t3 = 0;
            t3 += Math.abs(at.signedArea(this._shell.getCoordinateSequence()));
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 -= Math.abs(at.signedArea(this._holes[e4].getCoordinateSequence()));
            return t3;
          }, e3.prototype.isRectangle = function() {
            if (0 !== this.getNumInteriorRing())
              return false;
            if (null === this._shell)
              return false;
            if (5 !== this._shell.getNumPoints())
              return false;
            for (var t3 = this._shell.getCoordinateSequence(), e4 = this.getEnvelopeInternal(), n3 = 0; n3 < 5; n3++) {
              var i2 = t3.getX(n3);
              if (i2 !== e4.getMinX() && i2 !== e4.getMaxX())
                return false;
              var r2 = t3.getY(n3);
              if (r2 !== e4.getMinY() && r2 !== e4.getMaxY())
                return false;
            }
            for (var o2 = t3.getX(0), s2 = t3.getY(0), a2 = 1; a2 <= 4; a2++) {
              var u2 = t3.getX(a2), l2 = t3.getY(a2);
              if (u2 !== o2 === (l2 !== s2))
                return false;
              o2 = u2, s2 = l2;
            }
            return true;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4, r2 = this._shell, o2 = i2._shell;
              if (!r2.equalsExact(o2, n3))
                return false;
              if (this._holes.length !== i2._holes.length)
                return false;
              for (var s2 = 0; s2 < this._holes.length; s2++)
                if (!this._holes[s2].equalsExact(i2._holes[s2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            if (0 === arguments.length) {
              this.normalize(this._shell, true);
              for (var t3 = 0; t3 < this._holes.length; t3++)
                this.normalize(this._holes[t3], false);
              Gt.sort(this._holes);
            } else if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (e4.isEmpty())
                return null;
              var i2 = new Array(e4.getCoordinates().length - 1).fill(null);
              Y.arraycopy(e4.getCoordinates(), 0, i2, 0, i2.length);
              var r2 = Lt.minCoordinate(e4.getCoordinates());
              Lt.scroll(i2, r2), Y.arraycopy(i2, 0, e4.getCoordinates(), 0, i2.length), e4.getCoordinates()[i2.length] = i2[0], at.isCCW(e4.getCoordinates()) === n3 && Lt.reverse(e4.getCoordinates());
            }
          }, e3.prototype.getCoordinate = function() {
            return this._shell.getCoordinate();
          }, e3.prototype.getNumInteriorRing = function() {
            return this._holes.length;
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.getLength = function() {
            var t3 = 0;
            t3 += this._shell.getLength();
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = this._shell.getNumPoints(), e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getNumPoints();
            return t3;
          }, e3.prototype.reverse = function() {
            var t3 = this.copy();
            t3._shell = this._shell.copy().reverse(), t3._holes = new Array(this._holes.length).fill(null);
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3._holes[e4] = this._holes[e4].copy().reverse();
            return t3;
          }, e3.prototype.convexHull = function() {
            return this.getExteriorRing().convexHull();
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = this._shell, n3 = t3._shell;
              return e4.compareToSameClass(n3);
            }
            if (2 === arguments.length) {
              var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this._shell, a2 = o2._shell, u2 = s2.compareToSameClass(a2, r2);
              if (0 !== u2)
                return u2;
              for (var l2 = this.getNumInteriorRing(), c2 = o2.getNumInteriorRing(), p2 = 0; p2 < l2 && p2 < c2; ) {
                var h2 = this.getInteriorRingN(p2), f2 = o2.getInteriorRingN(p2), g2 = h2.compareToSameClass(f2, r2);
                if (0 !== g2)
                  return g2;
                p2++;
              }
              return p2 < l2 ? 1 : p2 < c2 ? -1 : 0;
            }
          }, e3.prototype.apply = function(t3) {
            if (T(t3, ft)) {
              this._shell.apply(t3);
              for (var e4 = 0; e4 < this._holes.length; e4++)
                this._holes[e4].apply(t3);
            } else if (T(t3, Ut)) {
              if (this._shell.apply(t3), !t3.isDone())
                for (var n3 = 0; n3 < this._holes.length && (this._holes[n3].apply(t3), !t3.isDone()); n3++)
                  ;
              t3.isGeometryChanged() && this.geometryChanged();
            } else if (T(t3, Vt))
              t3.filter(this);
            else if (T(t3, lt)) {
              t3.filter(this), this._shell.apply(t3);
              for (var i2 = 0; i2 < this._holes.length; i2++)
                this._holes[i2].apply(t3);
            }
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            var t3 = new Array(this._holes.length + 1).fill(null);
            t3[0] = this._shell;
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3[e4 + 1] = this._holes[e4];
            return t3.length <= 1 ? this.getFactory().createLinearRing(t3[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t3);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._shell = this._shell.clone(), e4._holes = new Array(this._holes.length).fill(null);
            for (var n3 = 0; n3 < this._holes.length; n3++)
              e4._holes[n3] = this._holes[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "Polygon";
          }, e3.prototype.copy = function() {
            for (var t3 = this._shell.copy(), n3 = new Array(this._holes.length).fill(null), i2 = 0; i2 < n3.length; i2++)
              n3[i2] = this._holes[i2].copy();
            return new e3(t3, n3, this._factory);
          }, e3.prototype.getExteriorRing = function() {
            return this._shell;
          }, e3.prototype.isEmpty = function() {
            return this._shell.isEmpty();
          }, e3.prototype.getInteriorRingN = function(t3) {
            return this._holes[t3];
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -3494792200821764600;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), te = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOINT;
          }, e3.prototype.isValid = function() {
            return true;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getCoordinate = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              return this._geometries[e4].getCoordinate();
            }
            return t2.prototype.getCoordinate.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.getGeometryType = function() {
            return "MultiPoint";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -8048474874175356e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ee = function(t2) {
          function e3(e4, n3) {
            e4 instanceof C && n3 instanceof _e && (e4 = n3.getCoordinateSequenceFactory().create(e4)), t2.call(this, e4, n3), this.validateConstruction();
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_LINEARRING;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.isClosed = function() {
            return !!this.isEmpty() || t2.prototype.isClosed.call(this);
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLinearRing(t3);
          }, e3.prototype.validateConstruction = function() {
            if (!this.isEmpty() && !t2.prototype.isClosed.call(this))
              throw new m("Points of LinearRing do not form a closed linestring");
            if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e3.MINIMUM_VALID_SIZE)
              throw new m("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
          }, e3.prototype.getGeometryType = function() {
            return "LinearRing";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.MINIMUM_VALID_SIZE.get = function() {
            return 4;
          }, n2.serialVersionUID.get = function() {
            return -4261142084085851600;
          }, Object.defineProperties(e3, n2), e3;
        }(Kt), ne = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOLYGON;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiPolygon(e4);
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            for (var t3 = new Nt(), e4 = 0; e4 < this._geometries.length; e4++)
              for (var n3 = this._geometries[e4].getBoundary(), i2 = 0; i2 < n3.getNumGeometries(); i2++)
                t3.add(n3.getGeometryN(i2));
            var r2 = new Array(t3.size()).fill(null);
            return this.getFactory().createMultiLineString(t3.toArray(r2));
          }, e3.prototype.getGeometryType = function() {
            return "MultiPolygon";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -551033529766975900;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ie = function(t2) {
          this._factory = t2 || null, this._isUserDataCopied = false;
        }, re = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
        ie.prototype.setCopyUserData = function(t2) {
          this._isUserDataCopied = t2;
        }, ie.prototype.edit = function(t2, e3) {
          if (null === t2)
            return null;
          var n2 = this.editInternal(t2, e3);
          return this._isUserDataCopied && n2.setUserData(t2.getUserData()), n2;
        }, ie.prototype.editInternal = function(t2, e3) {
          return null === this._factory && (this._factory = t2.getFactory()), t2 instanceof zt ? this.editGeometryCollection(t2, e3) : t2 instanceof $t ? this.editPolygon(t2, e3) : t2 instanceof Qt ? e3.edit(t2, this._factory) : t2 instanceof Kt ? e3.edit(t2, this._factory) : (et.shouldNeverReachHere("Unsupported Geometry class: " + t2.getClass().getName()), null);
        }, ie.prototype.editGeometryCollection = function(t2, e3) {
          for (var n2 = e3.edit(t2, this._factory), i2 = new Nt(), r2 = 0; r2 < n2.getNumGeometries(); r2++) {
            var o2 = this.edit(n2.getGeometryN(r2), e3);
            null === o2 || o2.isEmpty() || i2.add(o2);
          }
          return n2.getClass() === te ? this._factory.createMultiPoint(i2.toArray([])) : n2.getClass() === Xt ? this._factory.createMultiLineString(i2.toArray([])) : n2.getClass() === ne ? this._factory.createMultiPolygon(i2.toArray([])) : this._factory.createGeometryCollection(i2.toArray([]));
        }, ie.prototype.editPolygon = function(t2, e3) {
          var n2 = e3.edit(t2, this._factory);
          if (null === n2 && (n2 = this._factory.createPolygon(null)), n2.isEmpty())
            return n2;
          var i2 = this.edit(n2.getExteriorRing(), e3);
          if (null === i2 || i2.isEmpty())
            return this._factory.createPolygon();
          for (var r2 = new Nt(), o2 = 0; o2 < n2.getNumInteriorRing(); o2++) {
            var s2 = this.edit(n2.getInteriorRingN(o2), e3);
            null === s2 || s2.isEmpty() || r2.add(s2);
          }
          return this._factory.createPolygon(i2, r2.toArray([]));
        }, ie.prototype.interfaces_ = function() {
          return [];
        }, ie.prototype.getClass = function() {
          return ie;
        }, ie.GeometryEditorOperation = function() {
        }, re.NoOpGeometryOperation.get = function() {
          return oe;
        }, re.CoordinateOperation.get = function() {
          return se;
        }, re.CoordinateSequenceOperation.get = function() {
          return ae;
        }, Object.defineProperties(ie, re);
        var oe = function() {
        };
        oe.prototype.edit = function(t2, e3) {
          return t2;
        }, oe.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, oe.prototype.getClass = function() {
          return oe;
        };
        var se = function() {
        };
        se.prototype.edit = function(t2, e3) {
          var n2 = this.editCoordinates(t2.getCoordinates(), t2);
          return null === n2 ? t2 : t2 instanceof ee ? e3.createLinearRing(n2) : t2 instanceof Kt ? e3.createLineString(n2) : t2 instanceof Qt ? n2.length > 0 ? e3.createPoint(n2[0]) : e3.createPoint() : t2;
        }, se.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, se.prototype.getClass = function() {
          return se;
        };
        var ae = function() {
        };
        ae.prototype.edit = function(t2, e3) {
          return t2 instanceof ee ? e3.createLinearRing(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Kt ? e3.createLineString(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Qt ? e3.createPoint(this.edit(t2.getCoordinateSequence(), t2)) : t2;
        }, ae.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, ae.prototype.getClass = function() {
          return ae;
        };
        var ue = function() {
          if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array)
              this._coordinates = arguments[0], this._dimension = 3;
            else if (Number.isInteger(arguments[0])) {
              var t2 = arguments[0];
              this._coordinates = new Array(t2).fill(null);
              for (var e3 = 0; e3 < t2; e3++)
                this._coordinates[e3] = new C();
            } else if (T(arguments[0], V)) {
              var n2 = arguments[0];
              if (null === n2)
                return this._coordinates = new Array(0).fill(null), null;
              this._dimension = n2.getDimension(), this._coordinates = new Array(n2.size()).fill(null);
              for (var i2 = 0; i2 < this._coordinates.length; i2++)
                this._coordinates[i2] = n2.getCoordinateCopy(i2);
            }
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var r2 = arguments[0], o2 = arguments[1];
              this._coordinates = r2, this._dimension = o2, null === r2 && (this._coordinates = new Array(0).fill(null));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var s2 = arguments[0], a2 = arguments[1];
              this._coordinates = new Array(s2).fill(null), this._dimension = a2;
              for (var u2 = 0; u2 < s2; u2++)
                this._coordinates[u2] = new C();
            }
          }
        }, le = { serialVersionUID: { configurable: true } };
        ue.prototype.setOrdinate = function(t2, e3, n2) {
          switch (e3) {
            case V.X:
              this._coordinates[t2].x = n2;
              break;
            case V.Y:
              this._coordinates[t2].y = n2;
              break;
            case V.Z:
              this._coordinates[t2].z = n2;
              break;
            default:
              throw new m("invalid ordinateIndex");
          }
        }, ue.prototype.size = function() {
          return this._coordinates.length;
        }, ue.prototype.getOrdinate = function(t2, e3) {
          switch (e3) {
            case V.X:
              return this._coordinates[t2].x;
            case V.Y:
              return this._coordinates[t2].y;
            case V.Z:
              return this._coordinates[t2].z;
          }
          return v.NaN;
        }, ue.prototype.getCoordinate = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this._coordinates[t2];
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            n2.x = this._coordinates[e3].x, n2.y = this._coordinates[e3].y, n2.z = this._coordinates[e3].z;
          }
        }, ue.prototype.getCoordinateCopy = function(t2) {
          return new C(this._coordinates[t2]);
        }, ue.prototype.getDimension = function() {
          return this._dimension;
        }, ue.prototype.getX = function(t2) {
          return this._coordinates[t2].x;
        }, ue.prototype.clone = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].clone();
          return new ue(t2, this._dimension);
        }, ue.prototype.expandEnvelope = function(t2) {
          for (var e3 = 0; e3 < this._coordinates.length; e3++)
            t2.expandToInclude(this._coordinates[e3]);
          return t2;
        }, ue.prototype.copy = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].copy();
          return new ue(t2, this._dimension);
        }, ue.prototype.toString = function() {
          if (this._coordinates.length > 0) {
            var t2 = new D(17 * this._coordinates.length);
            t2.append("("), t2.append(this._coordinates[0]);
            for (var e3 = 1; e3 < this._coordinates.length; e3++)
              t2.append(", "), t2.append(this._coordinates[e3]);
            return t2.append(")"), t2.toString();
          }
          return "()";
        }, ue.prototype.getY = function(t2) {
          return this._coordinates[t2].y;
        }, ue.prototype.toCoordinateArray = function() {
          return this._coordinates;
        }, ue.prototype.interfaces_ = function() {
          return [V, e];
        }, ue.prototype.getClass = function() {
          return ue;
        }, le.serialVersionUID.get = function() {
          return -915438501601840600;
        }, Object.defineProperties(ue, le);
        var ce = function() {
        }, pe = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
        ce.prototype.readResolve = function() {
          return ce.instance();
        }, ce.prototype.create = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new ue(t2);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new ue(e3);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return i2 > 3 && (i2 = 3), i2 < 2 ? new ue(n2) : new ue(n2, i2);
          }
        }, ce.prototype.interfaces_ = function() {
          return [b, e];
        }, ce.prototype.getClass = function() {
          return ce;
        }, ce.instance = function() {
          return ce.instanceObject;
        }, pe.serialVersionUID.get = function() {
          return -4099577099607551500;
        }, pe.instanceObject.get = function() {
          return new ce();
        }, Object.defineProperties(ce, pe);
        var he = function(t2) {
          function e3() {
            t2.call(this), this.map_ = /* @__PURE__ */ new Map();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function(t3) {
            return this.map_.get(t3) || null;
          }, e3.prototype.put = function(t3, e4) {
            return this.map_.set(t3, e4), e4;
          }, e3.prototype.values = function() {
            for (var t3 = new Nt(), e4 = this.map_.values(), n2 = e4.next(); !n2.done; )
              t3.add(n2.value), n2 = e4.next();
            return t3;
          }, e3.prototype.entrySet = function() {
            var t3 = new Pt();
            return this.map_.entries().forEach(function(e4) {
              return t3.add(e4);
            }), t3;
          }, e3.prototype.size = function() {
            return this.map_.size();
          }, e3;
        }(Tt), fe = function t2() {
          if (this._modelType = null, this._scale = null, 0 === arguments.length)
            this._modelType = t2.FLOATING;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof de) {
              var e3 = arguments[0];
              this._modelType = e3, e3 === t2.FIXED && this.setScale(1);
            } else if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              this._modelType = t2.FIXED, this.setScale(n2);
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              this._modelType = i2._modelType, this._scale = i2._scale;
            }
          }
        }, ge = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
        fe.prototype.equals = function(t2) {
          if (!(t2 instanceof fe))
            return false;
          var e3 = t2;
          return this._modelType === e3._modelType && this._scale === e3._scale;
        }, fe.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.getMaximumSignificantDigits(), i2 = e3.getMaximumSignificantDigits();
          return new M(n2).compareTo(new M(i2));
        }, fe.prototype.getScale = function() {
          return this._scale;
        }, fe.prototype.isFloating = function() {
          return this._modelType === fe.FLOATING || this._modelType === fe.FLOATING_SINGLE;
        }, fe.prototype.getType = function() {
          return this._modelType;
        }, fe.prototype.toString = function() {
          var t2 = "UNKNOWN";
          return this._modelType === fe.FLOATING ? t2 = "Floating" : this._modelType === fe.FLOATING_SINGLE ? t2 = "Floating-Single" : this._modelType === fe.FIXED && (t2 = "Fixed (Scale=" + this.getScale() + ")"), t2;
        }, fe.prototype.makePrecise = function() {
          if ("number" == typeof arguments[0]) {
            var t2 = arguments[0];
            if (v.isNaN(t2))
              return t2;
            if (this._modelType === fe.FLOATING_SINGLE) {
              return t2;
            }
            return this._modelType === fe.FIXED ? Math.round(t2 * this._scale) / this._scale : t2;
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            if (this._modelType === fe.FLOATING)
              return null;
            e3.x = this.makePrecise(e3.x), e3.y = this.makePrecise(e3.y);
          }
        }, fe.prototype.getMaximumSignificantDigits = function() {
          var t2 = 16;
          return this._modelType === fe.FLOATING ? t2 = 16 : this._modelType === fe.FLOATING_SINGLE ? t2 = 6 : this._modelType === fe.FIXED && (t2 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t2;
        }, fe.prototype.setScale = function(t2) {
          this._scale = Math.abs(t2);
        }, fe.prototype.interfaces_ = function() {
          return [e, E];
        }, fe.prototype.getClass = function() {
          return fe;
        }, fe.mostPrecise = function(t2, e3) {
          return t2.compareTo(e3) >= 0 ? t2 : e3;
        }, ge.serialVersionUID.get = function() {
          return 7777263578777804e3;
        }, ge.maximumPreciseValue.get = function() {
          return 9007199254740992;
        }, Object.defineProperties(fe, ge);
        var de = function t2(e3) {
          this._name = e3 || null, t2.nameToTypeMap.put(e3, this);
        }, ye = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
        de.prototype.readResolve = function() {
          return de.nameToTypeMap.get(this._name);
        }, de.prototype.toString = function() {
          return this._name;
        }, de.prototype.interfaces_ = function() {
          return [e];
        }, de.prototype.getClass = function() {
          return de;
        }, ye.serialVersionUID.get = function() {
          return -552860263173159e4;
        }, ye.nameToTypeMap.get = function() {
          return new he();
        }, Object.defineProperties(de, ye), fe.Type = de, fe.FIXED = new de("FIXED"), fe.FLOATING = new de("FLOATING"), fe.FLOATING_SINGLE = new de("FLOATING SINGLE");
        var _e = function t2() {
          this._precisionModel = new fe(), this._SRID = 0, this._coordinateSequenceFactory = t2.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? T(arguments[0], b) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof fe && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
        }, me = { serialVersionUID: { configurable: true } };
        _e.prototype.toGeometry = function(t2) {
          return t2.isNull() ? this.createPoint(null) : t2.getMinX() === t2.getMaxX() && t2.getMinY() === t2.getMaxY() ? this.createPoint(new C(t2.getMinX(), t2.getMinY())) : t2.getMinX() === t2.getMaxX() || t2.getMinY() === t2.getMaxY() ? this.createLineString([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMaxX(), t2.getMaxY())]) : this.createPolygon(this.createLinearRing([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMinX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMinY()), new C(t2.getMinX(), t2.getMinY())]), null);
        }, _e.prototype.createLineString = function(t2) {
          return t2 ? t2 instanceof Array ? new Kt(this.getCoordinateSequenceFactory().create(t2), this) : T(t2, V) ? new Kt(t2, this) : void 0 : new Kt(this.getCoordinateSequenceFactory().create([]), this);
        }, _e.prototype.createMultiLineString = function() {
          if (0 === arguments.length)
            return new Xt(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Xt(t2, this);
          }
        }, _e.prototype.buildGeometry = function(t2) {
          for (var e3 = null, n2 = false, i2 = false, r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getClass();
            null === e3 && (e3 = s2), s2 !== e3 && (n2 = true), o2.isGeometryCollectionOrDerived() && (i2 = true);
          }
          if (null === e3)
            return this.createGeometryCollection();
          if (n2 || i2)
            return this.createGeometryCollection(_e.toGeometryArray(t2));
          var a2 = t2.iterator().next();
          if (t2.size() > 1) {
            if (a2 instanceof $t)
              return this.createMultiPolygon(_e.toPolygonArray(t2));
            if (a2 instanceof Kt)
              return this.createMultiLineString(_e.toLineStringArray(t2));
            if (a2 instanceof Qt)
              return this.createMultiPoint(_e.toPointArray(t2));
            et.shouldNeverReachHere("Unhandled class: " + a2.getClass().getName());
          }
          return a2;
        }, _e.prototype.createMultiPointFromCoords = function(t2) {
          return this.createMultiPoint(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
        }, _e.prototype.createPoint = function() {
          if (0 === arguments.length)
            return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.createPoint(null !== t2 ? this.getCoordinateSequenceFactory().create([t2]) : null);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new Qt(e3, this);
            }
          }
        }, _e.prototype.getCoordinateSequenceFactory = function() {
          return this._coordinateSequenceFactory;
        }, _e.prototype.createPolygon = function() {
          if (0 === arguments.length)
            return new $t(null, null, this);
          if (1 === arguments.length) {
            if (T(arguments[0], V)) {
              var t2 = arguments[0];
              return this.createPolygon(this.createLinearRing(t2));
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createPolygon(this.createLinearRing(e3));
            }
            if (arguments[0] instanceof ee) {
              var n2 = arguments[0];
              return this.createPolygon(n2, null);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return new $t(i2, r2, this);
          }
        }, _e.prototype.getSRID = function() {
          return this._SRID;
        }, _e.prototype.createGeometryCollection = function() {
          if (0 === arguments.length)
            return new zt(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new zt(t2, this);
          }
        }, _e.prototype.createGeometry = function(t2) {
          return new ie(this).edit(t2, { edit: function() {
            if (2 === arguments.length) {
              var t3 = arguments[0];
              return this._coordinateSequenceFactory.create(t3);
            }
          } });
        }, _e.prototype.getPrecisionModel = function() {
          return this._precisionModel;
        }, _e.prototype.createLinearRing = function() {
          if (0 === arguments.length)
            return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return this.createLinearRing(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new ee(e3, this);
            }
          }
        }, _e.prototype.createMultiPolygon = function() {
          if (0 === arguments.length)
            return new ne(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new ne(t2, this);
          }
        }, _e.prototype.createMultiPoint = function() {
          if (0 === arguments.length)
            return new te(null, this);
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new te(t2, this);
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createMultiPoint(null !== e3 ? this.getCoordinateSequenceFactory().create(e3) : null);
            }
            if (T(arguments[0], V)) {
              var n2 = arguments[0];
              if (null === n2)
                return this.createMultiPoint(new Array(0).fill(null));
              for (var i2 = new Array(n2.size()).fill(null), r2 = 0; r2 < n2.size(); r2++) {
                var o2 = this.getCoordinateSequenceFactory().create(1, n2.getDimension());
                Wt.copy(n2, r2, o2, 0, 1), i2[r2] = this.createPoint(o2);
              }
              return this.createMultiPoint(i2);
            }
          }
        }, _e.prototype.interfaces_ = function() {
          return [e];
        }, _e.prototype.getClass = function() {
          return _e;
        }, _e.toMultiPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toGeometryArray = function(t2) {
          if (null === t2)
            return null;
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.getDefaultCoordinateSequenceFactory = function() {
          return ce.instance();
        }, _e.toMultiLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toMultiPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLinearRingArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.createPointFromInternalCoord = function(t2, e3) {
          return e3.getPrecisionModel().makePrecise(t2), e3.getFactory().createPoint(t2);
        }, me.serialVersionUID.get = function() {
          return -6820524753094096e3;
        }, Object.defineProperties(_e, me);
        var ve = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Ie = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        Ie.prototype.read = function(t2) {
          var e3, n2 = (e3 = "string" == typeof t2 ? JSON.parse(t2) : t2).type;
          if (!Ee[n2])
            throw new Error("Unknown GeoJSON type: " + e3.type);
          return -1 !== ve.indexOf(n2) ? Ee[n2].apply(this, [e3.coordinates]) : "GeometryCollection" === n2 ? Ee[n2].apply(this, [e3.geometries]) : Ee[n2].apply(this, [e3]);
        }, Ie.prototype.write = function(t2) {
          var e3 = t2.getGeometryType();
          if (!xe[e3])
            throw new Error("Geometry is not supported");
          return xe[e3].apply(this, [t2]);
        };
        var Ee = { Feature: function(t2) {
          var e3 = {};
          for (var n2 in t2)
            e3[n2] = t2[n2];
          if (t2.geometry) {
            var i2 = t2.geometry.type;
            if (!Ee[i2])
              throw new Error("Unknown GeoJSON type: " + t2.type);
            e3.geometry = this.read(t2.geometry);
          }
          return t2.bbox && (e3.bbox = Ee.bbox.apply(this, [t2.bbox])), e3;
        }, FeatureCollection: function(t2) {
          var e3 = {};
          if (t2.features) {
            e3.features = [];
            for (var n2 = 0; n2 < t2.features.length; ++n2)
              e3.features.push(this.read(t2.features[n2]));
          }
          return t2.bbox && (e3.bbox = this.parse.bbox.apply(this, [t2.bbox])), e3;
        }, coordinates: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(new C(i2[0], i2[1]));
          }
          return e3;
        }, bbox: function(t2) {
          return this.geometryFactory.createLinearRing([new C(t2[0], t2[1]), new C(t2[2], t2[1]), new C(t2[2], t2[3]), new C(t2[0], t2[3]), new C(t2[0], t2[1])]);
        }, Point: function(t2) {
          var e3 = new C(t2[0], t2[1]);
          return this.geometryFactory.createPoint(e3);
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.Point.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiPoint(e3);
        }, LineString: function(t2) {
          var e3 = Ee.coordinates.apply(this, [t2]);
          return this.geometryFactory.createLineString(e3);
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.LineString.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiLineString(e3);
        }, Polygon: function(t2) {
          for (var e3 = Ee.coordinates.apply(this, [t2[0]]), n2 = this.geometryFactory.createLinearRing(e3), i2 = [], r2 = 1; r2 < t2.length; ++r2) {
            var o2 = t2[r2], s2 = Ee.coordinates.apply(this, [o2]), a2 = this.geometryFactory.createLinearRing(s2);
            i2.push(a2);
          }
          return this.geometryFactory.createPolygon(n2, i2);
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(Ee.Polygon.apply(this, [i2]));
          }
          return this.geometryFactory.createMultiPolygon(e3);
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(this.read(i2));
          }
          return this.geometryFactory.createGeometryCollection(e3);
        } }, xe = { coordinate: function(t2) {
          return [t2.x, t2.y];
        }, Point: function(t2) {
          return { type: "Point", coordinates: xe.coordinate.apply(this, [t2.getCoordinate()]) };
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Point.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPoint", coordinates: e3 };
        }, LineString: function(t2) {
          for (var e3 = [], n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; ++i2) {
            var r2 = n2[i2];
            e3.push(xe.coordinate.apply(this, [r2]));
          }
          return { type: "LineString", coordinates: e3 };
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.LineString.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiLineString", coordinates: e3 };
        }, Polygon: function(t2) {
          var e3 = [], n2 = xe.LineString.apply(this, [t2._shell]);
          e3.push(n2.coordinates);
          for (var i2 = 0; i2 < t2._holes.length; ++i2) {
            var r2 = t2._holes[i2], o2 = xe.LineString.apply(this, [r2]);
            e3.push(o2.coordinates);
          }
          return { type: "Polygon", coordinates: e3 };
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Polygon.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPolygon", coordinates: e3 };
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = i2.getGeometryType();
            e3.push(xe[r2].apply(this, [i2]));
          }
          return { type: "GeometryCollection", geometries: e3 };
        } }, Ne = function(t2) {
          this.geometryFactory = t2 || new _e(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ie(this.geometryFactory);
        };
        Ne.prototype.read = function(t2) {
          var e3 = this.parser.read(t2);
          return this.precisionModel.getType() === fe.FIXED && this.reducePrecision(e3), e3;
        }, Ne.prototype.reducePrecision = function(t2) {
          var e3, n2;
          if (t2.coordinate)
            this.precisionModel.makePrecise(t2.coordinate);
          else if (t2.points)
            for (e3 = 0, n2 = t2.points.length; e3 < n2; e3++)
              this.precisionModel.makePrecise(t2.points[e3]);
          else if (t2.geometries)
            for (e3 = 0, n2 = t2.geometries.length; e3 < n2; e3++)
              this.reducePrecision(t2.geometries[e3]);
        };
        var Ce = function() {
          this.parser = new Ie(this.geometryFactory);
        };
        Ce.prototype.write = function(t2) {
          return this.parser.write(t2);
        };
        var Se = function() {
        }, Le = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
        Se.prototype.interfaces_ = function() {
          return [];
        }, Se.prototype.getClass = function() {
          return Se;
        }, Se.opposite = function(t2) {
          return t2 === Se.LEFT ? Se.RIGHT : t2 === Se.RIGHT ? Se.LEFT : t2;
        }, Le.ON.get = function() {
          return 0;
        }, Le.LEFT.get = function() {
          return 1;
        }, Le.RIGHT.get = function() {
          return 2;
        }, Object.defineProperties(Se, Le), (d.prototype = new Error()).name = "EmptyStackException", (y2.prototype = new xt()).add = function(t2) {
          return this.array_.push(t2), true;
        }, y2.prototype.get = function(t2) {
          if (t2 < 0 || t2 >= this.size())
            throw new Error();
          return this.array_[t2];
        }, y2.prototype.push = function(t2) {
          return this.array_.push(t2), t2;
        }, y2.prototype.pop = function(t2) {
          if (0 === this.array_.length)
            throw new d();
          return this.array_.pop();
        }, y2.prototype.peek = function() {
          if (0 === this.array_.length)
            throw new d();
          return this.array_[this.array_.length - 1];
        }, y2.prototype.empty = function() {
          return 0 === this.array_.length;
        }, y2.prototype.isEmpty = function() {
          return this.empty();
        }, y2.prototype.search = function(t2) {
          return this.array_.indexOf(t2);
        }, y2.prototype.size = function() {
          return this.array_.length;
        }, y2.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        };
        var be = function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        };
        be.prototype.getCoordinate = function() {
          return this._minCoord;
        }, be.prototype.getRightmostSide = function(t2, e3) {
          var n2 = this.getRightmostSideOfSegment(t2, e3);
          return n2 < 0 && (n2 = this.getRightmostSideOfSegment(t2, e3 - 1)), n2 < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t2)), n2;
        }, be.prototype.findRightmostEdgeAtVertex = function() {
          var t2 = this._minDe.getEdge().getCoordinates();
          et.isTrue(this._minIndex > 0 && this._minIndex < t2.length, "rightmost point expected to be interior vertex of edge");
          var e3 = t2[this._minIndex - 1], n2 = t2[this._minIndex + 1], i2 = at.computeOrientation(this._minCoord, n2, e3), r2 = false;
          e3.y < this._minCoord.y && n2.y < this._minCoord.y && i2 === at.COUNTERCLOCKWISE ? r2 = true : e3.y > this._minCoord.y && n2.y > this._minCoord.y && i2 === at.CLOCKWISE && (r2 = true), r2 && (this._minIndex = this._minIndex - 1);
        }, be.prototype.getRightmostSideOfSegment = function(t2, e3) {
          var n2 = t2.getEdge().getCoordinates();
          if (e3 < 0 || e3 + 1 >= n2.length)
            return -1;
          if (n2[e3].y === n2[e3 + 1].y)
            return -1;
          var i2 = Se.LEFT;
          return n2[e3].y < n2[e3 + 1].y && (i2 = Se.RIGHT), i2;
        }, be.prototype.getEdge = function() {
          return this._orientedDe;
        }, be.prototype.checkForRightmostCoordinate = function(t2) {
          for (var e3 = t2.getEdge().getCoordinates(), n2 = 0; n2 < e3.length - 1; n2++)
            (null === this._minCoord || e3[n2].x > this._minCoord.x) && (this._minDe = t2, this._minIndex = n2, this._minCoord = e3[n2]);
        }, be.prototype.findRightmostEdgeAtNode = function() {
          var t2 = this._minDe.getNode().getEdges();
          this._minDe = t2.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        }, be.prototype.findEdge = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            n2.isForward() && this.checkForRightmostCoordinate(n2);
          }
          et.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
          this.getRightmostSide(this._minDe, this._minIndex) === Se.LEFT && (this._orientedDe = this._minDe.getSym());
        }, be.prototype.interfaces_ = function() {
          return [];
        }, be.prototype.getClass = function() {
          return be;
        };
        var we = function(t2) {
          function e3(n2, i2) {
            t2.call(this, e3.msgWithCoord(n2, i2)), this.pt = i2 ? new C(i2) : null, this.name = "TopologyException";
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getCoordinate = function() {
            return this.pt;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.msgWithCoord = function(t3, e4) {
            return e4 ? t3 : t3 + " [ " + e4 + " ]";
          }, e3;
        }($), Oe = function() {
          this.array_ = [];
        };
        Oe.prototype.addLast = function(t2) {
          this.array_.push(t2);
        }, Oe.prototype.removeFirst = function() {
          return this.array_.shift();
        }, Oe.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        };
        var Te = function() {
          this._finder = null, this._dirEdgeList = new Nt(), this._nodes = new Nt(), this._rightMostCoord = null, this._env = null, this._finder = new be();
        };
        Te.prototype.clearVisitedEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            t2.next().setVisited(false);
          }
        }, Te.prototype.getRightmostCoordinate = function() {
          return this._rightMostCoord;
        }, Te.prototype.computeNodeDepth = function(t2) {
          for (var e3 = null, n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isVisited() || i2.getSym().isVisited()) {
              e3 = i2;
              break;
            }
          }
          if (null === e3)
            throw new we("unable to find edge to compute depths at " + t2.getCoordinate());
          t2.getEdges().computeDepths(e3);
          for (var r2 = t2.getEdges().iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            o2.setVisited(true), this.copySymDepths(o2);
          }
        }, Te.prototype.computeDepth = function(t2) {
          this.clearVisitedEdges();
          var e3 = this._finder.getEdge();
          e3.setEdgeDepths(Se.RIGHT, t2), this.copySymDepths(e3), this.computeDepths(e3);
        }, Te.prototype.create = function(t2) {
          this.addReachable(t2), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        }, Te.prototype.findResultEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            var e3 = t2.next();
            e3.getDepth(Se.RIGHT) >= 1 && e3.getDepth(Se.LEFT) <= 0 && !e3.isInteriorAreaEdge() && e3.setInResult(true);
          }
        }, Te.prototype.computeDepths = function(t2) {
          var e3 = new Pt(), n2 = new Oe(), i2 = t2.getNode();
          for (n2.addLast(i2), e3.add(i2), t2.setVisited(true); !n2.isEmpty(); ) {
            var r2 = n2.removeFirst();
            e3.add(r2), this.computeNodeDepth(r2);
            for (var o2 = r2.getEdges().iterator(); o2.hasNext(); ) {
              var s2 = o2.next().getSym();
              if (!s2.isVisited()) {
                var a2 = s2.getNode();
                e3.contains(a2) || (n2.addLast(a2), e3.add(a2));
              }
            }
          }
        }, Te.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._rightMostCoord.x < e3._rightMostCoord.x ? -1 : this._rightMostCoord.x > e3._rightMostCoord.x ? 1 : 0;
        }, Te.prototype.getEnvelope = function() {
          if (null === this._env) {
            for (var t2 = new j(), e3 = this._dirEdgeList.iterator(); e3.hasNext(); )
              for (var n2 = e3.next().getEdge().getCoordinates(), i2 = 0; i2 < n2.length - 1; i2++)
                t2.expandToInclude(n2[i2]);
            this._env = t2;
          }
          return this._env;
        }, Te.prototype.addReachable = function(t2) {
          var e3 = new y2();
          for (e3.add(t2); !e3.empty(); ) {
            var n2 = e3.pop();
            this.add(n2, e3);
          }
        }, Te.prototype.copySymDepths = function(t2) {
          var e3 = t2.getSym();
          e3.setDepth(Se.LEFT, t2.getDepth(Se.RIGHT)), e3.setDepth(Se.RIGHT, t2.getDepth(Se.LEFT));
        }, Te.prototype.add = function(t2, e3) {
          t2.setVisited(true), this._nodes.add(t2);
          for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this._dirEdgeList.add(i2);
            var r2 = i2.getSym().getNode();
            r2.isVisited() || e3.push(r2);
          }
        }, Te.prototype.getNodes = function() {
          return this._nodes;
        }, Te.prototype.getDirectedEdges = function() {
          return this._dirEdgeList;
        }, Te.prototype.interfaces_ = function() {
          return [E];
        }, Te.prototype.getClass = function() {
          return Te;
        };
        var Re = function t2() {
          if (this.location = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              this.init(e3.length);
            } else if (Number.isInteger(arguments[0])) {
              var n2 = arguments[0];
              this.init(1), this.location[Se.ON] = n2;
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              if (this.init(i2.location.length), null !== i2)
                for (var r2 = 0; r2 < this.location.length; r2++)
                  this.location[r2] = i2.location[r2];
            }
          } else if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.init(3), this.location[Se.ON] = o2, this.location[Se.LEFT] = s2, this.location[Se.RIGHT] = a2;
          }
        };
        Re.prototype.setAllLocations = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] = t2;
        }, Re.prototype.isNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] !== w.NONE)
              return false;
          return true;
        }, Re.prototype.setAllLocationsIfNull = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] === w.NONE && (this.location[e3] = t2);
        }, Re.prototype.isLine = function() {
          return 1 === this.location.length;
        }, Re.prototype.merge = function(t2) {
          if (t2.location.length > this.location.length) {
            var e3 = new Array(3).fill(null);
            e3[Se.ON] = this.location[Se.ON], e3[Se.LEFT] = w.NONE, e3[Se.RIGHT] = w.NONE, this.location = e3;
          }
          for (var n2 = 0; n2 < this.location.length; n2++)
            this.location[n2] === w.NONE && n2 < t2.location.length && (this.location[n2] = t2.location[n2]);
        }, Re.prototype.getLocations = function() {
          return this.location;
        }, Re.prototype.flip = function() {
          if (this.location.length <= 1)
            return null;
          var t2 = this.location[Se.LEFT];
          this.location[Se.LEFT] = this.location[Se.RIGHT], this.location[Se.RIGHT] = t2;
        }, Re.prototype.toString = function() {
          var t2 = new D();
          return this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.LEFT])), t2.append(w.toLocationSymbol(this.location[Se.ON])), this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.RIGHT])), t2.toString();
        }, Re.prototype.setLocations = function(t2, e3, n2) {
          this.location[Se.ON] = t2, this.location[Se.LEFT] = e3, this.location[Se.RIGHT] = n2;
        }, Re.prototype.get = function(t2) {
          return t2 < this.location.length ? this.location[t2] : w.NONE;
        }, Re.prototype.isArea = function() {
          return this.location.length > 1;
        }, Re.prototype.isAnyNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] === w.NONE)
              return true;
          return false;
        }, Re.prototype.setLocation = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setLocation(Se.ON, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.location[e3] = n2;
          }
        }, Re.prototype.init = function(t2) {
          this.location = new Array(t2).fill(null), this.setAllLocations(w.NONE);
        }, Re.prototype.isEqualOnSide = function(t2, e3) {
          return this.location[e3] === t2.location[e3];
        }, Re.prototype.allPositionsEqual = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            if (this.location[e3] !== t2)
              return false;
          return true;
        }, Re.prototype.interfaces_ = function() {
          return [];
        }, Re.prototype.getClass = function() {
          return Re;
        };
        var Pe = function t2() {
          if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
            if (Number.isInteger(arguments[0])) {
              var e3 = arguments[0];
              this.elt[0] = new Re(e3), this.elt[1] = new Re(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.elt[0] = new Re(n2.elt[0]), this.elt[1] = new Re(n2.elt[1]);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.elt[0] = new Re(w.NONE), this.elt[1] = new Re(w.NONE), this.elt[i2].setLocation(r2);
          } else if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.elt[0] = new Re(o2, s2, a2), this.elt[1] = new Re(o2, s2, a2);
          } else if (4 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2], p2 = arguments[3];
            this.elt[0] = new Re(w.NONE, w.NONE, w.NONE), this.elt[1] = new Re(w.NONE, w.NONE, w.NONE), this.elt[u2].setLocations(l2, c2, p2);
          }
        };
        Pe.prototype.getGeometryCount = function() {
          var t2 = 0;
          return this.elt[0].isNull() || t2++, this.elt[1].isNull() || t2++, t2;
        }, Pe.prototype.setAllLocations = function(t2, e3) {
          this.elt[t2].setAllLocations(e3);
        }, Pe.prototype.isNull = function(t2) {
          return this.elt[t2].isNull();
        }, Pe.prototype.setAllLocationsIfNull = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setAllLocationsIfNull(0, t2), this.setAllLocationsIfNull(1, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.elt[e3].setAllLocationsIfNull(n2);
          }
        }, Pe.prototype.isLine = function(t2) {
          return this.elt[t2].isLine();
        }, Pe.prototype.merge = function(t2) {
          for (var e3 = 0; e3 < 2; e3++)
            null === this.elt[e3] && null !== t2.elt[e3] ? this.elt[e3] = new Re(t2.elt[e3]) : this.elt[e3].merge(t2.elt[e3]);
        }, Pe.prototype.flip = function() {
          this.elt[0].flip(), this.elt[1].flip();
        }, Pe.prototype.getLocation = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].get(Se.ON);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return this.elt[e3].get(n2);
          }
        }, Pe.prototype.toString = function() {
          var t2 = new D();
          return null !== this.elt[0] && (t2.append("A:"), t2.append(this.elt[0].toString())), null !== this.elt[1] && (t2.append(" B:"), t2.append(this.elt[1].toString())), t2.toString();
        }, Pe.prototype.isArea = function() {
          if (0 === arguments.length)
            return this.elt[0].isArea() || this.elt[1].isArea();
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].isArea();
          }
        }, Pe.prototype.isAnyNull = function(t2) {
          return this.elt[t2].isAnyNull();
        }, Pe.prototype.setLocation = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this.elt[t2].setLocation(Se.ON, e3);
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this.elt[n2].setLocation(i2, r2);
          }
        }, Pe.prototype.isEqualOnSide = function(t2, e3) {
          return this.elt[0].isEqualOnSide(t2.elt[0], e3) && this.elt[1].isEqualOnSide(t2.elt[1], e3);
        }, Pe.prototype.allPositionsEqual = function(t2, e3) {
          return this.elt[t2].allPositionsEqual(e3);
        }, Pe.prototype.toLine = function(t2) {
          this.elt[t2].isArea() && (this.elt[t2] = new Re(this.elt[t2].location[0]));
        }, Pe.prototype.interfaces_ = function() {
          return [];
        }, Pe.prototype.getClass = function() {
          return Pe;
        }, Pe.toLineLabel = function(t2) {
          for (var e3 = new Pe(w.NONE), n2 = 0; n2 < 2; n2++)
            e3.setLocation(n2, t2.getLocation(n2));
          return e3;
        };
        var De = function() {
          this._startDe = null, this._maxNodeDegree = -1, this._edges = new Nt(), this._pts = new Nt(), this._label = new Pe(w.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Nt(), this._geometryFactory = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._geometryFactory = e3, this.computePoints(t2), this.computeRing();
        };
        De.prototype.computeRing = function() {
          if (null !== this._ring)
            return null;
          for (var t2 = new Array(this._pts.size()).fill(null), e3 = 0; e3 < this._pts.size(); e3++)
            t2[e3] = this._pts.get(e3);
          this._ring = this._geometryFactory.createLinearRing(t2), this._isHole = at.isCCW(this._ring.getCoordinates());
        }, De.prototype.isIsolated = function() {
          return 1 === this._label.getGeometryCount();
        }, De.prototype.computePoints = function(t2) {
          this._startDe = t2;
          var e3 = t2, n2 = true;
          do {
            if (null === e3)
              throw new we("Found null DirectedEdge");
            if (e3.getEdgeRing() === this)
              throw new we("Directed Edge visited twice during ring-building at " + e3.getCoordinate());
            this._edges.add(e3);
            var i2 = e3.getLabel();
            et.isTrue(i2.isArea()), this.mergeLabel(i2), this.addPoints(e3.getEdge(), e3.isForward(), n2), n2 = false, this.setEdgeRing(e3, this), e3 = this.getNext(e3);
          } while (e3 !== this._startDe);
        }, De.prototype.getLinearRing = function() {
          return this._ring;
        }, De.prototype.getCoordinate = function(t2) {
          return this._pts.get(t2);
        }, De.prototype.computeMaxNodeDegree = function() {
          this._maxNodeDegree = 0;
          var t2 = this._startDe;
          do {
            var e3 = t2.getNode().getEdges().getOutgoingDegree(this);
            e3 > this._maxNodeDegree && (this._maxNodeDegree = e3), t2 = this.getNext(t2);
          } while (t2 !== this._startDe);
          this._maxNodeDegree *= 2;
        }, De.prototype.addPoints = function(t2, e3, n2) {
          var i2 = t2.getCoordinates();
          if (e3) {
            var r2 = 1;
            n2 && (r2 = 0);
            for (var o2 = r2; o2 < i2.length; o2++)
              this._pts.add(i2[o2]);
          } else {
            var s2 = i2.length - 2;
            n2 && (s2 = i2.length - 1);
            for (var a2 = s2; a2 >= 0; a2--)
              this._pts.add(i2[a2]);
          }
        }, De.prototype.isHole = function() {
          return this._isHole;
        }, De.prototype.setInResult = function() {
          var t2 = this._startDe;
          do {
            t2.getEdge().setInResult(true), t2 = t2.getNext();
          } while (t2 !== this._startDe);
        }, De.prototype.containsPoint = function(t2) {
          var e3 = this.getLinearRing();
          if (!e3.getEnvelopeInternal().contains(t2))
            return false;
          if (!at.isPointInRing(t2, e3.getCoordinates()))
            return false;
          for (var n2 = this._holes.iterator(); n2.hasNext(); ) {
            if (n2.next().containsPoint(t2))
              return false;
          }
          return true;
        }, De.prototype.addHole = function(t2) {
          this._holes.add(t2);
        }, De.prototype.isShell = function() {
          return null === this._shell;
        }, De.prototype.getLabel = function() {
          return this._label;
        }, De.prototype.getEdges = function() {
          return this._edges;
        }, De.prototype.getMaxNodeDegree = function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        }, De.prototype.getShell = function() {
          return this._shell;
        }, De.prototype.mergeLabel = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.mergeLabel(t2, 0), this.mergeLabel(t2, 1);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = e3.getLocation(n2, Se.RIGHT);
            if (i2 === w.NONE)
              return null;
            if (this._label.getLocation(n2) === w.NONE)
              return this._label.setLocation(n2, i2), null;
          }
        }, De.prototype.setShell = function(t2) {
          this._shell = t2, null !== t2 && t2.addHole(this);
        }, De.prototype.toPolygon = function(t2) {
          for (var e3 = new Array(this._holes.size()).fill(null), n2 = 0; n2 < this._holes.size(); n2++)
            e3[n2] = this._holes.get(n2).getLinearRing();
          return t2.createPolygon(this.getLinearRing(), e3);
        }, De.prototype.interfaces_ = function() {
          return [];
        }, De.prototype.getClass = function() {
          return De;
        };
        var Me = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setMinEdgeRing(e4);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNextMin();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Ae = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildMinimalRings = function() {
            var t3 = new Nt(), e4 = this._startDe;
            do {
              if (null === e4.getMinEdgeRing()) {
                var n2 = new Me(e4, this._geometryFactory);
                t3.add(n2);
              }
              e4 = e4.getNext();
            } while (e4 !== this._startDe);
            return t3;
          }, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setEdgeRing(e4);
          }, e3.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
            var t3 = this._startDe;
            do {
              t3.getNode().getEdges().linkMinimalDirectedEdges(this), t3 = t3.getNext();
            } while (t3 !== this._startDe);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNext();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Fe = function() {
          if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._label = t2;
          }
        };
        Fe.prototype.setVisited = function(t2) {
          this._isVisited = t2;
        }, Fe.prototype.setInResult = function(t2) {
          this._isInResult = t2;
        }, Fe.prototype.isCovered = function() {
          return this._isCovered;
        }, Fe.prototype.isCoveredSet = function() {
          return this._isCoveredSet;
        }, Fe.prototype.setLabel = function(t2) {
          this._label = t2;
        }, Fe.prototype.getLabel = function() {
          return this._label;
        }, Fe.prototype.setCovered = function(t2) {
          this._isCovered = t2, this._isCoveredSet = true;
        }, Fe.prototype.updateIM = function(t2) {
          et.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t2);
        }, Fe.prototype.isInResult = function() {
          return this._isInResult;
        }, Fe.prototype.isVisited = function() {
          return this._isVisited;
        }, Fe.prototype.interfaces_ = function() {
          return [];
        }, Fe.prototype.getClass = function() {
          return Fe;
        };
        var Ge = function(t2) {
          function e3() {
            t2.call(this), this._coord = null, this._edges = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._coord = e4, this._edges = n2, this._label = new Pe(0, w.NONE);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isIncidentEdgeInResult = function() {
            for (var t3 = this.getEdges().getEdges().iterator(); t3.hasNext(); ) {
              if (t3.next().getEdge().isInResult())
                return true;
            }
            return false;
          }, e3.prototype.isIsolated = function() {
            return 1 === this._label.getGeometryCount();
          }, e3.prototype.getCoordinate = function() {
            return this._coord;
          }, e3.prototype.print = function(t3) {
            t3.println("node " + this._coord + " lbl: " + this._label);
          }, e3.prototype.computeIM = function(t3) {
          }, e3.prototype.computeMergedLocation = function(t3, e4) {
            var n2 = w.NONE;
            if (n2 = this._label.getLocation(e4), !t3.isNull(e4)) {
              var i2 = t3.getLocation(e4);
              n2 !== w.BOUNDARY && (n2 = i2);
            }
            return n2;
          }, e3.prototype.setLabel = function() {
            if (2 !== arguments.length)
              return t2.prototype.setLabel.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            null === this._label ? this._label = new Pe(e4, n2) : this._label.setLocation(e4, n2);
          }, e3.prototype.getEdges = function() {
            return this._edges;
          }, e3.prototype.mergeLabel = function() {
            if (arguments[0] instanceof e3) {
              var t3 = arguments[0];
              this.mergeLabel(t3._label);
            } else if (arguments[0] instanceof Pe)
              for (var n2 = arguments[0], i2 = 0; i2 < 2; i2++) {
                var r2 = this.computeMergedLocation(n2, i2);
                this._label.getLocation(i2) === w.NONE && this._label.setLocation(i2, r2);
              }
          }, e3.prototype.add = function(t3) {
            this._edges.insert(t3), t3.setNode(this);
          }, e3.prototype.setLabelBoundary = function(t3) {
            if (null === this._label)
              return null;
            var e4 = w.NONE;
            null !== this._label && (e4 = this._label.getLocation(t3));
            var n2 = null;
            switch (e4) {
              case w.BOUNDARY:
                n2 = w.INTERIOR;
                break;
              case w.INTERIOR:
              default:
                n2 = w.BOUNDARY;
            }
            this._label.setLocation(t3, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Fe), qe = function() {
          this.nodeMap = new p(), this.nodeFact = null;
          var t2 = arguments[0];
          this.nodeFact = t2;
        };
        qe.prototype.find = function(t2) {
          return this.nodeMap.get(t2);
        }, qe.prototype.addNode = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0], e3 = this.nodeMap.get(t2);
            return null === e3 && (e3 = this.nodeFact.createNode(t2), this.nodeMap.put(t2, e3)), e3;
          }
          if (arguments[0] instanceof Ge) {
            var n2 = arguments[0], i2 = this.nodeMap.get(n2.getCoordinate());
            return null === i2 ? (this.nodeMap.put(n2.getCoordinate(), n2), n2) : (i2.mergeLabel(n2), i2);
          }
        }, qe.prototype.print = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, qe.prototype.iterator = function() {
          return this.nodeMap.values().iterator();
        }, qe.prototype.values = function() {
          return this.nodeMap.values();
        }, qe.prototype.getBoundaryNodes = function(t2) {
          for (var e3 = new Nt(), n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.getLabel().getLocation(t2) === w.BOUNDARY && e3.add(i2);
          }
          return e3;
        }, qe.prototype.add = function(t2) {
          var e3 = t2.getCoordinate();
          this.addNode(e3).add(t2);
        }, qe.prototype.interfaces_ = function() {
          return [];
        }, qe.prototype.getClass = function() {
          return qe;
        };
        var Be = function() {
        }, Ve = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
        Be.prototype.interfaces_ = function() {
          return [];
        }, Be.prototype.getClass = function() {
          return Be;
        }, Be.isNorthern = function(t2) {
          return t2 === Be.NE || t2 === Be.NW;
        }, Be.isOpposite = function(t2, e3) {
          if (t2 === e3)
            return false;
          return 2 === (t2 - e3 + 4) % 4;
        }, Be.commonHalfPlane = function(t2, e3) {
          if (t2 === e3)
            return t2;
          if (2 === (t2 - e3 + 4) % 4)
            return -1;
          var n2 = t2 < e3 ? t2 : e3;
          return 0 === n2 && 3 === (t2 > e3 ? t2 : e3) ? 3 : n2;
        }, Be.isInHalfPlane = function(t2, e3) {
          return e3 === Be.SE ? t2 === Be.SE || t2 === Be.SW : t2 === e3 || t2 === e3 + 1;
        }, Be.quadrant = function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === t2 && 0 === e3)
              throw new m("Cannot compute the quadrant for point ( " + t2 + ", " + e3 + " )");
            return t2 >= 0 ? e3 >= 0 ? Be.NE : Be.SE : e3 >= 0 ? Be.NW : Be.SW;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var n2 = arguments[0], i2 = arguments[1];
            if (i2.x === n2.x && i2.y === n2.y)
              throw new m("Cannot compute the quadrant for two identical points " + n2);
            return i2.x >= n2.x ? i2.y >= n2.y ? Be.NE : Be.SE : i2.y >= n2.y ? Be.NW : Be.SW;
          }
        }, Ve.NE.get = function() {
          return 0;
        }, Ve.NW.get = function() {
          return 1;
        }, Ve.SW.get = function() {
          return 2;
        }, Ve.SE.get = function() {
          return 3;
        }, Object.defineProperties(Be, Ve);
        var Ue = function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._edge = t2;
          } else if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._edge = e3, this.init(n2, i2), this._label = null;
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            this._edge = r2, this.init(o2, s2), this._label = a2;
          }
        };
        Ue.prototype.compareDirection = function(t2) {
          return this._dx === t2._dx && this._dy === t2._dy ? 0 : this._quadrant > t2._quadrant ? 1 : this._quadrant < t2._quadrant ? -1 : at.computeOrientation(t2._p0, t2._p1, this._p1);
        }, Ue.prototype.getDy = function() {
          return this._dy;
        }, Ue.prototype.getCoordinate = function() {
          return this._p0;
        }, Ue.prototype.setNode = function(t2) {
          this._node = t2;
        }, Ue.prototype.print = function(t2) {
          var e3 = Math.atan2(this._dy, this._dx), n2 = this.getClass().getName(), i2 = n2.lastIndexOf("."), r2 = n2.substring(i2 + 1);
          t2.print("  " + r2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e3 + "   " + this._label);
        }, Ue.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compareDirection(e3);
        }, Ue.prototype.getDirectedCoordinate = function() {
          return this._p1;
        }, Ue.prototype.getDx = function() {
          return this._dx;
        }, Ue.prototype.getLabel = function() {
          return this._label;
        }, Ue.prototype.getEdge = function() {
          return this._edge;
        }, Ue.prototype.getQuadrant = function() {
          return this._quadrant;
        }, Ue.prototype.getNode = function() {
          return this._node;
        }, Ue.prototype.toString = function() {
          var t2 = Math.atan2(this._dy, this._dx), e3 = this.getClass().getName(), n2 = e3.lastIndexOf(".");
          return "  " + e3.substring(n2 + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t2 + "   " + this._label;
        }, Ue.prototype.computeLabel = function(t2) {
        }, Ue.prototype.init = function(t2, e3) {
          this._p0 = t2, this._p1 = e3, this._dx = e3.x - t2.x, this._dy = e3.y - t2.y, this._quadrant = Be.quadrant(this._dx, this._dy), et.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found");
        }, Ue.prototype.interfaces_ = function() {
          return [E];
        }, Ue.prototype.getClass = function() {
          return Ue;
        };
        var ze = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            if (t2.call(this, e4), this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n2, n2)
              this.init(e4.getCoordinate(0), e4.getCoordinate(1));
            else {
              var i2 = e4.getNumPoints() - 1;
              this.init(e4.getCoordinate(i2), e4.getCoordinate(i2 - 1));
            }
            this.computeDirectedLabel();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getNextMin = function() {
            return this._nextMin;
          }, e3.prototype.getDepth = function(t3) {
            return this._depth[t3];
          }, e3.prototype.setVisited = function(t3) {
            this._isVisited = t3;
          }, e3.prototype.computeDirectedLabel = function() {
            this._label = new Pe(this._edge.getLabel()), this._isForward || this._label.flip();
          }, e3.prototype.getNext = function() {
            return this._next;
          }, e3.prototype.setDepth = function(t3, e4) {
            if (-999 !== this._depth[t3] && this._depth[t3] !== e4)
              throw new we("assigned depths do not match", this.getCoordinate());
            this._depth[t3] = e4;
          }, e3.prototype.isInteriorAreaEdge = function() {
            for (var t3 = true, e4 = 0; e4 < 2; e4++)
              this._label.isArea(e4) && this._label.getLocation(e4, Se.LEFT) === w.INTERIOR && this._label.getLocation(e4, Se.RIGHT) === w.INTERIOR || (t3 = false);
            return t3;
          }, e3.prototype.setNextMin = function(t3) {
            this._nextMin = t3;
          }, e3.prototype.print = function(e4) {
            t2.prototype.print.call(this, e4), e4.print(" " + this._depth[Se.LEFT] + "/" + this._depth[Se.RIGHT]), e4.print(" (" + this.getDepthDelta() + ")"), this._isInResult && e4.print(" inResult");
          }, e3.prototype.setMinEdgeRing = function(t3) {
            this._minEdgeRing = t3;
          }, e3.prototype.isLineEdge = function() {
            var t3 = this._label.isLine(0) || this._label.isLine(1), e4 = !this._label.isArea(0) || this._label.allPositionsEqual(0, w.EXTERIOR), n2 = !this._label.isArea(1) || this._label.allPositionsEqual(1, w.EXTERIOR);
            return t3 && e4 && n2;
          }, e3.prototype.setEdgeRing = function(t3) {
            this._edgeRing = t3;
          }, e3.prototype.getMinEdgeRing = function() {
            return this._minEdgeRing;
          }, e3.prototype.getDepthDelta = function() {
            var t3 = this._edge.getDepthDelta();
            return this._isForward || (t3 = -t3), t3;
          }, e3.prototype.setInResult = function(t3) {
            this._isInResult = t3;
          }, e3.prototype.getSym = function() {
            return this._sym;
          }, e3.prototype.isForward = function() {
            return this._isForward;
          }, e3.prototype.getEdge = function() {
            return this._edge;
          }, e3.prototype.printEdge = function(t3) {
            this.print(t3), t3.print(" "), this._isForward ? this._edge.print(t3) : this._edge.printReverse(t3);
          }, e3.prototype.setSym = function(t3) {
            this._sym = t3;
          }, e3.prototype.setVisitedEdge = function(t3) {
            this.setVisited(t3), this._sym.setVisited(t3);
          }, e3.prototype.setEdgeDepths = function(t3, e4) {
            var n2 = this.getEdge().getDepthDelta();
            this._isForward || (n2 = -n2);
            var i2 = 1;
            t3 === Se.LEFT && (i2 = -1);
            var r2 = Se.opposite(t3), o2 = e4 + n2 * i2;
            this.setDepth(t3, e4), this.setDepth(r2, o2);
          }, e3.prototype.getEdgeRing = function() {
            return this._edgeRing;
          }, e3.prototype.isInResult = function() {
            return this._isInResult;
          }, e3.prototype.setNext = function(t3) {
            this._next = t3;
          }, e3.prototype.isVisited = function() {
            return this._isVisited;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.depthFactor = function(t3, e4) {
            return t3 === w.EXTERIOR && e4 === w.INTERIOR ? 1 : t3 === w.INTERIOR && e4 === w.EXTERIOR ? -1 : 0;
          }, e3;
        }(Ue), Xe = function() {
        };
        Xe.prototype.createNode = function(t2) {
          return new Ge(t2, null);
        }, Xe.prototype.interfaces_ = function() {
          return [];
        }, Xe.prototype.getClass = function() {
          return Xe;
        };
        var Ye = function() {
          if (this._edges = new Nt(), this._nodes = null, this._edgeEndList = new Nt(), 0 === arguments.length)
            this._nodes = new qe(new Xe());
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._nodes = new qe(t2);
          }
        };
        Ye.prototype.printEdges = function(t2) {
          t2.println("Edges:");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            t2.println("edge " + e3 + ":");
            var n2 = this._edges.get(e3);
            n2.print(t2), n2.eiList.print(t2);
          }
        }, Ye.prototype.find = function(t2) {
          return this._nodes.find(t2);
        }, Ye.prototype.addNode = function() {
          if (arguments[0] instanceof Ge) {
            var t2 = arguments[0];
            return this._nodes.addNode(t2);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return this._nodes.addNode(e3);
          }
        }, Ye.prototype.getNodeIterator = function() {
          return this._nodes.iterator();
        }, Ye.prototype.linkResultDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkResultDirectedEdges();
          }
        }, Ye.prototype.debugPrintln = function(t2) {
          Y.out.println(t2);
        }, Ye.prototype.isBoundaryNode = function(t2, e3) {
          var n2 = this._nodes.find(e3);
          if (null === n2)
            return false;
          var i2 = n2.getLabel();
          return null !== i2 && i2.getLocation(t2) === w.BOUNDARY;
        }, Ye.prototype.linkAllDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkAllDirectedEdges();
          }
        }, Ye.prototype.matchInSameDirection = function(t2, e3, n2, i2) {
          return !!t2.equals(n2) && (at.computeOrientation(t2, e3, i2) === at.COLLINEAR && Be.quadrant(t2, e3) === Be.quadrant(n2, i2));
        }, Ye.prototype.getEdgeEnds = function() {
          return this._edgeEndList;
        }, Ye.prototype.debugPrint = function(t2) {
          Y.out.print(t2);
        }, Ye.prototype.getEdgeIterator = function() {
          return this._edges.iterator();
        }, Ye.prototype.findEdgeInSameDirection = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (this.matchInSameDirection(t2, e3, r2[0], r2[1]))
              return i2;
            if (this.matchInSameDirection(t2, e3, r2[r2.length - 1], r2[r2.length - 2]))
              return i2;
          }
          return null;
        }, Ye.prototype.insertEdge = function(t2) {
          this._edges.add(t2);
        }, Ye.prototype.findEdgeEnd = function(t2) {
          for (var e3 = this.getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (n2.getEdge() === t2)
              return n2;
          }
          return null;
        }, Ye.prototype.addEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this._edges.add(n2);
            var i2 = new ze(n2, true), r2 = new ze(n2, false);
            i2.setSym(r2), r2.setSym(i2), this.add(i2), this.add(r2);
          }
        }, Ye.prototype.add = function(t2) {
          this._nodes.add(t2), this._edgeEndList.add(t2);
        }, Ye.prototype.getNodes = function() {
          return this._nodes.values();
        }, Ye.prototype.findEdge = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (t2.equals(r2[0]) && e3.equals(r2[1]))
              return i2;
          }
          return null;
        }, Ye.prototype.interfaces_ = function() {
          return [];
        }, Ye.prototype.getClass = function() {
          return Ye;
        }, Ye.linkResultDirectedEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            e3.next().getEdges().linkResultDirectedEdges();
          }
        };
        var ke = function() {
          this._geometryFactory = null, this._shellList = new Nt();
          var t2 = arguments[0];
          this._geometryFactory = t2;
        };
        ke.prototype.sortShellsAndHoles = function(t2, e3, n2) {
          for (var i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() ? n2.add(r2) : e3.add(r2);
          }
        }, ke.prototype.computePolygons = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().toPolygon(this._geometryFactory);
            e3.add(i2);
          }
          return e3;
        }, ke.prototype.placeFreeHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (null === i2.getShell()) {
              var r2 = this.findEdgeRingContaining(i2, t2);
              if (null === r2)
                throw new we("unable to assign hole to a shell", i2.getCoordinate(0));
              i2.setShell(r2);
            }
          }
        }, ke.prototype.buildMinimalEdgeRings = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            if (o2.getMaxNodeDegree() > 2) {
              o2.linkDirectedEdgesForMinimalEdgeRings();
              var s2 = o2.buildMinimalRings(), a2 = this.findShell(s2);
              null !== a2 ? (this.placePolygonHoles(a2, s2), e3.add(a2)) : n2.addAll(s2);
            } else
              i2.add(o2);
          }
          return i2;
        }, ke.prototype.containsPoint = function(t2) {
          for (var e3 = this._shellList.iterator(); e3.hasNext(); ) {
            if (e3.next().containsPoint(t2))
              return true;
          }
          return false;
        }, ke.prototype.buildMaximalEdgeRings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isInResult() && i2.getLabel().isArea() && null === i2.getEdgeRing()) {
              var r2 = new Ae(i2, this._geometryFactory);
              e3.add(r2), r2.setInResult();
            }
          }
          return e3;
        }, ke.prototype.placePolygonHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.isHole() && i2.setShell(t2);
          }
        }, ke.prototype.getPolygons = function() {
          return this.computePolygons(this._shellList);
        }, ke.prototype.findEdgeRingContaining = function(t2, e3) {
          for (var n2 = t2.getLinearRing(), i2 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), o2 = null, s2 = null, a2 = e3.iterator(); a2.hasNext(); ) {
            var u2 = a2.next(), l2 = u2.getLinearRing(), c2 = l2.getEnvelopeInternal();
            null !== o2 && (s2 = o2.getLinearRing().getEnvelopeInternal());
            var p2 = false;
            c2.contains(i2) && at.isPointInRing(r2, l2.getCoordinates()) && (p2 = true), p2 && (null === o2 || s2.contains(c2)) && (o2 = u2);
          }
          return o2;
        }, ke.prototype.findShell = function(t2) {
          for (var e3 = 0, n2 = null, i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() || (n2 = r2, e3++);
          }
          return et.isTrue(e3 <= 1, "found two shells in MinimalEdgeRing list"), n2;
        }, ke.prototype.add = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.add(t2.getEdgeEnds(), t2.getNodes());
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            Ye.linkResultDirectedEdges(n2);
            var i2 = this.buildMaximalEdgeRings(e3), r2 = new Nt(), o2 = this.buildMinimalEdgeRings(i2, this._shellList, r2);
            this.sortShellsAndHoles(o2, this._shellList, r2), this.placeFreeHoles(this._shellList, r2);
          }
        }, ke.prototype.interfaces_ = function() {
          return [];
        }, ke.prototype.getClass = function() {
          return ke;
        };
        var je = function() {
        };
        je.prototype.getBounds = function() {
        }, je.prototype.interfaces_ = function() {
          return [];
        }, je.prototype.getClass = function() {
          return je;
        };
        var He = function() {
          this._bounds = null, this._item = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._bounds = t2, this._item = e3;
        };
        He.prototype.getItem = function() {
          return this._item;
        }, He.prototype.getBounds = function() {
          return this._bounds;
        }, He.prototype.interfaces_ = function() {
          return [je, e];
        }, He.prototype.getClass = function() {
          return He;
        };
        var We = function() {
          this._size = null, this._items = null, this._size = 0, this._items = new Nt(), this._items.add(null);
        };
        We.prototype.poll = function() {
          if (this.isEmpty())
            return null;
          var t2 = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t2;
        }, We.prototype.size = function() {
          return this._size;
        }, We.prototype.reorder = function(t2) {
          for (var e3 = null, n2 = this._items.get(t2); 2 * t2 <= this._size && ((e3 = 2 * t2) !== this._size && this._items.get(e3 + 1).compareTo(this._items.get(e3)) < 0 && e3++, this._items.get(e3).compareTo(n2) < 0); t2 = e3)
            this._items.set(t2, this._items.get(e3));
          this._items.set(t2, n2);
        }, We.prototype.clear = function() {
          this._size = 0, this._items.clear();
        }, We.prototype.isEmpty = function() {
          return 0 === this._size;
        }, We.prototype.add = function(t2) {
          this._items.add(null), this._size += 1;
          var e3 = this._size;
          for (this._items.set(0, t2); t2.compareTo(this._items.get(Math.trunc(e3 / 2))) < 0; e3 /= 2)
            this._items.set(e3, this._items.get(Math.trunc(e3 / 2)));
          this._items.set(e3, t2);
        }, We.prototype.interfaces_ = function() {
          return [];
        }, We.prototype.getClass = function() {
          return We;
        };
        var Ke = function() {
        };
        Ke.prototype.visitItem = function(t2) {
        }, Ke.prototype.interfaces_ = function() {
          return [];
        }, Ke.prototype.getClass = function() {
          return Ke;
        };
        var Je = function() {
        };
        Je.prototype.insert = function(t2, e3) {
        }, Je.prototype.remove = function(t2, e3) {
        }, Je.prototype.query = function() {
        }, Je.prototype.interfaces_ = function() {
          return [];
        }, Je.prototype.getClass = function() {
          return Je;
        };
        var Qe = function() {
          if (this._childBoundables = new Nt(), this._bounds = null, this._level = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._level = t2;
          }
        }, Ze = { serialVersionUID: { configurable: true } };
        Qe.prototype.getLevel = function() {
          return this._level;
        }, Qe.prototype.size = function() {
          return this._childBoundables.size();
        }, Qe.prototype.getChildBoundables = function() {
          return this._childBoundables;
        }, Qe.prototype.addChildBoundable = function(t2) {
          et.isTrue(null === this._bounds), this._childBoundables.add(t2);
        }, Qe.prototype.isEmpty = function() {
          return this._childBoundables.isEmpty();
        }, Qe.prototype.getBounds = function() {
          return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
        }, Qe.prototype.interfaces_ = function() {
          return [je, e];
        }, Qe.prototype.getClass = function() {
          return Qe;
        }, Ze.serialVersionUID.get = function() {
          return 6493722185909574e3;
        }, Object.defineProperties(Qe, Ze);
        var $e = function() {
        };
        $e.reverseOrder = function() {
          return { compare: function(t2, e3) {
            return e3.compareTo(t2);
          } };
        }, $e.min = function(t2) {
          return $e.sort(t2), t2.get(0);
        }, $e.sort = function(t2, e3) {
          var n2 = t2.toArray();
          e3 ? Gt.sort(n2, e3) : Gt.sort(n2);
          for (var i2 = t2.iterator(), r2 = 0, o2 = n2.length; r2 < o2; r2++)
            i2.next(), i2.set(n2[r2]);
        }, $e.singletonList = function(t2) {
          var e3 = new Nt();
          return e3.add(t2), e3;
        };
        var tn = function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._boundable1 = t2, this._boundable2 = e3, this._itemDistance = n2, this._distance = this.distance();
        };
        tn.prototype.expandToQueue = function(t2, e3) {
          var n2 = tn.isComposite(this._boundable1), i2 = tn.isComposite(this._boundable2);
          if (n2 && i2)
            return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t2, e3), null) : (this.expand(this._boundable2, this._boundable1, t2, e3), null);
          if (n2)
            return this.expand(this._boundable1, this._boundable2, t2, e3), null;
          if (i2)
            return this.expand(this._boundable2, this._boundable1, t2, e3), null;
          throw new m("neither boundable is composite");
        }, tn.prototype.isLeaves = function() {
          return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2));
        }, tn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._distance < e3._distance ? -1 : this._distance > e3._distance ? 1 : 0;
        }, tn.prototype.expand = function(t2, e3, n2, i2) {
          for (var r2 = t2.getChildBoundables().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = new tn(o2, e3, this._itemDistance);
            s2.getDistance() < i2 && n2.add(s2);
          }
        }, tn.prototype.getBoundable = function(t2) {
          return 0 === t2 ? this._boundable1 : this._boundable2;
        }, tn.prototype.getDistance = function() {
          return this._distance;
        }, tn.prototype.distance = function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        }, tn.prototype.interfaces_ = function() {
          return [E];
        }, tn.prototype.getClass = function() {
          return tn;
        }, tn.area = function(t2) {
          return t2.getBounds().getArea();
        }, tn.isComposite = function(t2) {
          return t2 instanceof Qe;
        };
        var en = function t2() {
          if (this._root = null, this._built = false, this._itemBoundables = new Nt(), this._nodeCapacity = null, 0 === arguments.length) {
            var e3 = t2.DEFAULT_NODE_CAPACITY;
            this._nodeCapacity = e3;
          } else if (1 === arguments.length) {
            var n2 = arguments[0];
            et.isTrue(n2 > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n2;
          }
        }, nn = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
        en.prototype.getNodeCapacity = function() {
          return this._nodeCapacity;
        }, en.prototype.lastNode = function(t2) {
          return t2.get(t2.size() - 1);
        }, en.prototype.size = function() {
          if (0 === arguments.length)
            return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (1 === arguments.length) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              n2 instanceof Qe ? t2 += this.size(n2) : n2 instanceof He && (t2 += 1);
            }
            return t2;
          }
        }, en.prototype.removeItem = function(t2, e3) {
          for (var n2 = null, i2 = t2.getChildBoundables().iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2 instanceof He && r2.getItem() === e3 && (n2 = r2);
          }
          return null !== n2 && (t2.getChildBoundables().remove(n2), true);
        }, en.prototype.itemsTree = function() {
          if (0 === arguments.length) {
            this.build();
            var t2 = this.itemsTree(this._root);
            return null === t2 ? new Nt() : t2;
          }
          if (1 === arguments.length) {
            for (var e3 = arguments[0], n2 = new Nt(), i2 = e3.getChildBoundables().iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              if (r2 instanceof Qe) {
                var o2 = this.itemsTree(r2);
                null !== o2 && n2.add(o2);
              } else
                r2 instanceof He ? n2.add(r2.getItem()) : et.shouldNeverReachHere();
            }
            return n2.size() <= 0 ? null : n2;
          }
        }, en.prototype.insert = function(t2, e3) {
          et.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new He(t2, e3));
        }, en.prototype.boundablesAtLevel = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new Nt();
            return this.boundablesAtLevel(t2, this._root, e3), e3;
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            if (et.isTrue(n2 > -2), i2.getLevel() === n2)
              return r2.add(i2), null;
            for (var o2 = i2.getChildBoundables().iterator(); o2.hasNext(); ) {
              var s2 = o2.next();
              s2 instanceof Qe ? this.boundablesAtLevel(n2, s2, r2) : (et.isTrue(s2 instanceof He), -1 === n2 && r2.add(s2));
            }
            return null;
          }
        }, en.prototype.query = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.build();
            var e3 = new Nt();
            return this.isEmpty() ? e3 : (this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.query(t2, this._root, e3), e3);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            if (this.build(), this.isEmpty())
              return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), n2) && this.query(n2, this._root, i2);
          } else if (3 === arguments.length) {
            if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = o2.getChildBoundables(), u2 = 0; u2 < a2.size(); u2++) {
                var l2 = a2.get(u2);
                this.getIntersectsOp().intersects(l2.getBounds(), r2) && (l2 instanceof Qe ? this.query(r2, l2, s2) : l2 instanceof He ? s2.visitItem(l2.getItem()) : et.shouldNeverReachHere());
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = p2.getChildBoundables(), g2 = 0; g2 < f2.size(); g2++) {
                var d2 = f2.get(g2);
                this.getIntersectsOp().intersects(d2.getBounds(), c2) && (d2 instanceof Qe ? this.query(c2, d2, h2) : d2 instanceof He ? h2.add(d2.getItem()) : et.shouldNeverReachHere());
              }
          }
        }, en.prototype.build = function() {
          if (this._built)
            return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
        }, en.prototype.getRoot = function() {
          return this.build(), this._root;
        }, en.prototype.remove = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.remove(t2, this._root, e3);
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = this.removeItem(i2, r2);
            if (o2)
              return true;
            for (var s2 = null, a2 = i2.getChildBoundables().iterator(); a2.hasNext(); ) {
              var u2 = a2.next();
              if (this.getIntersectsOp().intersects(u2.getBounds(), n2) && (u2 instanceof Qe && (o2 = this.remove(n2, u2, r2)))) {
                s2 = u2;
                break;
              }
            }
            return null !== s2 && s2.getChildBoundables().isEmpty() && i2.getChildBoundables().remove(s2), o2;
          }
        }, en.prototype.createHigherLevels = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = this.createParentBoundables(t2, e3 + 1);
          return 1 === n2.size() ? n2.get(0) : this.createHigherLevels(n2, e3 + 1);
        }, en.prototype.depth = function() {
          if (0 === arguments.length)
            return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (1 === arguments.length) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              if (n2 instanceof Qe) {
                var i2 = this.depth(n2);
                i2 > t2 && (t2 = i2);
              }
            }
            return t2 + 1;
          }
        }, en.prototype.createParentBoundables = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = new Nt();
          n2.add(this.createNode(e3));
          var i2 = new Nt(t2);
          $e.sort(i2, this.getComparator());
          for (var r2 = i2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            this.lastNode(n2).getChildBoundables().size() === this.getNodeCapacity() && n2.add(this.createNode(e3)), this.lastNode(n2).addChildBoundable(o2);
          }
          return n2;
        }, en.prototype.isEmpty = function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        }, en.prototype.interfaces_ = function() {
          return [e];
        }, en.prototype.getClass = function() {
          return en;
        }, en.compareDoubles = function(t2, e3) {
          return t2 > e3 ? 1 : t2 < e3 ? -1 : 0;
        }, nn.IntersectsOp.get = function() {
          return rn;
        }, nn.serialVersionUID.get = function() {
          return -3886435814360241e3;
        }, nn.DEFAULT_NODE_CAPACITY.get = function() {
          return 10;
        }, Object.defineProperties(en, nn);
        var rn = function() {
        }, on = function() {
        };
        on.prototype.distance = function(t2, e3) {
        }, on.prototype.interfaces_ = function() {
          return [];
        }, on.prototype.getClass = function() {
          return on;
        };
        var sn = function(t2) {
          function n2(e3) {
            e3 = e3 || n2.DEFAULT_NODE_CAPACITY, t2.call(this, e3);
          }
          t2 && (n2.__proto__ = t2), (n2.prototype = Object.create(t2 && t2.prototype)).constructor = n2;
          var i2 = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
          return n2.prototype.createParentBoundablesFromVerticalSlices = function(t3, e3) {
            et.isTrue(t3.length > 0);
            for (var n3 = new Nt(), i3 = 0; i3 < t3.length; i3++)
              n3.addAll(this.createParentBoundablesFromVerticalSlice(t3[i3], e3));
            return n3;
          }, n2.prototype.createNode = function(t3) {
            return new an(t3);
          }, n2.prototype.size = function() {
            return 0 === arguments.length ? t2.prototype.size.call(this) : t2.prototype.size.apply(this, arguments);
          }, n2.prototype.insert = function() {
            if (2 !== arguments.length)
              return t2.prototype.insert.apply(this, arguments);
            var e3 = arguments[0], n3 = arguments[1];
            if (e3.isNull())
              return null;
            t2.prototype.insert.call(this, e3, n3);
          }, n2.prototype.getIntersectsOp = function() {
            return n2.intersectsOp;
          }, n2.prototype.verticalSlices = function(t3, e3) {
            for (var n3 = Math.trunc(Math.ceil(t3.size() / e3)), i3 = new Array(e3).fill(null), r2 = t3.iterator(), o2 = 0; o2 < e3; o2++) {
              i3[o2] = new Nt();
              for (var s2 = 0; r2.hasNext() && s2 < n3; ) {
                var a2 = r2.next();
                i3[o2].add(a2), s2++;
              }
            }
            return i3;
          }, n2.prototype.query = function() {
            if (1 === arguments.length) {
              var e3 = arguments[0];
              return t2.prototype.query.call(this, e3);
            }
            if (2 === arguments.length) {
              var n3 = arguments[0], i3 = arguments[1];
              t2.prototype.query.call(this, n3, i3);
            } else if (3 === arguments.length) {
              if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
                t2.prototype.query.call(this, r2, o2, s2);
              } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
                t2.prototype.query.call(this, a2, u2, l2);
              }
            }
          }, n2.prototype.getComparator = function() {
            return n2.yComparator;
          }, n2.prototype.createParentBoundablesFromVerticalSlice = function(e3, n3) {
            return t2.prototype.createParentBoundables.call(this, e3, n3);
          }, n2.prototype.remove = function() {
            if (2 === arguments.length) {
              var e3 = arguments[0], n3 = arguments[1];
              return t2.prototype.remove.call(this, e3, n3);
            }
            return t2.prototype.remove.apply(this, arguments);
          }, n2.prototype.depth = function() {
            return 0 === arguments.length ? t2.prototype.depth.call(this) : t2.prototype.depth.apply(this, arguments);
          }, n2.prototype.createParentBoundables = function(t3, e3) {
            et.isTrue(!t3.isEmpty());
            var i3 = Math.trunc(Math.ceil(t3.size() / this.getNodeCapacity())), r2 = new Nt(t3);
            $e.sort(r2, n2.xComparator);
            var o2 = this.verticalSlices(r2, Math.trunc(Math.ceil(Math.sqrt(i3))));
            return this.createParentBoundablesFromVerticalSlices(o2, e3);
          }, n2.prototype.nearestNeighbour = function() {
            if (1 === arguments.length) {
              if (T(arguments[0], on)) {
                var t3 = arguments[0], e3 = new tn(this.getRoot(), this.getRoot(), t3);
                return this.nearestNeighbour(e3);
              }
              if (arguments[0] instanceof tn) {
                var i3 = arguments[0];
                return this.nearestNeighbour(i3, v.POSITIVE_INFINITY);
              }
            } else if (2 === arguments.length) {
              if (arguments[0] instanceof n2 && T(arguments[1], on)) {
                var r2 = arguments[0], o2 = arguments[1], s2 = new tn(this.getRoot(), r2.getRoot(), o2);
                return this.nearestNeighbour(s2);
              }
              if (arguments[0] instanceof tn && "number" == typeof arguments[1]) {
                var a2 = arguments[0], u2 = arguments[1], l2 = null, c2 = new We();
                for (c2.add(a2); !c2.isEmpty() && u2 > 0; ) {
                  var p2 = c2.poll(), h2 = p2.getDistance();
                  if (h2 >= u2)
                    break;
                  p2.isLeaves() ? (u2 = h2, l2 = p2) : p2.expandToQueue(c2, u2);
                }
                return [l2.getBoundable(0).getItem(), l2.getBoundable(1).getItem()];
              }
            } else if (3 === arguments.length) {
              var f2 = arguments[0], g2 = arguments[1], d2 = arguments[2], y3 = new He(f2, g2), _2 = new tn(this.getRoot(), y3, d2);
              return this.nearestNeighbour(_2)[0];
            }
          }, n2.prototype.interfaces_ = function() {
            return [Je, e];
          }, n2.prototype.getClass = function() {
            return n2;
          }, n2.centreX = function(t3) {
            return n2.avg(t3.getMinX(), t3.getMaxX());
          }, n2.avg = function(t3, e3) {
            return (t3 + e3) / 2;
          }, n2.centreY = function(t3) {
            return n2.avg(t3.getMinY(), t3.getMaxY());
          }, i2.STRtreeNode.get = function() {
            return an;
          }, i2.serialVersionUID.get = function() {
            return 259274702368956900;
          }, i2.xComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreX(e3.getBounds()), n2.centreX(i3.getBounds()));
            } };
          }, i2.yComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreY(e3.getBounds()), n2.centreY(i3.getBounds()));
            } };
          }, i2.intersectsOp.get = function() {
            return { interfaces_: function() {
              return [t2.IntersectsOp];
            }, intersects: function(t3, e3) {
              return t3.intersects(e3);
            } };
          }, i2.DEFAULT_NODE_CAPACITY.get = function() {
            return 10;
          }, Object.defineProperties(n2, i2), n2;
        }(en), an = function(t2) {
          function e3() {
            var e4 = arguments[0];
            t2.call(this, e4);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.computeBounds = function() {
            for (var t3 = null, e4 = this.getChildBoundables().iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              null === t3 ? t3 = new j(n2.getBounds()) : t3.expandToInclude(n2.getBounds());
            }
            return t3;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Qe), un = function() {
        };
        un.prototype.interfaces_ = function() {
          return [];
        }, un.prototype.getClass = function() {
          return un;
        }, un.relativeSign = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
        }, un.compare = function(t2, e3, n2) {
          if (e3.equals2D(n2))
            return 0;
          var i2 = un.relativeSign(e3.x, n2.x), r2 = un.relativeSign(e3.y, n2.y);
          switch (t2) {
            case 0:
              return un.compareValue(i2, r2);
            case 1:
              return un.compareValue(r2, i2);
            case 2:
              return un.compareValue(r2, -i2);
            case 3:
              return un.compareValue(-i2, r2);
            case 4:
              return un.compareValue(-i2, -r2);
            case 5:
              return un.compareValue(-r2, -i2);
            case 6:
              return un.compareValue(-r2, i2);
            case 7:
              return un.compareValue(i2, -r2);
          }
          return et.shouldNeverReachHere("invalid octant value"), 0;
        }, un.compareValue = function(t2, e3) {
          return t2 < 0 ? -1 : t2 > 0 ? 1 : e3 < 0 ? -1 : e3 > 0 ? 1 : 0;
        };
        var ln = function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._segString = t2, this.coord = new C(e3), this.segmentIndex = n2, this._segmentOctant = i2, this._isInterior = !e3.equals2D(t2.getCoordinate(n2));
        };
        ln.prototype.getCoordinate = function() {
          return this.coord;
        }, ln.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex);
        }, ln.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.segmentIndex < e3.segmentIndex ? -1 : this.segmentIndex > e3.segmentIndex ? 1 : this.coord.equals2D(e3.coord) ? 0 : un.compare(this._segmentOctant, this.coord, e3.coord);
        }, ln.prototype.isEndPoint = function(t2) {
          return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t2;
        }, ln.prototype.isInterior = function() {
          return this._isInterior;
        }, ln.prototype.interfaces_ = function() {
          return [E];
        }, ln.prototype.getClass = function() {
          return ln;
        };
        var cn = function() {
          this._nodeMap = new p(), this._edge = null;
          var t2 = arguments[0];
          this._edge = t2;
        };
        cn.prototype.getSplitCoordinates = function() {
          var t2 = new St();
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next();
            this.addEdgeCoordinates(n2, i2, t2), n2 = i2;
          }
          return t2.toCoordinateArray();
        }, cn.prototype.addCollapsedNodes = function() {
          var t2 = new Nt();
          this.findCollapsesFromInsertedNodes(t2), this.findCollapsesFromExistingVertices(t2);
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next().intValue();
            this.add(this._edge.getCoordinate(n2), n2);
          }
        }, cn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, cn.prototype.findCollapsesFromExistingVertices = function(t2) {
          for (var e3 = 0; e3 < this._edge.size() - 2; e3++) {
            var n2 = this._edge.getCoordinate(e3), i2 = this._edge.getCoordinate(e3 + 2);
            n2.equals2D(i2) && t2.add(new M(e3 + 1));
          }
        }, cn.prototype.addEdgeCoordinates = function(t2, e3, n2) {
          var i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          n2.add(new C(t2.coord), false);
          for (var o2 = t2.segmentIndex + 1; o2 <= e3.segmentIndex; o2++)
            n2.add(this._edge.getCoordinate(o2));
          r2 && n2.add(new C(e3.coord));
        }, cn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, cn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, cn.prototype.findCollapseIndex = function(t2, e3, n2) {
          if (!t2.coord.equals2D(e3.coord))
            return false;
          var i2 = e3.segmentIndex - t2.segmentIndex;
          return e3.isInterior() || i2--, 1 === i2 && (n2[0] = t2.segmentIndex + 1, true);
        }, cn.prototype.findCollapsesFromInsertedNodes = function(t2) {
          for (var e3 = new Array(1).fill(null), n2 = this.iterator(), i2 = n2.next(); n2.hasNext(); ) {
            var r2 = n2.next();
            this.findCollapseIndex(i2, r2, e3) && t2.add(new M(e3[0])), i2 = r2;
          }
        }, cn.prototype.getEdge = function() {
          return this._edge;
        }, cn.prototype.addEndpoints = function() {
          var t2 = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t2), t2);
        }, cn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a2 = t2.segmentIndex + 1; a2 <= e3.segmentIndex; a2++)
            o2[s2++] = this._edge.getCoordinate(a2);
          return r2 && (o2[s2] = new C(e3.coord)), new gn(o2, this._edge.getData());
        }, cn.prototype.add = function(t2, e3) {
          var n2 = new ln(this._edge, t2, e3, this._edge.getSegmentOctant(e3)), i2 = this._nodeMap.get(n2);
          return null !== i2 ? (et.isTrue(i2.coord.equals2D(t2), "Found equal nodes with different coordinates"), i2) : (this._nodeMap.put(n2, n2), n2);
        }, cn.prototype.checkSplitEdgesCorrectness = function(t2) {
          var e3 = this._edge.getCoordinates(), n2 = t2.get(0).getCoordinate(0);
          if (!n2.equals2D(e3[0]))
            throw new $("bad split edge start point at " + n2);
          var i2 = t2.get(t2.size() - 1).getCoordinates(), r2 = i2[i2.length - 1];
          if (!r2.equals2D(e3[e3.length - 1]))
            throw new $("bad split edge end point at " + r2);
        }, cn.prototype.interfaces_ = function() {
          return [];
        }, cn.prototype.getClass = function() {
          return cn;
        };
        var pn = function() {
        };
        pn.prototype.interfaces_ = function() {
          return [];
        }, pn.prototype.getClass = function() {
          return pn;
        }, pn.octant = function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === t2 && 0 === e3)
              throw new m("Cannot compute the octant for point ( " + t2 + ", " + e3 + " )");
            var n2 = Math.abs(t2), i2 = Math.abs(e3);
            return t2 >= 0 ? e3 >= 0 ? n2 >= i2 ? 0 : 1 : n2 >= i2 ? 7 : 6 : e3 >= 0 ? n2 >= i2 ? 3 : 2 : n2 >= i2 ? 4 : 5;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var r2 = arguments[0], o2 = arguments[1], s2 = o2.x - r2.x, a2 = o2.y - r2.y;
            if (0 === s2 && 0 === a2)
              throw new m("Cannot compute the octant for two identical points " + r2);
            return pn.octant(s2, a2);
          }
        };
        var hn = function() {
        };
        hn.prototype.getCoordinates = function() {
        }, hn.prototype.size = function() {
        }, hn.prototype.getCoordinate = function(t2) {
        }, hn.prototype.isClosed = function() {
        }, hn.prototype.setData = function(t2) {
        }, hn.prototype.getData = function() {
        }, hn.prototype.interfaces_ = function() {
          return [];
        }, hn.prototype.getClass = function() {
          return hn;
        };
        var fn = function() {
        };
        fn.prototype.addIntersection = function(t2, e3) {
        }, fn.prototype.interfaces_ = function() {
          return [hn];
        }, fn.prototype.getClass = function() {
          return fn;
        };
        var gn = function() {
          this._nodeList = new cn(this), this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        gn.prototype.getCoordinates = function() {
          return this._pts;
        }, gn.prototype.size = function() {
          return this._pts.length;
        }, gn.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, gn.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, gn.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, gn.prototype.setData = function(t2) {
          this._data = t2;
        }, gn.prototype.safeOctant = function(t2, e3) {
          return t2.equals2D(e3) ? 0 : pn.octant(t2, e3);
        }, gn.prototype.getData = function() {
          return this._data;
        }, gn.prototype.addIntersection = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this.addIntersectionNode(t2, e3);
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[3], o2 = new C(n2.getIntersection(r2));
            this.addIntersection(o2, i2);
          }
        }, gn.prototype.toString = function() {
          return Z.toLineString(new ue(this._pts));
        }, gn.prototype.getNodeList = function() {
          return this._nodeList;
        }, gn.prototype.addIntersectionNode = function(t2, e3) {
          var n2 = e3, i2 = n2 + 1;
          if (i2 < this._pts.length) {
            var r2 = this._pts[i2];
            t2.equals2D(r2) && (n2 = i2);
          }
          return this._nodeList.add(t2, n2);
        }, gn.prototype.addIntersections = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++)
            this.addIntersection(t2, e3, n2, i2);
        }, gn.prototype.interfaces_ = function() {
          return [fn];
        }, gn.prototype.getClass = function() {
          return gn;
        }, gn.getNodedSubstrings = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new Nt();
            return gn.getNodedSubstrings(t2, e3), e3;
          }
          if (2 === arguments.length)
            for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
              r2.next().getNodeList().addSplitEdges(i2);
            }
        };
        var dn = function() {
          if (this.p0 = null, this.p1 = null, 0 === arguments.length)
            this.p0 = new C(), this.p1 = new C();
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.p0 = new C(t2.p0), this.p1 = new C(t2.p1);
          } else if (2 === arguments.length)
            this.p0 = arguments[0], this.p1 = arguments[1];
          else if (4 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3];
            this.p0 = new C(e3, n2), this.p1 = new C(i2, r2);
          }
        }, yn = { serialVersionUID: { configurable: true } };
        dn.prototype.minX = function() {
          return Math.min(this.p0.x, this.p1.x);
        }, dn.prototype.orientationIndex = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0], e3 = at.orientationIndex(this.p0, this.p1, t2.p0), n2 = at.orientationIndex(this.p0, this.p1, t2.p1);
            return e3 >= 0 && n2 >= 0 ? Math.max(e3, n2) : e3 <= 0 && n2 <= 0 ? Math.max(e3, n2) : 0;
          }
          if (arguments[0] instanceof C) {
            var i2 = arguments[0];
            return at.orientationIndex(this.p0, this.p1, i2);
          }
        }, dn.prototype.toGeometry = function(t2) {
          return t2.createLineString([this.p0, this.p1]);
        }, dn.prototype.isVertical = function() {
          return this.p0.x === this.p1.x;
        }, dn.prototype.equals = function(t2) {
          if (!(t2 instanceof dn))
            return false;
          var e3 = t2;
          return this.p0.equals(e3.p0) && this.p1.equals(e3.p1);
        }, dn.prototype.intersection = function(t2) {
          var e3 = new rt();
          return e3.computeIntersection(this.p0, this.p1, t2.p0, t2.p1), e3.hasIntersection() ? e3.getIntersection(0) : null;
        }, dn.prototype.project = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            if (t2.equals(this.p0) || t2.equals(this.p1))
              return new C(t2);
            var e3 = this.projectionFactor(t2), n2 = new C();
            return n2.x = this.p0.x + e3 * (this.p1.x - this.p0.x), n2.y = this.p0.y + e3 * (this.p1.y - this.p0.y), n2;
          }
          if (arguments[0] instanceof dn) {
            var i2 = arguments[0], r2 = this.projectionFactor(i2.p0), o2 = this.projectionFactor(i2.p1);
            if (r2 >= 1 && o2 >= 1)
              return null;
            if (r2 <= 0 && o2 <= 0)
              return null;
            var s2 = this.project(i2.p0);
            r2 < 0 && (s2 = this.p0), r2 > 1 && (s2 = this.p1);
            var a2 = this.project(i2.p1);
            return o2 < 0 && (a2 = this.p0), o2 > 1 && (a2 = this.p1), new dn(s2, a2);
          }
        }, dn.prototype.normalize = function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        }, dn.prototype.angle = function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        }, dn.prototype.getCoordinate = function(t2) {
          return 0 === t2 ? this.p0 : this.p1;
        }, dn.prototype.distancePerpendicular = function(t2) {
          return at.distancePointLinePerpendicular(t2, this.p0, this.p1);
        }, dn.prototype.minY = function() {
          return Math.min(this.p0.y, this.p1.y);
        }, dn.prototype.midPoint = function() {
          return dn.midPoint(this.p0, this.p1);
        }, dn.prototype.projectionFactor = function(t2) {
          if (t2.equals(this.p0))
            return 0;
          if (t2.equals(this.p1))
            return 1;
          var e3 = this.p1.x - this.p0.x, n2 = this.p1.y - this.p0.y, i2 = e3 * e3 + n2 * n2;
          if (i2 <= 0)
            return v.NaN;
          return ((t2.x - this.p0.x) * e3 + (t2.y - this.p0.y) * n2) / i2;
        }, dn.prototype.closestPoints = function(t2) {
          var e3 = this.intersection(t2);
          if (null !== e3)
            return [e3, e3];
          var n2 = new Array(2).fill(null), i2 = v.MAX_VALUE, r2 = null, o2 = this.closestPoint(t2.p0);
          i2 = o2.distance(t2.p0), n2[0] = o2, n2[1] = t2.p0;
          var s2 = this.closestPoint(t2.p1);
          (r2 = s2.distance(t2.p1)) < i2 && (i2 = r2, n2[0] = s2, n2[1] = t2.p1);
          var a2 = t2.closestPoint(this.p0);
          (r2 = a2.distance(this.p0)) < i2 && (i2 = r2, n2[0] = this.p0, n2[1] = a2);
          var u2 = t2.closestPoint(this.p1);
          return (r2 = u2.distance(this.p1)) < i2 && (i2 = r2, n2[0] = this.p1, n2[1] = u2), n2;
        }, dn.prototype.closestPoint = function(t2) {
          var e3 = this.projectionFactor(t2);
          if (e3 > 0 && e3 < 1)
            return this.project(t2);
          return this.p0.distance(t2) < this.p1.distance(t2) ? this.p0 : this.p1;
        }, dn.prototype.maxX = function() {
          return Math.max(this.p0.x, this.p1.x);
        }, dn.prototype.getLength = function() {
          return this.p0.distance(this.p1);
        }, dn.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.p0.compareTo(e3.p0);
          return 0 !== n2 ? n2 : this.p1.compareTo(e3.p1);
        }, dn.prototype.reverse = function() {
          var t2 = this.p0;
          this.p0 = this.p1, this.p1 = t2;
        }, dn.prototype.equalsTopo = function(t2) {
          return this.p0.equals(t2.p0) && (this.p1.equals(t2.p1) || this.p0.equals(t2.p1)) && this.p1.equals(t2.p0);
        }, dn.prototype.lineIntersection = function(t2) {
          try {
            return k.intersection(this.p0, this.p1, t2.p0, t2.p1);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
          }
          return null;
        }, dn.prototype.maxY = function() {
          return Math.max(this.p0.y, this.p1.y);
        }, dn.prototype.pointAlongOffset = function(t2, e3) {
          var n2 = this.p0.x + t2 * (this.p1.x - this.p0.x), i2 = this.p0.y + t2 * (this.p1.y - this.p0.y), r2 = this.p1.x - this.p0.x, o2 = this.p1.y - this.p0.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = 0, u2 = 0;
          if (0 !== e3) {
            if (s2 <= 0)
              throw new Error("Cannot compute offset from zero-length line segment");
            a2 = e3 * r2 / s2, u2 = e3 * o2 / s2;
          }
          return new C(n2 - u2, i2 + a2);
        }, dn.prototype.setCoordinates = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setCoordinates(t2.p0, t2.p1);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.p0.x = e3.x, this.p0.y = e3.y, this.p1.x = n2.x, this.p1.y = n2.y;
          }
        }, dn.prototype.segmentFraction = function(t2) {
          var e3 = this.projectionFactor(t2);
          return e3 < 0 ? e3 = 0 : (e3 > 1 || v.isNaN(e3)) && (e3 = 1), e3;
        }, dn.prototype.toString = function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        }, dn.prototype.isHorizontal = function() {
          return this.p0.y === this.p1.y;
        }, dn.prototype.distance = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0];
            return at.distanceLineLine(this.p0, this.p1, t2.p0, t2.p1);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return at.distancePointLine(e3, this.p0, this.p1);
          }
        }, dn.prototype.pointAlong = function(t2) {
          var e3 = new C();
          return e3.x = this.p0.x + t2 * (this.p1.x - this.p0.x), e3.y = this.p0.y + t2 * (this.p1.y - this.p0.y), e3;
        }, dn.prototype.hashCode = function() {
          var t2 = v.doubleToLongBits(this.p0.x);
          t2 ^= 31 * v.doubleToLongBits(this.p0.y);
          var e3 = Math.trunc(t2) ^ Math.trunc(t2 >> 32), n2 = v.doubleToLongBits(this.p1.x);
          n2 ^= 31 * v.doubleToLongBits(this.p1.y);
          return e3 ^ (Math.trunc(n2) ^ Math.trunc(n2 >> 32));
        }, dn.prototype.interfaces_ = function() {
          return [E, e];
        }, dn.prototype.getClass = function() {
          return dn;
        }, dn.midPoint = function(t2, e3) {
          return new C((t2.x + e3.x) / 2, (t2.y + e3.y) / 2);
        }, yn.serialVersionUID.get = function() {
          return 3252005833466256400;
        }, Object.defineProperties(dn, yn);
        var _n = function() {
          this.tempEnv1 = new j(), this.tempEnv2 = new j(), this._overlapSeg1 = new dn(), this._overlapSeg2 = new dn();
        };
        _n.prototype.overlap = function() {
          if (2 === arguments.length)
            ;
          else if (4 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            t2.getLineSegment(e3, this._overlapSeg1), n2.getLineSegment(i2, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        }, _n.prototype.interfaces_ = function() {
          return [];
        }, _n.prototype.getClass = function() {
          return _n;
        };
        var mn = function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._pts = t2, this._start = e3, this._end = n2, this._context = i2;
        };
        mn.prototype.getLineSegment = function(t2, e3) {
          e3.p0 = this._pts[t2], e3.p1 = this._pts[t2 + 1];
        }, mn.prototype.computeSelect = function(t2, e3, n2, i2) {
          var r2 = this._pts[e3], o2 = this._pts[n2];
          if (i2.tempEnv1.init(r2, o2), n2 - e3 == 1)
            return i2.select(this, e3), null;
          if (!t2.intersects(i2.tempEnv1))
            return null;
          var s2 = Math.trunc((e3 + n2) / 2);
          e3 < s2 && this.computeSelect(t2, e3, s2, i2), s2 < n2 && this.computeSelect(t2, s2, n2, i2);
        }, mn.prototype.getCoordinates = function() {
          for (var t2 = new Array(this._end - this._start + 1).fill(null), e3 = 0, n2 = this._start; n2 <= this._end; n2++)
            t2[e3++] = this._pts[n2];
          return t2;
        }, mn.prototype.computeOverlaps = function(t2, e3) {
          this.computeOverlapsInternal(this._start, this._end, t2, t2._start, t2._end, e3);
        }, mn.prototype.setId = function(t2) {
          this._id = t2;
        }, mn.prototype.select = function(t2, e3) {
          this.computeSelect(t2, this._start, this._end, e3);
        }, mn.prototype.getEnvelope = function() {
          if (null === this._env) {
            var t2 = this._pts[this._start], e3 = this._pts[this._end];
            this._env = new j(t2, e3);
          }
          return this._env;
        }, mn.prototype.getEndIndex = function() {
          return this._end;
        }, mn.prototype.getStartIndex = function() {
          return this._start;
        }, mn.prototype.getContext = function() {
          return this._context;
        }, mn.prototype.getId = function() {
          return this._id;
        }, mn.prototype.computeOverlapsInternal = function(t2, e3, n2, i2, r2, o2) {
          var s2 = this._pts[t2], a2 = this._pts[e3], u2 = n2._pts[i2], l2 = n2._pts[r2];
          if (e3 - t2 == 1 && r2 - i2 == 1)
            return o2.overlap(this, t2, n2, i2), null;
          if (o2.tempEnv1.init(s2, a2), o2.tempEnv2.init(u2, l2), !o2.tempEnv1.intersects(o2.tempEnv2))
            return null;
          var c2 = Math.trunc((t2 + e3) / 2), p2 = Math.trunc((i2 + r2) / 2);
          t2 < c2 && (i2 < p2 && this.computeOverlapsInternal(t2, c2, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(t2, c2, n2, p2, r2, o2)), c2 < e3 && (i2 < p2 && this.computeOverlapsInternal(c2, e3, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(c2, e3, n2, p2, r2, o2));
        }, mn.prototype.interfaces_ = function() {
          return [];
        }, mn.prototype.getClass = function() {
          return mn;
        };
        var vn = function() {
        };
        vn.prototype.interfaces_ = function() {
          return [];
        }, vn.prototype.getClass = function() {
          return vn;
        }, vn.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = vn.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return vn.toIntArray(n2);
        }, vn.findChainEnd = function(t2, e3) {
          for (var n2 = e3; n2 < t2.length - 1 && t2[n2].equals2D(t2[n2 + 1]); )
            n2++;
          if (n2 >= t2.length - 1)
            return t2.length - 1;
          for (var i2 = Be.quadrant(t2[n2], t2[n2 + 1]), r2 = e3 + 1; r2 < t2.length; ) {
            if (!t2[r2 - 1].equals2D(t2[r2])) {
              if (Be.quadrant(t2[r2 - 1], t2[r2]) !== i2)
                break;
            }
            r2++;
          }
          return r2 - 1;
        }, vn.getChains = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return vn.getChains(t2, null);
          }
          if (2 === arguments.length) {
            for (var e3 = arguments[0], n2 = arguments[1], i2 = new Nt(), r2 = vn.getChainStartIndices(e3), o2 = 0; o2 < r2.length - 1; o2++) {
              var s2 = new mn(e3, r2[o2], r2[o2 + 1], n2);
              i2.add(s2);
            }
            return i2;
          }
        }, vn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var In = function() {
        };
        In.prototype.computeNodes = function(t2) {
        }, In.prototype.getNodedSubstrings = function() {
        }, In.prototype.interfaces_ = function() {
          return [];
        }, In.prototype.getClass = function() {
          return In;
        };
        var En = function() {
          if (this._segInt = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setSegmentIntersector(t2);
          }
        };
        En.prototype.setSegmentIntersector = function(t2) {
          this._segInt = t2;
        }, En.prototype.interfaces_ = function() {
          return [In];
        }, En.prototype.getClass = function() {
          return En;
        };
        var xn = function(t2) {
          function e3(e4) {
            e4 ? t2.call(this, e4) : t2.call(this), this._monoChains = new Nt(), this._index = new sn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { SegmentOverlapAction: { configurable: true } };
          return e3.prototype.getMonotoneChains = function() {
            return this._monoChains;
          }, e3.prototype.getNodedSubstrings = function() {
            return gn.getNodedSubstrings(this._nodedSegStrings);
          }, e3.prototype.getIndex = function() {
            return this._index;
          }, e3.prototype.add = function(t3) {
            for (var e4 = vn.getChains(t3.getCoordinates(), t3).iterator(); e4.hasNext(); ) {
              var n3 = e4.next();
              n3.setId(this._idCounter++), this._index.insert(n3.getEnvelope(), n3), this._monoChains.add(n3);
            }
          }, e3.prototype.computeNodes = function(t3) {
            this._nodedSegStrings = t3;
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            this.intersectChains();
          }, e3.prototype.intersectChains = function() {
            for (var t3 = new Nn(this._segInt), e4 = this._monoChains.iterator(); e4.hasNext(); )
              for (var n3 = e4.next(), i2 = this._index.query(n3.getEnvelope()).iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                if (r2.getId() > n3.getId() && (n3.computeOverlaps(r2, t3), this._nOverlaps++), this._segInt.isDone())
                  return null;
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.SegmentOverlapAction.get = function() {
            return Nn;
          }, Object.defineProperties(e3, n2), e3;
        }(En), Nn = function(t2) {
          function e3() {
            t2.call(this), this._si = null;
            var e4 = arguments[0];
            this._si = e4;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.overlap = function() {
            if (4 !== arguments.length)
              return t2.prototype.overlap.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3], o2 = e4.getContext(), s2 = i2.getContext();
            this._si.processIntersections(o2, n2, s2, r2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(_n), Cn = function t2() {
          if (this._quadrantSegments = t2.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t2.CAP_ROUND, this._joinStyle = t2.JOIN_ROUND, this._mitreLimit = t2.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = t2.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.setQuadrantSegments(e3);
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.setQuadrantSegments(n2), this.setEndCapStyle(i2);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            this.setQuadrantSegments(r2), this.setEndCapStyle(o2), this.setJoinStyle(s2), this.setMitreLimit(a2);
          }
        }, Sn = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
        Cn.prototype.getEndCapStyle = function() {
          return this._endCapStyle;
        }, Cn.prototype.isSingleSided = function() {
          return this._isSingleSided;
        }, Cn.prototype.setQuadrantSegments = function(t2) {
          this._quadrantSegments = t2, 0 === this._quadrantSegments && (this._joinStyle = Cn.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Cn.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t2 <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Cn.JOIN_ROUND && (this._quadrantSegments = Cn.DEFAULT_QUADRANT_SEGMENTS);
        }, Cn.prototype.getJoinStyle = function() {
          return this._joinStyle;
        }, Cn.prototype.setJoinStyle = function(t2) {
          this._joinStyle = t2;
        }, Cn.prototype.setSimplifyFactor = function(t2) {
          this._simplifyFactor = t2 < 0 ? 0 : t2;
        }, Cn.prototype.getSimplifyFactor = function() {
          return this._simplifyFactor;
        }, Cn.prototype.getQuadrantSegments = function() {
          return this._quadrantSegments;
        }, Cn.prototype.setEndCapStyle = function(t2) {
          this._endCapStyle = t2;
        }, Cn.prototype.getMitreLimit = function() {
          return this._mitreLimit;
        }, Cn.prototype.setMitreLimit = function(t2) {
          this._mitreLimit = t2;
        }, Cn.prototype.setSingleSided = function(t2) {
          this._isSingleSided = t2;
        }, Cn.prototype.interfaces_ = function() {
          return [];
        }, Cn.prototype.getClass = function() {
          return Cn;
        }, Cn.bufferDistanceError = function(t2) {
          var e3 = Math.PI / 2 / t2;
          return 1 - Math.cos(e3 / 2);
        }, Sn.CAP_ROUND.get = function() {
          return 1;
        }, Sn.CAP_FLAT.get = function() {
          return 2;
        }, Sn.CAP_SQUARE.get = function() {
          return 3;
        }, Sn.JOIN_ROUND.get = function() {
          return 1;
        }, Sn.JOIN_MITRE.get = function() {
          return 2;
        }, Sn.JOIN_BEVEL.get = function() {
          return 3;
        }, Sn.DEFAULT_QUADRANT_SEGMENTS.get = function() {
          return 8;
        }, Sn.DEFAULT_MITRE_LIMIT.get = function() {
          return 5;
        }, Sn.DEFAULT_SIMPLIFY_FACTOR.get = function() {
          return 0.01;
        }, Object.defineProperties(Cn, Sn);
        var Ln = function(t2) {
          this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t2 || null;
        }, bn = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
        Ln.prototype.isDeletable = function(t2, e3, n2, i2) {
          var r2 = this._inputLine[t2], o2 = this._inputLine[e3], s2 = this._inputLine[n2];
          return !!this.isConcave(r2, o2, s2) && (!!this.isShallow(r2, o2, s2, i2) && this.isShallowSampled(r2, o2, t2, n2, i2));
        }, Ln.prototype.deleteShallowConcavities = function() {
          for (var t2 = 1, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3), i2 = false; n2 < this._inputLine.length; ) {
            var r2 = false;
            this.isDeletable(t2, e3, n2, this._distanceTol) && (this._isDeleted[e3] = Ln.DELETE, r2 = true, i2 = true), t2 = r2 ? n2 : e3, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3);
          }
          return i2;
        }, Ln.prototype.isShallowConcavity = function(t2, e3, n2, i2) {
          if (!(at.computeOrientation(t2, e3, n2) === this._angleOrientation))
            return false;
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.isShallowSampled = function(t2, e3, n2, i2, r2) {
          var o2 = Math.trunc((i2 - n2) / Ln.NUM_PTS_TO_CHECK);
          o2 <= 0 && (o2 = 1);
          for (var s2 = n2; s2 < i2; s2 += o2)
            if (!this.isShallow(t2, e3, this._inputLine[s2], r2))
              return false;
          return true;
        }, Ln.prototype.isConcave = function(t2, e3, n2) {
          var i2 = at.computeOrientation(t2, e3, n2) === this._angleOrientation;
          return i2;
        }, Ln.prototype.simplify = function(t2) {
          this._distanceTol = Math.abs(t2), t2 < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var e3 = false;
          do {
            e3 = this.deleteShallowConcavities();
          } while (e3);
          return this.collapseLine();
        }, Ln.prototype.findNextNonDeletedIndex = function(t2) {
          for (var e3 = t2 + 1; e3 < this._inputLine.length && this._isDeleted[e3] === Ln.DELETE; )
            e3++;
          return e3;
        }, Ln.prototype.isShallow = function(t2, e3, n2, i2) {
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.collapseLine = function() {
          for (var t2 = new St(), e3 = 0; e3 < this._inputLine.length; e3++)
            this._isDeleted[e3] !== Ln.DELETE && t2.add(this._inputLine[e3]);
          return t2.toCoordinateArray();
        }, Ln.prototype.interfaces_ = function() {
          return [];
        }, Ln.prototype.getClass = function() {
          return Ln;
        }, Ln.simplify = function(t2, e3) {
          return new Ln(t2).simplify(e3);
        }, bn.INIT.get = function() {
          return 0;
        }, bn.DELETE.get = function() {
          return 1;
        }, bn.KEEP.get = function() {
          return 1;
        }, bn.NUM_PTS_TO_CHECK.get = function() {
          return 10;
        }, Object.defineProperties(Ln, bn);
        var wn = function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Nt();
        }, On = { COORDINATE_ARRAY_TYPE: { configurable: true } };
        wn.prototype.getCoordinates = function() {
          return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE);
        }, wn.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, wn.prototype.addPt = function(t2) {
          var e3 = new C(t2);
          if (this._precisionModel.makePrecise(e3), this.isRedundant(e3))
            return null;
          this._ptList.add(e3);
        }, wn.prototype.revere = function() {
        }, wn.prototype.addPts = function(t2, e3) {
          if (e3)
            for (var n2 = 0; n2 < t2.length; n2++)
              this.addPt(t2[n2]);
          else
            for (var i2 = t2.length - 1; i2 >= 0; i2--)
              this.addPt(t2[i2]);
        }, wn.prototype.isRedundant = function(t2) {
          if (this._ptList.size() < 1)
            return false;
          var e3 = this._ptList.get(this._ptList.size() - 1);
          return t2.distance(e3) < this._minimimVertexDistance;
        }, wn.prototype.toString = function() {
          return new _e().createLineString(this.getCoordinates()).toString();
        }, wn.prototype.closeRing = function() {
          if (this._ptList.size() < 1)
            return null;
          var t2 = new C(this._ptList.get(0)), e3 = this._ptList.get(this._ptList.size() - 1);
          if (t2.equals(e3))
            return null;
          this._ptList.add(t2);
        }, wn.prototype.setMinimumVertexDistance = function(t2) {
          this._minimimVertexDistance = t2;
        }, wn.prototype.interfaces_ = function() {
          return [];
        }, wn.prototype.getClass = function() {
          return wn;
        }, On.COORDINATE_ARRAY_TYPE.get = function() {
          return new Array(0).fill(null);
        }, Object.defineProperties(wn, On);
        var Tn = function() {
        }, Rn = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
        Tn.prototype.interfaces_ = function() {
          return [];
        }, Tn.prototype.getClass = function() {
          return Tn;
        }, Tn.toDegrees = function(t2) {
          return 180 * t2 / Math.PI;
        }, Tn.normalize = function(t2) {
          for (; t2 > Math.PI; )
            t2 -= Tn.PI_TIMES_2;
          for (; t2 <= -Math.PI; )
            t2 += Tn.PI_TIMES_2;
          return t2;
        }, Tn.angle = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Math.atan2(t2.y, t2.x);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = n2.x - e3.x, r2 = n2.y - e3.y;
            return Math.atan2(r2, i2);
          }
        }, Tn.isAcute = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) > 0;
        }, Tn.isObtuse = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) < 0;
        }, Tn.interiorAngle = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Math.abs(r2 - i2);
        }, Tn.normalizePositive = function(t2) {
          if (t2 < 0) {
            for (; t2 < 0; )
              t2 += Tn.PI_TIMES_2;
            t2 >= Tn.PI_TIMES_2 && (t2 = 0);
          } else {
            for (; t2 >= Tn.PI_TIMES_2; )
              t2 -= Tn.PI_TIMES_2;
            t2 < 0 && (t2 = 0);
          }
          return t2;
        }, Tn.angleBetween = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Tn.diff(i2, r2);
        }, Tn.diff = function(t2, e3) {
          var n2 = null;
          return (n2 = t2 < e3 ? e3 - t2 : t2 - e3) > Math.PI && (n2 = 2 * Math.PI - n2), n2;
        }, Tn.toRadians = function(t2) {
          return t2 * Math.PI / 180;
        }, Tn.getTurn = function(t2, e3) {
          var n2 = Math.sin(e3 - t2);
          return n2 > 0 ? Tn.COUNTERCLOCKWISE : n2 < 0 ? Tn.CLOCKWISE : Tn.NONE;
        }, Tn.angleBetweenOriented = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2) - i2;
          return r2 <= -Math.PI ? r2 + Tn.PI_TIMES_2 : r2 > Math.PI ? r2 - Tn.PI_TIMES_2 : r2;
        }, Rn.PI_TIMES_2.get = function() {
          return 2 * Math.PI;
        }, Rn.PI_OVER_2.get = function() {
          return Math.PI / 2;
        }, Rn.PI_OVER_4.get = function() {
          return Math.PI / 4;
        }, Rn.COUNTERCLOCKWISE.get = function() {
          return at.COUNTERCLOCKWISE;
        }, Rn.CLOCKWISE.get = function() {
          return at.CLOCKWISE;
        }, Rn.NONE.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(Tn, Rn);
        var Pn = function t2() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new dn(), this._seg1 = new dn(), this._offset0 = new dn(), this._offset1 = new dn(), this._side = 0, this._hasNarrowConcaveAngle = false;
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._precisionModel = e3, this._bufParams = n2, this._li = new rt(), this._filletAngleQuantum = Math.PI / 2 / n2.getQuadrantSegments(), n2.getQuadrantSegments() >= 8 && n2.getJoinStyle() === Cn.JOIN_ROUND && (this._closingSegLengthFactor = t2.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i2);
        }, Dn = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
        Pn.prototype.addNextSegment = function(t2, e3) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t2, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2))
            return null;
          var n2 = at.computeOrientation(this._s0, this._s1, this._s2), i2 = n2 === at.CLOCKWISE && this._side === Se.LEFT || n2 === at.COUNTERCLOCKWISE && this._side === Se.RIGHT;
          0 === n2 ? this.addCollinear(e3) : i2 ? this.addOutsideTurn(n2, e3) : this.addInsideTurn(n2, e3);
        }, Pn.prototype.addLineEndCap = function(t2, e3) {
          var n2 = new dn(t2, e3), i2 = new dn();
          this.computeOffsetSegment(n2, Se.LEFT, this._distance, i2);
          var r2 = new dn();
          this.computeOffsetSegment(n2, Se.RIGHT, this._distance, r2);
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a2 = Math.atan2(s2, o2);
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              this._segList.addPt(i2.p1), this.addFilletArc(e3, a2 + Math.PI / 2, a2 - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_FLAT:
              this._segList.addPt(i2.p1), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_SQUARE:
              var u2 = new C();
              u2.x = Math.abs(this._distance) * Math.cos(a2), u2.y = Math.abs(this._distance) * Math.sin(a2);
              var l2 = new C(i2.p1.x + u2.x, i2.p1.y + u2.y), c2 = new C(r2.p1.x + u2.x, r2.p1.y + u2.y);
              this._segList.addPt(l2), this._segList.addPt(c2);
          }
        }, Pn.prototype.getCoordinates = function() {
          return this._segList.getCoordinates();
        }, Pn.prototype.addMitreJoin = function(t2, e3, n2, i2) {
          var r2 = true, o2 = null;
          try {
            o2 = k.intersection(e3.p0, e3.p1, n2.p0, n2.p1);
            (i2 <= 0 ? 1 : o2.distance(t2) / Math.abs(i2)) > this._bufParams.getMitreLimit() && (r2 = false);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
            o2 = new C(0, 0), r2 = false;
          }
          r2 ? this._segList.addPt(o2) : this.addLimitedMitreJoin(e3, n2, i2, this._bufParams.getMitreLimit());
        }, Pn.prototype.addFilletCorner = function(t2, e3, n2, i2, r2) {
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a2 = Math.atan2(s2, o2), u2 = n2.x - t2.x, l2 = n2.y - t2.y, c2 = Math.atan2(l2, u2);
          i2 === at.CLOCKWISE ? a2 <= c2 && (a2 += 2 * Math.PI) : a2 >= c2 && (a2 -= 2 * Math.PI), this._segList.addPt(e3), this.addFilletArc(t2, a2, c2, i2, r2), this._segList.addPt(n2);
        }, Pn.prototype.addOutsideTurn = function(t2, e3) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.OFFSET_SEGMENT_SEPARATION_FACTOR)
            return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e3 && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t2, this._distance), this._segList.addPt(this._offset1.p0));
        }, Pn.prototype.createSquare = function(t2) {
          this._segList.addPt(new C(t2.x + this._distance, t2.y + this._distance)), this._segList.addPt(new C(t2.x + this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y + this._distance)), this._segList.closeRing();
        }, Pn.prototype.addSegments = function(t2, e3) {
          this._segList.addPts(t2, e3);
        }, Pn.prototype.addFirstSegment = function() {
          this._segList.addPt(this._offset1.p0);
        }, Pn.prototype.addLastSegment = function() {
          this._segList.addPt(this._offset1.p1);
        }, Pn.prototype.initSideSegments = function(t2, e3, n2) {
          this._s1 = t2, this._s2 = e3, this._side = n2, this._seg1.setCoordinates(t2, e3), this.computeOffsetSegment(this._seg1, n2, this._distance, this._offset1);
        }, Pn.prototype.addLimitedMitreJoin = function(t2, e3, n2, i2) {
          var r2 = this._seg0.p1, o2 = Tn.angle(r2, this._seg0.p0), s2 = Tn.angleBetweenOriented(this._seg0.p0, r2, this._seg1.p1) / 2, a2 = Tn.normalize(o2 + s2), u2 = Tn.normalize(a2 + Math.PI), l2 = i2 * n2, c2 = n2 - l2 * Math.abs(Math.sin(s2)), p2 = r2.x + l2 * Math.cos(u2), h2 = r2.y + l2 * Math.sin(u2), f2 = new C(p2, h2), g2 = new dn(r2, f2), d2 = g2.pointAlongOffset(1, c2), y3 = g2.pointAlongOffset(1, -c2);
          this._side === Se.LEFT ? (this._segList.addPt(d2), this._segList.addPt(y3)) : (this._segList.addPt(y3), this._segList.addPt(d2));
        }, Pn.prototype.computeOffsetSegment = function(t2, e3, n2, i2) {
          var r2 = e3 === Se.LEFT ? 1 : -1, o2 = t2.p1.x - t2.p0.x, s2 = t2.p1.y - t2.p0.y, a2 = Math.sqrt(o2 * o2 + s2 * s2), u2 = r2 * n2 * o2 / a2, l2 = r2 * n2 * s2 / a2;
          i2.p0.x = t2.p0.x - l2, i2.p0.y = t2.p0.y + u2, i2.p1.x = t2.p1.x - l2, i2.p1.y = t2.p1.y + u2;
        }, Pn.prototype.addFilletArc = function(t2, e3, n2, i2, r2) {
          var o2 = i2 === at.CLOCKWISE ? -1 : 1, s2 = Math.abs(e3 - n2), a2 = Math.trunc(s2 / this._filletAngleQuantum + 0.5);
          if (a2 < 1)
            return null;
          for (var u2 = s2 / a2, l2 = 0, c2 = new C(); l2 < s2; ) {
            var p2 = e3 + o2 * l2;
            c2.x = t2.x + r2 * Math.cos(p2), c2.y = t2.y + r2 * Math.sin(p2), this._segList.addPt(c2), l2 += u2;
          }
        }, Pn.prototype.addInsideTurn = function(t2, e3) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection())
            this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
            this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var n2 = new C((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(n2);
              var i2 = new C((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(i2);
            } else
              this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        }, Pn.prototype.createCircle = function(t2) {
          var e3 = new C(t2.x + this._distance, t2.y);
          this._segList.addPt(e3), this.addFilletArc(t2, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        }, Pn.prototype.addBevelJoin = function(t2, e3) {
          this._segList.addPt(t2.p1), this._segList.addPt(e3.p0);
        }, Pn.prototype.init = function(t2) {
          this._distance = t2, this._maxCurveSegmentError = t2 * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new wn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t2 * Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        }, Pn.prototype.addCollinear = function(t2) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
          this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL || this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? (t2 && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance));
        }, Pn.prototype.closeRing = function() {
          this._segList.closeRing();
        }, Pn.prototype.hasNarrowConcaveAngle = function() {
          return this._hasNarrowConcaveAngle;
        }, Pn.prototype.interfaces_ = function() {
          return [];
        }, Pn.prototype.getClass = function() {
          return Pn;
        }, Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
          return 1e-3;
        }, Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-3;
        }, Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-6;
        }, Dn.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
          return 80;
        }, Object.defineProperties(Pn, Dn);
        var Mn = function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._precisionModel = t2, this._bufParams = e3;
        };
        Mn.prototype.getOffsetCurve = function(t2, e3) {
          if (this._distance = e3, 0 === e3)
            return null;
          var n2 = e3 < 0, i2 = Math.abs(e3), r2 = this.getSegGen(i2);
          t2.length <= 1 ? this.computePointCurve(t2[0], r2) : this.computeOffsetCurve(t2, n2, r2);
          var o2 = r2.getCoordinates();
          return n2 && Lt.reverse(o2), o2;
        }, Mn.prototype.computeSingleSidedBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            n2.addSegments(t2, true);
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            n2.addSegments(t2, false);
            var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
            n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a2[l2], true);
          }
          n2.addLastSegment(), n2.closeRing();
        }, Mn.prototype.computeRingBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          e3 === Se.RIGHT && (i2 = -i2);
          var r2 = Ln.simplify(t2, i2), o2 = r2.length - 1;
          n2.initSideSegments(r2[o2 - 1], r2[0], e3);
          for (var s2 = 1; s2 <= o2; s2++) {
            var a2 = 1 !== s2;
            n2.addNextSegment(r2[s2], a2);
          }
          n2.closeRing();
        }, Mn.prototype.computeLineBufferCurve = function(t2, e3) {
          var n2 = this.simplifyTolerance(this._distance), i2 = Ln.simplify(t2, n2), r2 = i2.length - 1;
          e3.initSideSegments(i2[0], i2[1], Se.LEFT);
          for (var o2 = 2; o2 <= r2; o2++)
            e3.addNextSegment(i2[o2], true);
          e3.addLastSegment(), e3.addLineEndCap(i2[r2 - 1], i2[r2]);
          var s2 = Ln.simplify(t2, -n2), a2 = s2.length - 1;
          e3.initSideSegments(s2[a2], s2[a2 - 1], Se.LEFT);
          for (var u2 = a2 - 2; u2 >= 0; u2--)
            e3.addNextSegment(s2[u2], true);
          e3.addLastSegment(), e3.addLineEndCap(s2[1], s2[0]), e3.closeRing();
        }, Mn.prototype.computePointCurve = function(t2, e3) {
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              e3.createCircle(t2);
              break;
            case Cn.CAP_SQUARE:
              e3.createSquare(t2);
          }
        }, Mn.prototype.getLineCurve = function(t2, e3) {
          if (this._distance = e3, e3 < 0 && !this._bufParams.isSingleSided())
            return null;
          if (0 === e3)
            return null;
          var n2 = Math.abs(e3), i2 = this.getSegGen(n2);
          if (t2.length <= 1)
            this.computePointCurve(t2[0], i2);
          else if (this._bufParams.isSingleSided()) {
            var r2 = e3 < 0;
            this.computeSingleSidedBufferCurve(t2, r2, i2);
          } else
            this.computeLineBufferCurve(t2, i2);
          return i2.getCoordinates();
        }, Mn.prototype.getBufferParameters = function() {
          return this._bufParams;
        }, Mn.prototype.simplifyTolerance = function(t2) {
          return t2 * this._bufParams.getSimplifyFactor();
        }, Mn.prototype.getRingCurve = function(t2, e3, n2) {
          if (this._distance = n2, t2.length <= 2)
            return this.getLineCurve(t2, n2);
          if (0 === n2)
            return Mn.copyCoordinates(t2);
          var i2 = this.getSegGen(n2);
          return this.computeRingBufferCurve(t2, e3, i2), i2.getCoordinates();
        }, Mn.prototype.computeOffsetCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
            n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a2[l2], true);
          }
          n2.addLastSegment();
        }, Mn.prototype.getSegGen = function(t2) {
          return new Pn(this._precisionModel, this._bufParams, t2);
        }, Mn.prototype.interfaces_ = function() {
          return [];
        }, Mn.prototype.getClass = function() {
          return Mn;
        }, Mn.copyCoordinates = function(t2) {
          for (var e3 = new Array(t2.length).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = new C(t2[n2]);
          return e3;
        };
        var An = function() {
          this._subgraphs = null, this._seg = new dn(), this._cga = new at();
          var t2 = arguments[0];
          this._subgraphs = t2;
        }, Fn = { DepthSegment: { configurable: true } };
        An.prototype.findStabbedSegments = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = this._subgraphs.iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getEnvelope();
              t2.y < r2.getMinY() || t2.y > r2.getMaxY() || this.findStabbedSegments(t2, i2.getDirectedEdges(), e3);
            }
            return e3;
          }
          if (3 === arguments.length) {
            if (T(arguments[2], xt) && arguments[0] instanceof C && arguments[1] instanceof ze)
              for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = s2.getEdge().getCoordinates(), l2 = 0; l2 < u2.length - 1; l2++) {
                this._seg.p0 = u2[l2], this._seg.p1 = u2[l2 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
                if (!(Math.max(this._seg.p0.x, this._seg.p1.x) < o2.x) && !(this._seg.isHorizontal() || o2.y < this._seg.p0.y || o2.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, o2) === at.RIGHT)) {
                  var c2 = s2.getDepth(Se.LEFT);
                  this._seg.p0.equals(u2[l2]) || (c2 = s2.getDepth(Se.RIGHT));
                  var p2 = new Gn(this._seg, c2);
                  a2.add(p2);
                }
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof C && T(arguments[1], xt))
              for (var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = f2.iterator(); d2.hasNext(); ) {
                var y3 = d2.next();
                y3.isForward() && this.findStabbedSegments(h2, y3, g2);
              }
          }
        }, An.prototype.getDepth = function(t2) {
          var e3 = this.findStabbedSegments(t2);
          if (0 === e3.size())
            return 0;
          return $e.min(e3)._leftDepth;
        }, An.prototype.interfaces_ = function() {
          return [];
        }, An.prototype.getClass = function() {
          return An;
        }, Fn.DepthSegment.get = function() {
          return Gn;
        }, Object.defineProperties(An, Fn);
        var Gn = function() {
          this._upwardSeg = null, this._leftDepth = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._upwardSeg = new dn(t2), this._leftDepth = e3;
        };
        Gn.prototype.compareTo = function(t2) {
          var e3 = t2;
          if (this._upwardSeg.minX() >= e3._upwardSeg.maxX())
            return 1;
          if (this._upwardSeg.maxX() <= e3._upwardSeg.minX())
            return -1;
          var n2 = this._upwardSeg.orientationIndex(e3._upwardSeg);
          return 0 !== n2 ? n2 : 0 != (n2 = -1 * e3._upwardSeg.orientationIndex(this._upwardSeg)) ? n2 : this._upwardSeg.compareTo(e3._upwardSeg);
        }, Gn.prototype.compareX = function(t2, e3) {
          var n2 = t2.p0.compareTo(e3.p0);
          return 0 !== n2 ? n2 : t2.p1.compareTo(e3.p1);
        }, Gn.prototype.toString = function() {
          return this._upwardSeg.toString();
        }, Gn.prototype.interfaces_ = function() {
          return [E];
        }, Gn.prototype.getClass = function() {
          return Gn;
        };
        var qn = function(t2, e3, n2) {
          this.p0 = t2 || null, this.p1 = e3 || null, this.p2 = n2 || null;
        };
        qn.prototype.area = function() {
          return qn.area(this.p0, this.p1, this.p2);
        }, qn.prototype.signedArea = function() {
          return qn.signedArea(this.p0, this.p1, this.p2);
        }, qn.prototype.interpolateZ = function(t2) {
          if (null === t2)
            throw new m("Supplied point is null.");
          return qn.interpolateZ(t2, this.p0, this.p1, this.p2);
        }, qn.prototype.longestSideLength = function() {
          return qn.longestSideLength(this.p0, this.p1, this.p2);
        }, qn.prototype.isAcute = function() {
          return qn.isAcute(this.p0, this.p1, this.p2);
        }, qn.prototype.circumcentre = function() {
          return qn.circumcentre(this.p0, this.p1, this.p2);
        }, qn.prototype.area3D = function() {
          return qn.area3D(this.p0, this.p1, this.p2);
        }, qn.prototype.centroid = function() {
          return qn.centroid(this.p0, this.p1, this.p2);
        }, qn.prototype.inCentre = function() {
          return qn.inCentre(this.p0, this.p1, this.p2);
        }, qn.prototype.interfaces_ = function() {
          return [];
        }, qn.prototype.getClass = function() {
          return qn;
        }, qn.area = function(t2, e3, n2) {
          return Math.abs(((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2);
        }, qn.signedArea = function(t2, e3, n2) {
          return ((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2;
        }, qn.det = function(t2, e3, n2, i2) {
          return t2 * i2 - e3 * n2;
        }, qn.interpolateZ = function(t2, e3, n2, i2) {
          var r2 = e3.x, o2 = e3.y, s2 = n2.x - r2, a2 = i2.x - r2, u2 = n2.y - o2, l2 = i2.y - o2, c2 = s2 * l2 - a2 * u2, p2 = t2.x - r2, h2 = t2.y - o2, f2 = (l2 * p2 - a2 * h2) / c2, g2 = (-u2 * p2 + s2 * h2) / c2;
          return e3.z + f2 * (n2.z - e3.z) + g2 * (i2.z - e3.z);
        }, qn.longestSideLength = function(t2, e3, n2) {
          var i2 = t2.distance(e3), r2 = e3.distance(n2), o2 = n2.distance(t2), s2 = i2;
          return r2 > s2 && (s2 = r2), o2 > s2 && (s2 = o2), s2;
        }, qn.isAcute = function(t2, e3, n2) {
          return !!Tn.isAcute(t2, e3, n2) && (!!Tn.isAcute(e3, n2, t2) && !!Tn.isAcute(n2, t2, e3));
        }, qn.circumcentre = function(t2, e3, n2) {
          var i2 = n2.x, r2 = n2.y, o2 = t2.x - i2, s2 = t2.y - r2, a2 = e3.x - i2, u2 = e3.y - r2, l2 = 2 * qn.det(o2, s2, a2, u2), c2 = qn.det(s2, o2 * o2 + s2 * s2, u2, a2 * a2 + u2 * u2), p2 = qn.det(o2, o2 * o2 + s2 * s2, a2, a2 * a2 + u2 * u2);
          return new C(i2 - c2 / l2, r2 + p2 / l2);
        }, qn.perpendicularBisector = function(t2, e3) {
          var n2 = e3.x - t2.x, i2 = e3.y - t2.y, r2 = new k(t2.x + n2 / 2, t2.y + i2 / 2, 1), o2 = new k(t2.x - i2 + n2 / 2, t2.y + n2 + i2 / 2, 1);
          return new k(r2, o2);
        }, qn.angleBisector = function(t2, e3, n2) {
          var i2 = e3.distance(t2), r2 = i2 / (i2 + e3.distance(n2)), o2 = n2.x - t2.x, s2 = n2.y - t2.y;
          return new C(t2.x + r2 * o2, t2.y + r2 * s2);
        }, qn.area3D = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = e3.z - t2.z, s2 = n2.x - t2.x, a2 = n2.y - t2.y, u2 = n2.z - t2.z, l2 = r2 * u2 - o2 * a2, c2 = o2 * s2 - i2 * u2, p2 = i2 * a2 - r2 * s2, h2 = l2 * l2 + c2 * c2 + p2 * p2, f2 = Math.sqrt(h2) / 2;
          return f2;
        }, qn.centroid = function(t2, e3, n2) {
          var i2 = (t2.x + e3.x + n2.x) / 3, r2 = (t2.y + e3.y + n2.y) / 3;
          return new C(i2, r2);
        }, qn.inCentre = function(t2, e3, n2) {
          var i2 = e3.distance(n2), r2 = t2.distance(n2), o2 = t2.distance(e3), s2 = i2 + r2 + o2, a2 = (i2 * t2.x + r2 * e3.x + o2 * n2.x) / s2, u2 = (i2 * t2.y + r2 * e3.y + o2 * n2.y) / s2;
          return new C(a2, u2);
        };
        var Bn = function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._inputGeom = t2, this._distance = e3, this._curveBuilder = n2;
        };
        Bn.prototype.addPoint = function(t2) {
          if (this._distance <= 0)
            return null;
          var e3 = t2.getCoordinates(), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addPolygon = function(t2) {
          var e3 = this._distance, n2 = Se.LEFT;
          this._distance < 0 && (e3 = -this._distance, n2 = Se.RIGHT);
          var i2 = t2.getExteriorRing(), r2 = Lt.removeRepeatedPoints(i2.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(i2, this._distance))
            return null;
          if (this._distance <= 0 && r2.length < 3)
            return null;
          this.addPolygonRing(r2, e3, n2, w.EXTERIOR, w.INTERIOR);
          for (var o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = t2.getInteriorRingN(o2), a2 = Lt.removeRepeatedPoints(s2.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(s2, -this._distance) || this.addPolygonRing(a2, e3, Se.opposite(n2), w.INTERIOR, w.EXTERIOR);
          }
        }, Bn.prototype.isTriangleErodedCompletely = function(t2, e3) {
          var n2 = new qn(t2[0], t2[1], t2[2]), i2 = n2.inCentre();
          return at.distancePointLine(i2, n2.p0, n2.p1) < Math.abs(e3);
        }, Bn.prototype.addLineString = function(t2) {
          if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided())
            return null;
          var e3 = Lt.removeRepeatedPoints(t2.getCoordinates()), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addCurve = function(t2, e3, n2) {
          if (null === t2 || t2.length < 2)
            return null;
          var i2 = new gn(t2, new Pe(0, w.BOUNDARY, e3, n2));
          this._curveList.add(i2);
        }, Bn.prototype.getCurves = function() {
          return this.add(this._inputGeom), this._curveList;
        }, Bn.prototype.addPolygonRing = function(t2, e3, n2, i2, r2) {
          if (0 === e3 && t2.length < ee.MINIMUM_VALID_SIZE)
            return null;
          var o2 = i2, s2 = r2;
          t2.length >= ee.MINIMUM_VALID_SIZE && at.isCCW(t2) && (o2 = r2, s2 = i2, n2 = Se.opposite(n2));
          var a2 = this._curveBuilder.getRingCurve(t2, n2, e3);
          this.addCurve(a2, o2, s2);
        }, Bn.prototype.add = function(t2) {
          if (t2.isEmpty())
            return null;
          t2 instanceof $t ? this.addPolygon(t2) : t2 instanceof Kt ? this.addLineString(t2) : t2 instanceof Qt ? this.addPoint(t2) : t2 instanceof te ? this.addCollection(t2) : t2 instanceof Xt ? this.addCollection(t2) : t2 instanceof ne ? this.addCollection(t2) : t2 instanceof zt && this.addCollection(t2);
        }, Bn.prototype.isErodedCompletely = function(t2, e3) {
          var n2 = t2.getCoordinates();
          if (n2.length < 4)
            return e3 < 0;
          if (4 === n2.length)
            return this.isTriangleErodedCompletely(n2, e3);
          var i2 = t2.getEnvelopeInternal(), r2 = Math.min(i2.getHeight(), i2.getWidth());
          return e3 < 0 && 2 * Math.abs(e3) > r2;
        }, Bn.prototype.addCollection = function(t2) {
          for (var e3 = 0; e3 < t2.getNumGeometries(); e3++) {
            var n2 = t2.getGeometryN(e3);
            this.add(n2);
          }
        }, Bn.prototype.interfaces_ = function() {
          return [];
        }, Bn.prototype.getClass = function() {
          return Bn;
        };
        var Vn = function() {
        };
        Vn.prototype.locate = function(t2) {
        }, Vn.prototype.interfaces_ = function() {
          return [];
        }, Vn.prototype.getClass = function() {
          return Vn;
        };
        var Un = function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var t2 = arguments[0];
          this._parent = t2, this._atStart = true, this._index = 0, this._max = t2.getNumGeometries();
        };
        Un.prototype.next = function() {
          if (this._atStart)
            return this._atStart = false, Un.isAtomic(this._parent) && this._index++, this._parent;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext())
              return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max)
            throw new i();
          var t2 = this._parent.getGeometryN(this._index++);
          return t2 instanceof zt ? (this._subcollectionIterator = new Un(t2), this._subcollectionIterator.next()) : t2;
        }, Un.prototype.remove = function() {
          throw new Error(this.getClass().getName());
        }, Un.prototype.hasNext = function() {
          if (this._atStart)
            return true;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext())
              return true;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        }, Un.prototype.interfaces_ = function() {
          return [Et];
        }, Un.prototype.getClass = function() {
          return Un;
        }, Un.isAtomic = function(t2) {
          return !(t2 instanceof zt);
        };
        var zn = function() {
          this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        zn.prototype.locate = function(t2) {
          return zn.locate(t2, this._geom);
        }, zn.prototype.interfaces_ = function() {
          return [Vn];
        }, zn.prototype.getClass = function() {
          return zn;
        }, zn.isPointInRing = function(t2, e3) {
          return !!e3.getEnvelopeInternal().intersects(t2) && at.isPointInRing(t2, e3.getCoordinates());
        }, zn.containsPointInPolygon = function(t2, e3) {
          if (e3.isEmpty())
            return false;
          var n2 = e3.getExteriorRing();
          if (!zn.isPointInRing(t2, n2))
            return false;
          for (var i2 = 0; i2 < e3.getNumInteriorRing(); i2++) {
            var r2 = e3.getInteriorRingN(i2);
            if (zn.isPointInRing(t2, r2))
              return false;
          }
          return true;
        }, zn.containsPoint = function(t2, e3) {
          if (e3 instanceof $t)
            return zn.containsPointInPolygon(t2, e3);
          if (e3 instanceof zt)
            for (var n2 = new Un(e3); n2.hasNext(); ) {
              var i2 = n2.next();
              if (i2 !== e3 && zn.containsPoint(t2, i2))
                return true;
            }
          return false;
        }, zn.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : zn.containsPoint(t2, e3) ? w.INTERIOR : w.EXTERIOR;
        };
        var Xn = function() {
          this._edgeMap = new p(), this._edgeList = null, this._ptInAreaLocation = [w.NONE, w.NONE];
        };
        Xn.prototype.getNextCW = function(t2) {
          this.getEdges();
          var e3 = this._edgeList.indexOf(t2), n2 = e3 - 1;
          return 0 === e3 && (n2 = this._edgeList.size() - 1), this._edgeList.get(n2);
        }, Xn.prototype.propagateSideLabels = function(t2) {
          for (var e3 = w.NONE, n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getLabel();
            i2.isArea(t2) && i2.getLocation(t2, Se.LEFT) !== w.NONE && (e3 = i2.getLocation(t2, Se.LEFT));
          }
          if (e3 === w.NONE)
            return null;
          for (var r2 = e3, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next(), a2 = s2.getLabel();
            if (a2.getLocation(t2, Se.ON) === w.NONE && a2.setLocation(t2, Se.ON, r2), a2.isArea(t2)) {
              var u2 = a2.getLocation(t2, Se.LEFT), l2 = a2.getLocation(t2, Se.RIGHT);
              if (l2 !== w.NONE) {
                if (l2 !== r2)
                  throw new we("side location conflict", s2.getCoordinate());
                u2 === w.NONE && et.shouldNeverReachHere("found single null side (at " + s2.getCoordinate() + ")"), r2 = u2;
              } else
                et.isTrue(a2.getLocation(t2, Se.LEFT) === w.NONE, "found single null side"), a2.setLocation(t2, Se.RIGHT, r2), a2.setLocation(t2, Se.LEFT, r2);
            }
          }
        }, Xn.prototype.getCoordinate = function() {
          var t2 = this.iterator();
          if (!t2.hasNext())
            return null;
          return t2.next().getCoordinate();
        }, Xn.prototype.print = function(t2) {
          Y.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Xn.prototype.isAreaLabelsConsistent = function(t2) {
          return this.computeEdgeEndLabels(t2.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        }, Xn.prototype.checkAreaLabelsConsistent = function(t2) {
          var e3 = this.getEdges();
          if (e3.size() <= 0)
            return true;
          var n2 = e3.size() - 1, i2 = e3.get(n2).getLabel().getLocation(t2, Se.LEFT);
          et.isTrue(i2 !== w.NONE, "Found unlabelled area edge");
          for (var r2 = i2, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next().getLabel();
            et.isTrue(s2.isArea(t2), "Found non-area edge");
            var a2 = s2.getLocation(t2, Se.LEFT), u2 = s2.getLocation(t2, Se.RIGHT);
            if (a2 === u2)
              return false;
            if (u2 !== r2)
              return false;
            r2 = a2;
          }
          return true;
        }, Xn.prototype.findIndex = function(t2) {
          this.iterator();
          for (var e3 = 0; e3 < this._edgeList.size(); e3++) {
            if (this._edgeList.get(e3) === t2)
              return e3;
          }
          return -1;
        }, Xn.prototype.iterator = function() {
          return this.getEdges().iterator();
        }, Xn.prototype.getEdges = function() {
          return null === this._edgeList && (this._edgeList = new Nt(this._edgeMap.values())), this._edgeList;
        }, Xn.prototype.getLocation = function(t2, e3, n2) {
          return this._ptInAreaLocation[t2] === w.NONE && (this._ptInAreaLocation[t2] = zn.locate(e3, n2[t2].getGeometry())), this._ptInAreaLocation[t2];
        }, Xn.prototype.toString = function() {
          var t2 = new D();
          t2.append("EdgeEndStar:   " + this.getCoordinate()), t2.append("\n");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.append(n2), t2.append("\n");
          }
          return t2.toString();
        }, Xn.prototype.computeEdgeEndLabels = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().computeLabel(t2);
          }
        }, Xn.prototype.computeLabelling = function(t2) {
          this.computeEdgeEndLabels(t2[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var e3 = [false, false], n2 = this.iterator(); n2.hasNext(); )
            for (var i2 = n2.next().getLabel(), r2 = 0; r2 < 2; r2++)
              i2.isLine(r2) && i2.getLocation(r2) === w.BOUNDARY && (e3[r2] = true);
          for (var o2 = this.iterator(); o2.hasNext(); )
            for (var s2 = o2.next(), a2 = s2.getLabel(), u2 = 0; u2 < 2; u2++)
              if (a2.isAnyNull(u2)) {
                var l2 = w.NONE;
                if (e3[u2])
                  l2 = w.EXTERIOR;
                else {
                  var c2 = s2.getCoordinate();
                  l2 = this.getLocation(u2, c2, t2);
                }
                a2.setAllLocationsIfNull(u2, l2);
              }
        }, Xn.prototype.getDegree = function() {
          return this._edgeMap.size();
        }, Xn.prototype.insertEdgeEnd = function(t2, e3) {
          this._edgeMap.put(t2, e3), this._edgeList = null;
        }, Xn.prototype.interfaces_ = function() {
          return [];
        }, Xn.prototype.getClass = function() {
          return Xn;
        };
        var Yn = function(t2) {
          function e3() {
            t2.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.linkResultDirectedEdges = function() {
            this.getResultAreaEdges();
            for (var t3 = null, e4 = null, n2 = this._SCANNING_FOR_INCOMING, i2 = 0; i2 < this._resultAreaEdgeList.size(); i2++) {
              var r2 = this._resultAreaEdgeList.get(i2), o2 = r2.getSym();
              if (r2.getLabel().isArea())
                switch (null === t3 && r2.isInResult() && (t3 = r2), n2) {
                  case this._SCANNING_FOR_INCOMING:
                    if (!o2.isInResult())
                      continue;
                    e4 = o2, n2 = this._LINKING_TO_OUTGOING;
                    break;
                  case this._LINKING_TO_OUTGOING:
                    if (!r2.isInResult())
                      continue;
                    e4.setNext(r2), n2 = this._SCANNING_FOR_INCOMING;
                }
            }
            if (n2 === this._LINKING_TO_OUTGOING) {
              if (null === t3)
                throw new we("no outgoing dirEdge found", this.getCoordinate());
              et.isTrue(t3.isInResult(), "unable to link last incoming dirEdge"), e4.setNext(t3);
            }
          }, e3.prototype.insert = function(t3) {
            var e4 = t3;
            this.insertEdgeEnd(e4, e4);
          }, e3.prototype.getRightmostEdge = function() {
            var t3 = this.getEdges(), e4 = t3.size();
            if (e4 < 1)
              return null;
            var n2 = t3.get(0);
            if (1 === e4)
              return n2;
            var i2 = t3.get(e4 - 1), r2 = n2.getQuadrant(), o2 = i2.getQuadrant();
            return Be.isNorthern(r2) && Be.isNorthern(o2) ? n2 : Be.isNorthern(r2) || Be.isNorthern(o2) ? 0 !== n2.getDy() ? n2 : 0 !== i2.getDy() ? i2 : (et.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i2;
          }, e3.prototype.print = function(t3) {
            Y.out.println("DirectedEdgeStar: " + this.getCoordinate());
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              t3.print("out "), n2.print(t3), t3.println(), t3.print("in "), n2.getSym().print(t3), t3.println();
            }
          }, e3.prototype.getResultAreaEdges = function() {
            if (null !== this._resultAreaEdgeList)
              return this._resultAreaEdgeList;
            this._resultAreaEdgeList = new Nt();
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              (e4.isInResult() || e4.getSym().isInResult()) && this._resultAreaEdgeList.add(e4);
            }
            return this._resultAreaEdgeList;
          }, e3.prototype.updateLabelling = function(t3) {
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next().getLabel();
              n2.setAllLocationsIfNull(0, t3.getLocation(0)), n2.setAllLocationsIfNull(1, t3.getLocation(1));
            }
          }, e3.prototype.linkAllDirectedEdges = function() {
            this.getEdges();
            for (var t3 = null, e4 = null, n2 = this._edgeList.size() - 1; n2 >= 0; n2--) {
              var i2 = this._edgeList.get(n2), r2 = i2.getSym();
              null === e4 && (e4 = r2), null !== t3 && r2.setNext(t3), t3 = i2;
            }
            e4.setNext(t3);
          }, e3.prototype.computeDepths = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = this.findIndex(t3), n2 = t3.getDepth(Se.LEFT), i2 = t3.getDepth(Se.RIGHT), r2 = this.computeDepths(e4 + 1, this._edgeList.size(), n2);
              if (this.computeDepths(0, e4, r2) !== i2)
                throw new we("depth mismatch at " + t3.getCoordinate());
            } else if (3 === arguments.length) {
              for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = o2; u2 < s2; u2++) {
                var l2 = this._edgeList.get(u2);
                l2.setEdgeDepths(Se.RIGHT, a2), a2 = l2.getDepth(Se.LEFT);
              }
              return a2;
            }
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              e4.getLabel().merge(e4.getSym().getLabel());
            }
          }, e3.prototype.linkMinimalDirectedEdges = function(t3) {
            for (var e4 = null, n2 = null, i2 = this._SCANNING_FOR_INCOMING, r2 = this._resultAreaEdgeList.size() - 1; r2 >= 0; r2--) {
              var o2 = this._resultAreaEdgeList.get(r2), s2 = o2.getSym();
              switch (null === e4 && o2.getEdgeRing() === t3 && (e4 = o2), i2) {
                case this._SCANNING_FOR_INCOMING:
                  if (s2.getEdgeRing() !== t3)
                    continue;
                  n2 = s2, i2 = this._LINKING_TO_OUTGOING;
                  break;
                case this._LINKING_TO_OUTGOING:
                  if (o2.getEdgeRing() !== t3)
                    continue;
                  n2.setNextMin(o2), i2 = this._SCANNING_FOR_INCOMING;
              }
            }
            i2 === this._LINKING_TO_OUTGOING && (et.isTrue(null !== e4, "found null for first outgoing dirEdge"), et.isTrue(e4.getEdgeRing() === t3, "unable to link last incoming dirEdge"), n2.setNextMin(e4));
          }, e3.prototype.getOutgoingDegree = function() {
            if (0 === arguments.length) {
              for (var t3 = 0, e4 = this.iterator(); e4.hasNext(); ) {
                e4.next().isInResult() && t3++;
              }
              return t3;
            }
            if (1 === arguments.length) {
              for (var n2 = arguments[0], i2 = 0, r2 = this.iterator(); r2.hasNext(); ) {
                r2.next().getEdgeRing() === n2 && i2++;
              }
              return i2;
            }
          }, e3.prototype.getLabel = function() {
            return this._label;
          }, e3.prototype.findCoveredLineEdges = function() {
            for (var t3 = w.NONE, e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next(), i2 = n2.getSym();
              if (!n2.isLineEdge()) {
                if (n2.isInResult()) {
                  t3 = w.INTERIOR;
                  break;
                }
                if (i2.isInResult()) {
                  t3 = w.EXTERIOR;
                  break;
                }
              }
            }
            if (t3 === w.NONE)
              return null;
            for (var r2 = t3, o2 = this.iterator(); o2.hasNext(); ) {
              var s2 = o2.next(), a2 = s2.getSym();
              s2.isLineEdge() ? s2.getEdge().setCovered(r2 === w.INTERIOR) : (s2.isInResult() && (r2 = w.EXTERIOR), a2.isInResult() && (r2 = w.INTERIOR));
            }
          }, e3.prototype.computeLabelling = function(e4) {
            t2.prototype.computeLabelling.call(this, e4), this._label = new Pe(w.NONE);
            for (var n2 = this.iterator(); n2.hasNext(); )
              for (var i2 = n2.next().getEdge().getLabel(), r2 = 0; r2 < 2; r2++) {
                var o2 = i2.getLocation(r2);
                o2 !== w.INTERIOR && o2 !== w.BOUNDARY || this._label.setLocation(r2, w.INTERIOR);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xn), kn = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.createNode = function(t3) {
            return new Ge(t3, new Yn());
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xe), jn = function t2() {
          this._pts = null, this._orientation = null;
          var e3 = arguments[0];
          this._pts = e3, this._orientation = t2.orientation(e3);
        };
        jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return jn.compareOriented(this._pts, this._orientation, e3._pts, e3._orientation);
        }, jn.prototype.interfaces_ = function() {
          return [E];
        }, jn.prototype.getClass = function() {
          return jn;
        }, jn.orientation = function(t2) {
          return 1 === Lt.increasingDirection(t2);
        }, jn.compareOriented = function(t2, e3, n2, i2) {
          for (var r2 = e3 ? 1 : -1, o2 = i2 ? 1 : -1, s2 = e3 ? t2.length : -1, a2 = i2 ? n2.length : -1, u2 = e3 ? 0 : t2.length - 1, l2 = i2 ? 0 : n2.length - 1; ; ) {
            var c2 = t2[u2].compareTo(n2[l2]);
            if (0 !== c2)
              return c2;
            var p2 = (u2 += r2) === s2, h2 = (l2 += o2) === a2;
            if (p2 && !h2)
              return -1;
            if (!p2 && h2)
              return 1;
            if (p2 && h2)
              return 0;
          }
        };
        var Hn = function() {
          this._edges = new Nt(), this._ocaMap = new p();
        };
        Hn.prototype.print = function(t2) {
          t2.print("MULTILINESTRING ( ");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            var n2 = this._edges.get(e3);
            e3 > 0 && t2.print(","), t2.print("(");
            for (var i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++)
              r2 > 0 && t2.print(","), t2.print(i2[r2].x + " " + i2[r2].y);
            t2.println(")");
          }
          t2.print(")  ");
        }, Hn.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
        }, Hn.prototype.findEdgeIndex = function(t2) {
          for (var e3 = 0; e3 < this._edges.size(); e3++)
            if (this._edges.get(e3).equals(t2))
              return e3;
          return -1;
        }, Hn.prototype.iterator = function() {
          return this._edges.iterator();
        }, Hn.prototype.getEdges = function() {
          return this._edges;
        }, Hn.prototype.get = function(t2) {
          return this._edges.get(t2);
        }, Hn.prototype.findEqualEdge = function(t2) {
          var e3 = new jn(t2.getCoordinates());
          return this._ocaMap.get(e3);
        }, Hn.prototype.add = function(t2) {
          this._edges.add(t2);
          var e3 = new jn(t2.getCoordinates());
          this._ocaMap.put(e3, t2);
        }, Hn.prototype.interfaces_ = function() {
          return [];
        }, Hn.prototype.getClass = function() {
          return Hn;
        };
        var Wn = function() {
        };
        Wn.prototype.processIntersections = function(t2, e3, n2, i2) {
        }, Wn.prototype.isDone = function() {
        }, Wn.prototype.interfaces_ = function() {
          return [];
        }, Wn.prototype.getClass = function() {
          return Wn;
        };
        var Kn = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var t2 = arguments[0];
          this._li = t2;
        };
        Kn.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
            if (Kn.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.size() - 1;
              if (0 === e3 && i2 === r2 || 0 === i2 && e3 === r2)
                return true;
            }
          }
          return false;
        }, Kn.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, Kn.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, Kn.prototype.getLineIntersector = function() {
          return this._li;
        }, Kn.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, Kn.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
        }, Kn.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, Kn.prototype.isDone = function() {
          return false;
        }, Kn.prototype.hasInteriorIntersection = function() {
          return this._hasInterior;
        }, Kn.prototype.interfaces_ = function() {
          return [Wn];
        }, Kn.prototype.getClass = function() {
          return Kn;
        }, Kn.isAdjacentSegments = function(t2, e3) {
          return 1 === Math.abs(t2 - e3);
        };
        var Jn = function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this.coord = new C(t2), this.segmentIndex = e3, this.dist = n2;
        };
        Jn.prototype.getSegmentIndex = function() {
          return this.segmentIndex;
        }, Jn.prototype.getCoordinate = function() {
          return this.coord;
        }, Jn.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex), t2.println(" dist = " + this.dist);
        }, Jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compare(e3.segmentIndex, e3.dist);
        }, Jn.prototype.isEndPoint = function(t2) {
          return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t2;
        }, Jn.prototype.toString = function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        }, Jn.prototype.getDistance = function() {
          return this.dist;
        }, Jn.prototype.compare = function(t2, e3) {
          return this.segmentIndex < t2 ? -1 : this.segmentIndex > t2 ? 1 : this.dist < e3 ? -1 : this.dist > e3 ? 1 : 0;
        }, Jn.prototype.interfaces_ = function() {
          return [E];
        }, Jn.prototype.getClass = function() {
          return Jn;
        };
        var Qn = function() {
          this._nodeMap = new p(), this.edge = null;
          var t2 = arguments[0];
          this.edge = t2;
        };
        Qn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Qn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, Qn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, Qn.prototype.addEndpoints = function() {
          var t2 = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t2], t2, 0);
        }, Qn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this.edge.pts[e3.segmentIndex], r2 = e3.dist > 0 || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a2 = t2.segmentIndex + 1; a2 <= e3.segmentIndex; a2++)
            o2[s2++] = this.edge.pts[a2];
          return r2 && (o2[s2] = e3.coord), new ni(o2, new Pe(this.edge._label));
        }, Qn.prototype.add = function(t2, e3, n2) {
          var i2 = new Jn(t2, e3, n2), r2 = this._nodeMap.get(i2);
          return null !== r2 ? r2 : (this._nodeMap.put(i2, i2), i2);
        }, Qn.prototype.isIntersection = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            if (e3.next().coord.equals(t2))
              return true;
          }
          return false;
        }, Qn.prototype.interfaces_ = function() {
          return [];
        }, Qn.prototype.getClass = function() {
          return Qn;
        };
        var Zn = function() {
        };
        Zn.prototype.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = this.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return Zn.toIntArray(n2);
        }, Zn.prototype.findChainEnd = function(t2, e3) {
          for (var n2 = Be.quadrant(t2[e3], t2[e3 + 1]), i2 = e3 + 1; i2 < t2.length; ) {
            if (Be.quadrant(t2[i2 - 1], t2[i2]) !== n2)
              break;
            i2++;
          }
          return i2 - 1;
        }, Zn.prototype.interfaces_ = function() {
          return [];
        }, Zn.prototype.getClass = function() {
          return Zn;
        }, Zn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var $n = function() {
          this.e = null, this.pts = null, this.startIndex = null, this.env1 = new j(), this.env2 = new j();
          var t2 = arguments[0];
          this.e = t2, this.pts = t2.getCoordinates();
          var e3 = new Zn();
          this.startIndex = e3.getChainStartIndices(this.pts);
        };
        $n.prototype.getCoordinates = function() {
          return this.pts;
        }, $n.prototype.getMaxX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 > n2 ? e3 : n2;
        }, $n.prototype.getMinX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 < n2 ? e3 : n2;
        }, $n.prototype.computeIntersectsForChain = function() {
          if (4 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            this.computeIntersectsForChain(this.startIndex[t2], this.startIndex[t2 + 1], e3, e3.startIndex[n2], e3.startIndex[n2 + 1], i2);
          } else if (6 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = arguments[4], l2 = arguments[5], c2 = this.pts[r2], p2 = this.pts[o2], h2 = s2.pts[a2], f2 = s2.pts[u2];
            if (o2 - r2 == 1 && u2 - a2 == 1)
              return l2.addIntersections(this.e, r2, s2.e, a2), null;
            if (this.env1.init(c2, p2), this.env2.init(h2, f2), !this.env1.intersects(this.env2))
              return null;
            var g2 = Math.trunc((r2 + o2) / 2), d2 = Math.trunc((a2 + u2) / 2);
            r2 < g2 && (a2 < d2 && this.computeIntersectsForChain(r2, g2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(r2, g2, s2, d2, u2, l2)), g2 < o2 && (a2 < d2 && this.computeIntersectsForChain(g2, o2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(g2, o2, s2, d2, u2, l2));
          }
        }, $n.prototype.getStartIndexes = function() {
          return this.startIndex;
        }, $n.prototype.computeIntersects = function(t2, e3) {
          for (var n2 = 0; n2 < this.startIndex.length - 1; n2++)
            for (var i2 = 0; i2 < t2.startIndex.length - 1; i2++)
              this.computeIntersectsForChain(n2, t2, i2, e3);
        }, $n.prototype.interfaces_ = function() {
          return [];
        }, $n.prototype.getClass = function() {
          return $n;
        };
        var ti = function t2() {
          this._depth = Array(2).fill().map(function() {
            return Array(3);
          });
          for (var e3 = 0; e3 < 2; e3++)
            for (var n2 = 0; n2 < 3; n2++)
              this._depth[e3][n2] = t2.NULL_VALUE;
        }, ei = { NULL_VALUE: { configurable: true } };
        ti.prototype.getDepth = function(t2, e3) {
          return this._depth[t2][e3];
        }, ti.prototype.setDepth = function(t2, e3, n2) {
          this._depth[t2][e3] = n2;
        }, ti.prototype.isNull = function() {
          if (0 === arguments.length) {
            for (var t2 = 0; t2 < 2; t2++)
              for (var e3 = 0; e3 < 3; e3++)
                if (this._depth[t2][e3] !== ti.NULL_VALUE)
                  return false;
            return true;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0];
            return this._depth[n2][1] === ti.NULL_VALUE;
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._depth[i2][r2] === ti.NULL_VALUE;
          }
        }, ti.prototype.normalize = function() {
          for (var t2 = 0; t2 < 2; t2++)
            if (!this.isNull(t2)) {
              var e3 = this._depth[t2][1];
              this._depth[t2][2] < e3 && (e3 = this._depth[t2][2]), e3 < 0 && (e3 = 0);
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = 0;
                this._depth[t2][n2] > e3 && (i2 = 1), this._depth[t2][n2] = i2;
              }
            }
        }, ti.prototype.getDelta = function(t2) {
          return this._depth[t2][Se.RIGHT] - this._depth[t2][Se.LEFT];
        }, ti.prototype.getLocation = function(t2, e3) {
          return this._depth[t2][e3] <= 0 ? w.EXTERIOR : w.INTERIOR;
        }, ti.prototype.toString = function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        }, ti.prototype.add = function() {
          if (1 === arguments.length)
            for (var t2 = arguments[0], e3 = 0; e3 < 2; e3++)
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = t2.getLocation(e3, n2);
                i2 !== w.EXTERIOR && i2 !== w.INTERIOR || (this.isNull(e3, n2) ? this._depth[e3][n2] = ti.depthAtLocation(i2) : this._depth[e3][n2] += ti.depthAtLocation(i2));
              }
          else if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            arguments[2] === w.INTERIOR && this._depth[r2][o2]++;
          }
        }, ti.prototype.interfaces_ = function() {
          return [];
        }, ti.prototype.getClass = function() {
          return ti;
        }, ti.depthAtLocation = function(t2) {
          return t2 === w.EXTERIOR ? 0 : t2 === w.INTERIOR ? 1 : ti.NULL_VALUE;
        }, ei.NULL_VALUE.get = function() {
          return -1;
        }, Object.defineProperties(ti, ei);
        var ni = function(t2) {
          function e3() {
            if (t2.call(this), this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new ti(), this._depthDelta = 0, 1 === arguments.length) {
              var n2 = arguments[0];
              e3.call(this, n2, null);
            } else if (2 === arguments.length) {
              var i2 = arguments[0], r2 = arguments[1];
              this.pts = i2, this._label = r2;
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getDepth = function() {
            return this._depth;
          }, e3.prototype.getCollapsedEdge = function() {
            var t3 = new Array(2).fill(null);
            t3[0] = this.pts[0], t3[1] = this.pts[1];
            return new e3(t3, Pe.toLineLabel(this._label));
          }, e3.prototype.isIsolated = function() {
            return this._isIsolated;
          }, e3.prototype.getCoordinates = function() {
            return this.pts;
          }, e3.prototype.setIsolated = function(t3) {
            this._isIsolated = t3;
          }, e3.prototype.setName = function(t3) {
            this._name = t3;
          }, e3.prototype.equals = function(t3) {
            if (!(t3 instanceof e3))
              return false;
            var n2 = t3;
            if (this.pts.length !== n2.pts.length)
              return false;
            for (var i2 = true, r2 = true, o2 = this.pts.length, s2 = 0; s2 < this.pts.length; s2++)
              if (this.pts[s2].equals2D(n2.pts[s2]) || (i2 = false), this.pts[s2].equals2D(n2.pts[--o2]) || (r2 = false), !i2 && !r2)
                return false;
            return true;
          }, e3.prototype.getCoordinate = function() {
            if (0 === arguments.length)
              return this.pts.length > 0 ? this.pts[0] : null;
            if (1 === arguments.length) {
              var t3 = arguments[0];
              return this.pts[t3];
            }
          }, e3.prototype.print = function(t3) {
            t3.print("edge " + this._name + ": "), t3.print("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.print(","), t3.print(this.pts[e4].x + " " + this.pts[e4].y);
            t3.print(")  " + this._label + " " + this._depthDelta);
          }, e3.prototype.computeIM = function(t3) {
            e3.updateIM(this._label, t3);
          }, e3.prototype.isCollapsed = function() {
            return !!this._label.isArea() && (3 === this.pts.length && !!this.pts[0].equals(this.pts[2]));
          }, e3.prototype.isClosed = function() {
            return this.pts[0].equals(this.pts[this.pts.length - 1]);
          }, e3.prototype.getMaximumSegmentIndex = function() {
            return this.pts.length - 1;
          }, e3.prototype.getDepthDelta = function() {
            return this._depthDelta;
          }, e3.prototype.getNumPoints = function() {
            return this.pts.length;
          }, e3.prototype.printReverse = function(t3) {
            t3.print("edge " + this._name + ": ");
            for (var e4 = this.pts.length - 1; e4 >= 0; e4--)
              t3.print(this.pts[e4] + " ");
            t3.println("");
          }, e3.prototype.getMonotoneChainEdge = function() {
            return null === this._mce && (this._mce = new $n(this)), this._mce;
          }, e3.prototype.getEnvelope = function() {
            if (null === this._env) {
              this._env = new j();
              for (var t3 = 0; t3 < this.pts.length; t3++)
                this._env.expandToInclude(this.pts[t3]);
            }
            return this._env;
          }, e3.prototype.addIntersection = function(t3, e4, n2, i2) {
            var r2 = new C(t3.getIntersection(i2)), o2 = e4, s2 = t3.getEdgeDistance(n2, i2), a2 = o2 + 1;
            if (a2 < this.pts.length) {
              var u2 = this.pts[a2];
              r2.equals2D(u2) && (o2 = a2, s2 = 0);
            }
            this.eiList.add(r2, o2, s2);
          }, e3.prototype.toString = function() {
            var t3 = new D();
            t3.append("edge " + this._name + ": "), t3.append("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.append(","), t3.append(this.pts[e4].x + " " + this.pts[e4].y);
            return t3.append(")  " + this._label + " " + this._depthDelta), t3.toString();
          }, e3.prototype.isPointwiseEqual = function(t3) {
            if (this.pts.length !== t3.pts.length)
              return false;
            for (var e4 = 0; e4 < this.pts.length; e4++)
              if (!this.pts[e4].equals2D(t3.pts[e4]))
                return false;
            return true;
          }, e3.prototype.setDepthDelta = function(t3) {
            this._depthDelta = t3;
          }, e3.prototype.getEdgeIntersectionList = function() {
            return this.eiList;
          }, e3.prototype.addIntersections = function(t3, e4, n2) {
            for (var i2 = 0; i2 < t3.getIntersectionNum(); i2++)
              this.addIntersection(t3, e4, n2, i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.updateIM = function() {
            if (2 !== arguments.length)
              return t2.prototype.updateIM.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            n2.setAtLeastIfValid(e4.getLocation(0, Se.ON), e4.getLocation(1, Se.ON), 1), e4.isArea() && (n2.setAtLeastIfValid(e4.getLocation(0, Se.LEFT), e4.getLocation(1, Se.LEFT), 2), n2.setAtLeastIfValid(e4.getLocation(0, Se.RIGHT), e4.getLocation(1, Se.RIGHT), 2));
          }, e3;
        }(Fe), ii = function(t2) {
          this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Hn(), this._bufParams = t2 || null;
        };
        ii.prototype.setWorkingPrecisionModel = function(t2) {
          this._workingPrecisionModel = t2;
        }, ii.prototype.insertUniqueEdge = function(t2) {
          var e3 = this._edgeList.findEqualEdge(t2);
          if (null !== e3) {
            var n2 = e3.getLabel(), i2 = t2.getLabel();
            e3.isPointwiseEqual(t2) || (i2 = new Pe(t2.getLabel())).flip(), n2.merge(i2);
            var r2 = ii.depthDelta(i2), o2 = e3.getDepthDelta() + r2;
            e3.setDepthDelta(o2);
          } else
            this._edgeList.add(t2), t2.setDepthDelta(ii.depthDelta(t2.getLabel()));
        }, ii.prototype.buildSubgraphs = function(t2, e3) {
          for (var n2 = new Nt(), i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getRightmostCoordinate(), s2 = new An(n2).getDepth(o2);
            r2.computeDepth(s2), r2.findResultEdges(), n2.add(r2), e3.add(r2.getDirectedEdges(), r2.getNodes());
          }
        }, ii.prototype.createSubgraphs = function(t2) {
          for (var e3 = new Nt(), n2 = t2.getNodes().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (!i2.isVisited()) {
              var r2 = new Te();
              r2.create(i2), e3.add(r2);
            }
          }
          return $e.sort(e3, $e.reverseOrder()), e3;
        }, ii.prototype.createEmptyResultGeometry = function() {
          return this._geomFact.createPolygon();
        }, ii.prototype.getNoder = function(t2) {
          if (null !== this._workingNoder)
            return this._workingNoder;
          var e3 = new xn(), n2 = new rt();
          return n2.setPrecisionModel(t2), e3.setSegmentIntersector(new Kn(n2)), e3;
        }, ii.prototype.buffer = function(t2, e3) {
          var n2 = this._workingPrecisionModel;
          null === n2 && (n2 = t2.getPrecisionModel()), this._geomFact = t2.getFactory();
          var i2 = new Mn(n2, this._bufParams), r2 = new Bn(t2, e3, i2).getCurves();
          if (r2.size() <= 0)
            return this.createEmptyResultGeometry();
          this.computeNodedEdges(r2, n2), this._graph = new Ye(new kn()), this._graph.addEdges(this._edgeList.getEdges());
          var o2 = this.createSubgraphs(this._graph), s2 = new ke(this._geomFact);
          this.buildSubgraphs(o2, s2);
          var a2 = s2.getPolygons();
          if (a2.size() <= 0)
            return this.createEmptyResultGeometry();
          return this._geomFact.buildGeometry(a2);
        }, ii.prototype.computeNodedEdges = function(t2, e3) {
          var n2 = this.getNoder(e3);
          n2.computeNodes(t2);
          for (var i2 = n2.getNodedSubstrings().iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getCoordinates();
            if (2 !== o2.length || !o2[0].equals2D(o2[1])) {
              var s2 = r2.getData(), a2 = new ni(r2.getCoordinates(), new Pe(s2));
              this.insertUniqueEdge(a2);
            }
          }
        }, ii.prototype.setNoder = function(t2) {
          this._workingNoder = t2;
        }, ii.prototype.interfaces_ = function() {
          return [];
        }, ii.prototype.getClass = function() {
          return ii;
        }, ii.depthDelta = function(t2) {
          var e3 = t2.getLocation(0, Se.LEFT), n2 = t2.getLocation(0, Se.RIGHT);
          return e3 === w.INTERIOR && n2 === w.EXTERIOR ? 1 : e3 === w.EXTERIOR && n2 === w.INTERIOR ? -1 : 0;
        }, ii.convertSegStrings = function(t2) {
          for (var e3 = new _e(), n2 = new Nt(); t2.hasNext(); ) {
            var i2 = t2.next(), r2 = e3.createLineString(i2.getCoordinates());
            n2.add(r2);
          }
          return e3.buildGeometry(n2);
        };
        var ri = function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, 2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._noder = t2, this._scaleFactor = e3, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = arguments[3];
            this._noder = n2, this._scaleFactor = i2, this._offsetX = r2, this._offsetY = o2, this._isScaled = !this.isIntegerPrecision();
          }
        };
        ri.prototype.rescale = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.rescale(e3.getCoordinates());
            }
          else if (arguments[0] instanceof Array) {
            for (var n2 = arguments[0], i2 = 0; i2 < n2.length; i2++)
              n2[i2].x = n2[i2].x / this._scaleFactor + this._offsetX, n2[i2].y = n2[i2].y / this._scaleFactor + this._offsetY;
            2 === n2.length && n2[0].equals2D(n2[1]) && Y.out.println(n2);
          }
        }, ri.prototype.scale = function() {
          if (T(arguments[0], It)) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              e3.add(new gn(this.scale(i2.getCoordinates()), i2.getData()));
            }
            return e3;
          }
          if (arguments[0] instanceof Array) {
            for (var r2 = arguments[0], o2 = new Array(r2.length).fill(null), s2 = 0; s2 < r2.length; s2++)
              o2[s2] = new C(Math.round((r2[s2].x - this._offsetX) * this._scaleFactor), Math.round((r2[s2].y - this._offsetY) * this._scaleFactor), r2[s2].z);
            return Lt.removeRepeatedPoints(o2);
          }
        }, ri.prototype.isIntegerPrecision = function() {
          return 1 === this._scaleFactor;
        }, ri.prototype.getNodedSubstrings = function() {
          var t2 = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(t2), t2;
        }, ri.prototype.computeNodes = function(t2) {
          var e3 = t2;
          this._isScaled && (e3 = this.scale(t2)), this._noder.computeNodes(e3);
        }, ri.prototype.interfaces_ = function() {
          return [In];
        }, ri.prototype.getClass = function() {
          return ri;
        };
        var oi = function() {
          this._li = new rt(), this._segStrings = null;
          var t2 = arguments[0];
          this._segStrings = t2;
        }, si = { fact: { configurable: true } };
        oi.prototype.checkEndPtVertexIntersections = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next().getCoordinates();
              this.checkEndPtVertexIntersections(e3[0], this._segStrings), this.checkEndPtVertexIntersections(e3[e3.length - 1], this._segStrings);
            }
          else if (2 === arguments.length) {
            for (var n2 = arguments[0], i2 = arguments[1].iterator(); i2.hasNext(); )
              for (var r2 = i2.next().getCoordinates(), o2 = 1; o2 < r2.length - 1; o2++)
                if (r2[o2].equals(n2))
                  throw new $("found endpt/interior pt intersection at index " + o2 + " :pt " + n2);
          }
        }, oi.prototype.checkInteriorIntersections = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); )
              for (var e3 = t2.next(), n2 = this._segStrings.iterator(); n2.hasNext(); ) {
                var i2 = n2.next();
                this.checkInteriorIntersections(e3, i2);
              }
          else if (2 === arguments.length)
            for (var r2 = arguments[0], o2 = arguments[1], s2 = r2.getCoordinates(), a2 = o2.getCoordinates(), u2 = 0; u2 < s2.length - 1; u2++)
              for (var l2 = 0; l2 < a2.length - 1; l2++)
                this.checkInteriorIntersections(r2, u2, o2, l2);
          else if (4 === arguments.length) {
            var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = arguments[3];
            if (c2 === h2 && p2 === f2)
              return null;
            var g2 = c2.getCoordinates()[p2], d2 = c2.getCoordinates()[p2 + 1], y3 = h2.getCoordinates()[f2], _2 = h2.getCoordinates()[f2 + 1];
            if (this._li.computeIntersection(g2, d2, y3, _2), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g2, d2) || this.hasInteriorIntersection(this._li, y3, _2)))
              throw new $("found non-noded intersection at " + g2 + "-" + d2 + " and " + y3 + "-" + _2);
          }
        }, oi.prototype.checkValid = function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        }, oi.prototype.checkCollapses = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.checkCollapses(e3);
            }
          else if (1 === arguments.length)
            for (var n2 = arguments[0].getCoordinates(), i2 = 0; i2 < n2.length - 2; i2++)
              this.checkCollapse(n2[i2], n2[i2 + 1], n2[i2 + 2]);
        }, oi.prototype.hasInteriorIntersection = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++) {
            var r2 = t2.getIntersection(i2);
            if (!r2.equals(e3) && !r2.equals(n2))
              return true;
          }
          return false;
        }, oi.prototype.checkCollapse = function(t2, e3, n2) {
          if (t2.equals(n2))
            throw new $("found non-noded collapse at " + oi.fact.createLineString([t2, e3, n2]));
        }, oi.prototype.interfaces_ = function() {
          return [];
        }, oi.prototype.getClass = function() {
          return oi;
        }, si.fact.get = function() {
          return new _e();
        }, Object.defineProperties(oi, si);
        var ai = function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          if (this._originalPt = t2, this._pt = t2, this._scaleFactor = e3, this._li = n2, e3 <= 0)
            throw new m("Scale factor must be non-zero");
          1 !== e3 && (this._pt = new C(this.scale(t2.x), this.scale(t2.y)), this._p0Scaled = new C(), this._p1Scaled = new C()), this.initCorners(this._pt);
        }, ui = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
        ai.prototype.intersectsScaled = function(t2, e3) {
          var n2 = Math.min(t2.x, e3.x), i2 = Math.max(t2.x, e3.x), r2 = Math.min(t2.y, e3.y), o2 = Math.max(t2.y, e3.y), s2 = this._maxx < n2 || this._minx > i2 || this._maxy < r2 || this._miny > o2;
          if (s2)
            return false;
          var a2 = this.intersectsToleranceSquare(t2, e3);
          return et.isTrue(!(s2 && a2), "Found bad envelope test"), a2;
        }, ai.prototype.initCorners = function(t2) {
          this._minx = t2.x - 0.5, this._maxx = t2.x + 0.5, this._miny = t2.y - 0.5, this._maxy = t2.y + 0.5, this._corner[0] = new C(this._maxx, this._maxy), this._corner[1] = new C(this._minx, this._maxy), this._corner[2] = new C(this._minx, this._miny), this._corner[3] = new C(this._maxx, this._miny);
        }, ai.prototype.intersects = function(t2, e3) {
          return 1 === this._scaleFactor ? this.intersectsScaled(t2, e3) : (this.copyScaled(t2, this._p0Scaled), this.copyScaled(e3, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        }, ai.prototype.scale = function(t2) {
          return Math.round(t2 * this._scaleFactor);
        }, ai.prototype.getCoordinate = function() {
          return this._originalPt;
        }, ai.prototype.copyScaled = function(t2, e3) {
          e3.x = this.scale(t2.x), e3.y = this.scale(t2.y);
        }, ai.prototype.getSafeEnvelope = function() {
          if (null === this._safeEnv) {
            var t2 = ai.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new j(this._originalPt.x - t2, this._originalPt.x + t2, this._originalPt.y - t2, this._originalPt.y + t2);
          }
          return this._safeEnv;
        }, ai.prototype.intersectsPixelClosure = function(t2, e3) {
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        }, ai.prototype.intersectsToleranceSquare = function(t2, e3) {
          var n2 = false, i2 = false;
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n2 = true), this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i2 = true), this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.isProper() || (!(!n2 || !i2) || (!!t2.equals(this._pt) || !!e3.equals(this._pt))))));
        }, ai.prototype.addSnappedNode = function(t2, e3) {
          var n2 = t2.getCoordinate(e3), i2 = t2.getCoordinate(e3 + 1);
          return !!this.intersects(n2, i2) && (t2.addIntersection(this.getCoordinate(), e3), true);
        }, ai.prototype.interfaces_ = function() {
          return [];
        }, ai.prototype.getClass = function() {
          return ai;
        }, ui.SAFE_ENV_EXPANSION_FACTOR.get = function() {
          return 0.75;
        }, Object.defineProperties(ai, ui);
        var li = function() {
          this.tempEnv1 = new j(), this.selectedSegment = new dn();
        };
        li.prototype.select = function() {
          if (1 === arguments.length)
            ;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            t2.getLineSegment(e3, this.selectedSegment), this.select(this.selectedSegment);
          }
        }, li.prototype.interfaces_ = function() {
          return [];
        }, li.prototype.getClass = function() {
          return li;
        };
        var ci = function() {
          this._index = null;
          var t2 = arguments[0];
          this._index = t2;
        }, pi2 = { HotPixelSnapAction: { configurable: true } };
        ci.prototype.snap = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.snap(t2, null, -1);
          }
          if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = e3.getSafeEnvelope(), o2 = new hi(e3, n2, i2);
            return this._index.query(r2, { interfaces_: function() {
              return [Ke];
            }, visitItem: function(t3) {
              t3.select(r2, o2);
            } }), o2.isNodeAdded();
          }
        }, ci.prototype.interfaces_ = function() {
          return [];
        }, ci.prototype.getClass = function() {
          return ci;
        }, pi2.HotPixelSnapAction.get = function() {
          return hi;
        }, Object.defineProperties(ci, pi2);
        var hi = function(t2) {
          function e3() {
            t2.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._hotPixel = e4, this._parentEdge = n2, this._hotPixelVertexIndex = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isNodeAdded = function() {
            return this._isNodeAdded;
          }, e3.prototype.select = function() {
            if (2 !== arguments.length)
              return t2.prototype.select.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = e4.getContext();
            if (null !== this._parentEdge && i2 === this._parentEdge && n2 === this._hotPixelVertexIndex)
              return null;
            this._isNodeAdded = this._hotPixel.addSnappedNode(i2, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(li), fi = function() {
          this._li = null, this._interiorIntersections = null;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersections = new Nt();
        };
        fi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          if (this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var u2 = 0; u2 < this._li.getIntersectionNum(); u2++)
              this._interiorIntersections.add(this._li.getIntersection(u2));
            t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1);
          }
        }, fi.prototype.isDone = function() {
          return false;
        }, fi.prototype.getInteriorIntersections = function() {
          return this._interiorIntersections;
        }, fi.prototype.interfaces_ = function() {
          return [Wn];
        }, fi.prototype.getClass = function() {
          return fi;
        };
        var gi = function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var t2 = arguments[0];
          this._pm = t2, this._li = new rt(), this._li.setPrecisionModel(t2), this._scaleFactor = t2.getScale();
        };
        gi.prototype.checkCorrectness = function(t2) {
          var e3 = gn.getNodedSubstrings(t2), n2 = new oi(e3);
          try {
            n2.checkValid();
          } catch (t3) {
            if (!(t3 instanceof z))
              throw t3;
            t3.printStackTrace();
          }
        }, gi.prototype.getNodedSubstrings = function() {
          return gn.getNodedSubstrings(this._nodedSegStrings);
        }, gi.prototype.snapRound = function(t2, e3) {
          var n2 = this.findInteriorIntersections(t2, e3);
          this.computeIntersectionSnaps(n2), this.computeVertexSnaps(t2);
        }, gi.prototype.findInteriorIntersections = function(t2, e3) {
          var n2 = new fi(e3);
          return this._noder.setSegmentIntersector(n2), this._noder.computeNodes(t2), n2.getInteriorIntersections();
        }, gi.prototype.computeVertexSnaps = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.computeVertexSnaps(e3);
            }
          else if (arguments[0] instanceof gn)
            for (var n2 = arguments[0], i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++) {
              var o2 = new ai(i2[r2], this._scaleFactor, this._li);
              this._pointSnapper.snap(o2, n2, r2) && n2.addIntersection(i2[r2], r2);
            }
        }, gi.prototype.computeNodes = function(t2) {
          this._nodedSegStrings = t2, this._noder = new xn(), this._pointSnapper = new ci(this._noder.getIndex()), this.snapRound(t2, this._li);
        }, gi.prototype.computeIntersectionSnaps = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = new ai(n2, this._scaleFactor, this._li);
            this._pointSnapper.snap(i2);
          }
        }, gi.prototype.interfaces_ = function() {
          return [In];
        }, gi.prototype.getClass = function() {
          return gi;
        };
        var di = function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new Cn(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._argGeom = t2;
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._argGeom = e3, this._bufParams = n2;
          }
        }, yi = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
        di.prototype.bufferFixedPrecision = function(t2) {
          var e3 = new ri(new gi(new fe(1)), t2.getScale()), n2 = new ii(this._bufParams);
          n2.setWorkingPrecisionModel(t2), n2.setNoder(e3), this._resultGeometry = n2.buffer(this._argGeom, this._distance);
        }, di.prototype.bufferReducedPrecision = function() {
          var t2 = this;
          if (0 === arguments.length) {
            for (var e3 = di.MAX_PRECISION_DIGITS; e3 >= 0; e3--) {
              try {
                t2.bufferReducedPrecision(e3);
              } catch (e4) {
                if (!(e4 instanceof we))
                  throw e4;
                t2._saveException = e4;
              }
              if (null !== t2._resultGeometry)
                return null;
            }
            throw this._saveException;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0], i2 = di.precisionScaleFactor(this._argGeom, this._distance, n2), r2 = new fe(i2);
            this.bufferFixedPrecision(r2);
          }
        }, di.prototype.computeGeometry = function() {
          if (this.bufferOriginalPrecision(), null !== this._resultGeometry)
            return null;
          var t2 = this._argGeom.getFactory().getPrecisionModel();
          t2.getType() === fe.FIXED ? this.bufferFixedPrecision(t2) : this.bufferReducedPrecision();
        }, di.prototype.setQuadrantSegments = function(t2) {
          this._bufParams.setQuadrantSegments(t2);
        }, di.prototype.bufferOriginalPrecision = function() {
          try {
            var t2 = new ii(this._bufParams);
            this._resultGeometry = t2.buffer(this._argGeom, this._distance);
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            this._saveException = t3;
          }
        }, di.prototype.getResultGeometry = function(t2) {
          return this._distance = t2, this.computeGeometry(), this._resultGeometry;
        }, di.prototype.setEndCapStyle = function(t2) {
          this._bufParams.setEndCapStyle(t2);
        }, di.prototype.interfaces_ = function() {
          return [];
        }, di.prototype.getClass = function() {
          return di;
        }, di.bufferOp = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return new di(t2).getResultGeometry(e3);
          }
          if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new di(n2);
              o2.setQuadrantSegments(r2);
              return o2.getResultGeometry(i2);
            }
            if (arguments[2] instanceof Cn && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
              var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2];
              return new di(s2, u2).getResultGeometry(a2);
            }
          } else if (4 === arguments.length) {
            var l2 = arguments[0], c2 = arguments[1], p2 = arguments[2], h2 = arguments[3], f2 = new di(l2);
            f2.setQuadrantSegments(p2), f2.setEndCapStyle(h2);
            return f2.getResultGeometry(c2);
          }
        }, di.precisionScaleFactor = function(t2, e3, n2) {
          var i2 = t2.getEnvelopeInternal(), r2 = R.max(Math.abs(i2.getMaxX()), Math.abs(i2.getMaxY()), Math.abs(i2.getMinX()), Math.abs(i2.getMinY())) + 2 * (e3 > 0 ? e3 : 0), o2 = n2 - Math.trunc(Math.log(r2) / Math.log(10) + 1);
          return Math.pow(10, o2);
        }, yi.CAP_ROUND.get = function() {
          return Cn.CAP_ROUND;
        }, yi.CAP_BUTT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_FLAT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_SQUARE.get = function() {
          return Cn.CAP_SQUARE;
        }, yi.MAX_PRECISION_DIGITS.get = function() {
          return 12;
        }, Object.defineProperties(di, yi);
        var _i = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        _i.prototype.getCoordinates = function() {
          return this._pt;
        }, _i.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, _i.prototype.setMinimum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.initialize = function() {
          if (0 === arguments.length)
            this._isNull = true;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, _i.prototype.getDistance = function() {
          return this._distance;
        }, _i.prototype.setMaximum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.interfaces_ = function() {
          return [];
        }, _i.prototype.getClass = function() {
          return _i;
        };
        var mi = function() {
        };
        mi.prototype.interfaces_ = function() {
          return [];
        }, mi.prototype.getClass = function() {
          return mi;
        }, mi.computeDistance = function() {
          if (arguments[2] instanceof _i && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2.getCoordinates(), r2 = new dn(), o2 = 0; o2 < i2.length - 1; o2++) {
              r2.setCoordinates(i2[o2], i2[o2 + 1]);
              var s2 = r2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof _i && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            mi.computeDistance(a2.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
              mi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y3 = g2.getGeometryN(d2);
                mi.computeDistance(y3, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
            v2.setMinimum(I2, m2);
          }
        };
        var vi = function(t2) {
          this._maxPtDist = new _i(), this._inputGeom = t2 || null;
        }, Ii = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
        vi.prototype.computeMaxMidpointDistance = function(t2) {
          var e3 = new xi(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.computeMaxVertexDistance = function(t2) {
          var e3 = new Ei(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.findDistance = function(t2) {
          return this.computeMaxVertexDistance(t2), this.computeMaxMidpointDistance(t2), this._maxPtDist.getDistance();
        }, vi.prototype.getDistancePoints = function() {
          return this._maxPtDist;
        }, vi.prototype.interfaces_ = function() {
          return [];
        }, vi.prototype.getClass = function() {
          return vi;
        }, Ii.MaxPointDistanceFilter.get = function() {
          return Ei;
        }, Ii.MaxMidpointDistanceFilter.get = function() {
          return xi;
        }, Object.defineProperties(vi, Ii);
        var Ei = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        Ei.prototype.filter = function(t2) {
          this._minPtDist.initialize(), mi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ei.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ei.prototype.interfaces_ = function() {
          return [ft];
        }, Ei.prototype.getClass = function() {
          return Ei;
        };
        var xi = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        xi.prototype.filter = function(t2, e3) {
          if (0 === e3)
            return null;
          var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = new C((n2.x + i2.x) / 2, (n2.y + i2.y) / 2);
          this._minPtDist.initialize(), mi.computeDistance(this._geom, r2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, xi.prototype.isDone = function() {
          return false;
        }, xi.prototype.isGeometryChanged = function() {
          return false;
        }, xi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, xi.prototype.interfaces_ = function() {
          return [Ut];
        }, xi.prototype.getClass = function() {
          return xi;
        };
        var Ni = function(t2) {
          this._comps = t2 || null;
        };
        Ni.prototype.filter = function(t2) {
          t2 instanceof $t && this._comps.add(t2);
        }, Ni.prototype.interfaces_ = function() {
          return [Vt];
        }, Ni.prototype.getClass = function() {
          return Ni;
        }, Ni.getPolygons = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Ni.getPolygons(t2, new Nt());
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof $t ? n2.add(e3) : e3 instanceof zt && e3.apply(new Ni(n2)), n2;
          }
        };
        var Ci = function() {
          if (this._lines = null, this._isForcedToLineString = false, 1 === arguments.length) {
            var t2 = arguments[0];
            this._lines = t2;
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._lines = e3, this._isForcedToLineString = n2;
          }
        };
        Ci.prototype.filter = function(t2) {
          if (this._isForcedToLineString && t2 instanceof ee) {
            var e3 = t2.getFactory().createLineString(t2.getCoordinateSequence());
            return this._lines.add(e3), null;
          }
          t2 instanceof Kt && this._lines.add(t2);
        }, Ci.prototype.setForceToLineString = function(t2) {
          this._isForcedToLineString = t2;
        }, Ci.prototype.interfaces_ = function() {
          return [lt];
        }, Ci.prototype.getClass = function() {
          return Ci;
        }, Ci.getGeometry = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2.getFactory().buildGeometry(Ci.getLines(t2));
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().buildGeometry(Ci.getLines(e3, n2));
          }
        }, Ci.getLines = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Ci.getLines(t2, false);
          }
          if (2 === arguments.length) {
            if (T(arguments[0], It) && T(arguments[1], It)) {
              for (var e3 = arguments[0], n2 = arguments[1], i2 = e3.iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                Ci.getLines(r2, n2);
              }
              return n2;
            }
            if (arguments[0] instanceof ct && "boolean" == typeof arguments[1]) {
              var o2 = arguments[0], s2 = arguments[1], a2 = new Nt();
              return o2.apply(new Ci(a2, s2)), a2;
            }
            if (arguments[0] instanceof ct && T(arguments[1], It)) {
              var u2 = arguments[0], l2 = arguments[1];
              return u2 instanceof Kt ? l2.add(u2) : u2.apply(new Ci(l2)), l2;
            }
          } else if (3 === arguments.length) {
            if ("boolean" == typeof arguments[2] && T(arguments[0], It) && T(arguments[1], It)) {
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = c2.iterator(); f2.hasNext(); ) {
                var g2 = f2.next();
                Ci.getLines(g2, p2, h2);
              }
              return p2;
            }
            if ("boolean" == typeof arguments[2] && arguments[0] instanceof ct && T(arguments[1], It)) {
              var d2 = arguments[0], y3 = arguments[1], _2 = arguments[2];
              return d2.apply(new Ci(y3, _2)), y3;
            }
          }
        };
        var Si = function() {
          if (this._boundaryRule = gt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            if (null === t2)
              throw new m("Rule must be non-null");
            this._boundaryRule = t2;
          }
        };
        Si.prototype.locateInternal = function() {
          if (arguments[0] instanceof C && arguments[1] instanceof $t) {
            var t2 = arguments[0], e3 = arguments[1];
            if (e3.isEmpty())
              return w.EXTERIOR;
            var n2 = e3.getExteriorRing(), i2 = this.locateInPolygonRing(t2, n2);
            if (i2 === w.EXTERIOR)
              return w.EXTERIOR;
            if (i2 === w.BOUNDARY)
              return w.BOUNDARY;
            for (var r2 = 0; r2 < e3.getNumInteriorRing(); r2++) {
              var o2 = e3.getInteriorRingN(r2), s2 = this.locateInPolygonRing(t2, o2);
              if (s2 === w.INTERIOR)
                return w.EXTERIOR;
              if (s2 === w.BOUNDARY)
                return w.BOUNDARY;
            }
            return w.INTERIOR;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Kt) {
            var a2 = arguments[0], u2 = arguments[1];
            if (!u2.getEnvelopeInternal().intersects(a2))
              return w.EXTERIOR;
            var l2 = u2.getCoordinates();
            return u2.isClosed() || !a2.equals(l2[0]) && !a2.equals(l2[l2.length - 1]) ? at.isOnLine(a2, l2) ? w.INTERIOR : w.EXTERIOR : w.BOUNDARY;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Qt) {
            var c2 = arguments[0];
            return arguments[1].getCoordinate().equals2D(c2) ? w.INTERIOR : w.EXTERIOR;
          }
        }, Si.prototype.locateInPolygonRing = function(t2, e3) {
          return e3.getEnvelopeInternal().intersects(t2) ? at.locatePointInRing(t2, e3.getCoordinates()) : w.EXTERIOR;
        }, Si.prototype.intersects = function(t2, e3) {
          return this.locate(t2, e3) !== w.EXTERIOR;
        }, Si.prototype.updateLocationInfo = function(t2) {
          t2 === w.INTERIOR && (this._isIn = true), t2 === w.BOUNDARY && this._numBoundaries++;
        }, Si.prototype.computeLocation = function(t2, e3) {
          if (e3 instanceof Qt && this.updateLocationInfo(this.locateInternal(t2, e3)), e3 instanceof Kt)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof $t)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof Xt)
            for (var n2 = e3, i2 = 0; i2 < n2.getNumGeometries(); i2++) {
              var r2 = n2.getGeometryN(i2);
              this.updateLocationInfo(this.locateInternal(t2, r2));
            }
          else if (e3 instanceof ne)
            for (var o2 = e3, s2 = 0; s2 < o2.getNumGeometries(); s2++) {
              var a2 = o2.getGeometryN(s2);
              this.updateLocationInfo(this.locateInternal(t2, a2));
            }
          else if (e3 instanceof zt)
            for (var u2 = new Un(e3); u2.hasNext(); ) {
              var l2 = u2.next();
              l2 !== e3 && this.computeLocation(t2, l2);
            }
        }, Si.prototype.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : e3 instanceof Kt ? this.locateInternal(t2, e3) : e3 instanceof $t ? this.locateInternal(t2, e3) : (this._isIn = false, this._numBoundaries = 0, this.computeLocation(t2, e3), this._boundaryRule.isInBoundary(this._numBoundaries) ? w.BOUNDARY : this._numBoundaries > 0 || this._isIn ? w.INTERIOR : w.EXTERIOR);
        }, Si.prototype.interfaces_ = function() {
          return [];
        }, Si.prototype.getClass = function() {
          return Si;
        };
        var Li = function t2() {
          if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3, t2.INSIDE_AREA, n2);
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._component = i2, this._segIndex = r2, this._pt = o2;
          }
        }, bi = { INSIDE_AREA: { configurable: true } };
        Li.prototype.isInsideArea = function() {
          return this._segIndex === Li.INSIDE_AREA;
        }, Li.prototype.getCoordinate = function() {
          return this._pt;
        }, Li.prototype.getGeometryComponent = function() {
          return this._component;
        }, Li.prototype.getSegmentIndex = function() {
          return this._segIndex;
        }, Li.prototype.interfaces_ = function() {
          return [];
        }, Li.prototype.getClass = function() {
          return Li;
        }, bi.INSIDE_AREA.get = function() {
          return -1;
        }, Object.defineProperties(Li, bi);
        var wi = function(t2) {
          this._pts = t2 || null;
        };
        wi.prototype.filter = function(t2) {
          t2 instanceof Qt && this._pts.add(t2);
        }, wi.prototype.interfaces_ = function() {
          return [Vt];
        }, wi.prototype.getClass = function() {
          return wi;
        }, wi.getPoints = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2 instanceof Qt ? $e.singletonList(t2) : wi.getPoints(t2, new Nt());
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof Qt ? n2.add(e3) : e3 instanceof zt && e3.apply(new wi(n2)), n2;
          }
        };
        var Oi = function() {
          this._locations = null;
          var t2 = arguments[0];
          this._locations = t2;
        };
        Oi.prototype.filter = function(t2) {
          (t2 instanceof Qt || t2 instanceof Kt || t2 instanceof $t) && this._locations.add(new Li(t2, 0, t2.getCoordinate()));
        }, Oi.prototype.interfaces_ = function() {
          return [Vt];
        }, Oi.prototype.getClass = function() {
          return Oi;
        }, Oi.getLocations = function(t2) {
          var e3 = new Nt();
          return t2.apply(new Oi(e3)), e3;
        };
        var Ti = function() {
          if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Si(), this._minDistanceLocation = null, this._minDistance = v.MAX_VALUE, 2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._geom = [t2, e3], this._terminateDistance = 0;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._geom = new Array(2).fill(null), this._geom[0] = n2, this._geom[1] = i2, this._terminateDistance = r2;
          }
        };
        Ti.prototype.computeContainmentDistance = function() {
          if (0 === arguments.length) {
            var t2 = new Array(2).fill(null);
            if (this.computeContainmentDistance(0, t2), this._minDistance <= this._terminateDistance)
              return null;
            this.computeContainmentDistance(1, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = 1 - e3, r2 = Ni.getPolygons(this._geom[e3]);
            if (r2.size() > 0) {
              var o2 = Oi.getLocations(this._geom[i2]);
              if (this.computeContainmentDistance(o2, r2, n2), this._minDistance <= this._terminateDistance)
                return this._minDistanceLocation[i2] = n2[0], this._minDistanceLocation[e3] = n2[1], null;
            }
          } else if (3 === arguments.length) {
            if (arguments[2] instanceof Array && T(arguments[0], xt) && T(arguments[1], xt)) {
              for (var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2], l2 = 0; l2 < s2.size(); l2++)
                for (var c2 = s2.get(l2), p2 = 0; p2 < a2.size(); p2++)
                  if (this.computeContainmentDistance(c2, a2.get(p2), u2), this._minDistance <= this._terminateDistance)
                    return null;
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Li && arguments[1] instanceof $t) {
              var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = h2.getCoordinate();
              if (w.EXTERIOR !== this._ptLocator.locate(d2, f2))
                return this._minDistance = 0, g2[0] = h2, g2[1] = new Li(f2, d2), null;
            }
          }
        }, Ti.prototype.computeMinDistanceLinesPoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.computeFacetDistance = function() {
          var t2 = new Array(2).fill(null), e3 = Ci.getLines(this._geom[0]), n2 = Ci.getLines(this._geom[1]), i2 = wi.getPoints(this._geom[0]), r2 = wi.getPoints(this._geom[1]);
          return this.computeMinDistanceLines(e3, n2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(e3, r2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(n2, i2, t2), this.updateMinDistance(t2, true), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistancePoints(i2, r2, t2), void this.updateMinDistance(t2, false))));
        }, Ti.prototype.nearestLocations = function() {
          return this.computeMinDistance(), this._minDistanceLocation;
        }, Ti.prototype.updateMinDistance = function(t2, e3) {
          if (null === t2[0])
            return null;
          e3 ? (this._minDistanceLocation[0] = t2[1], this._minDistanceLocation[1] = t2[0]) : (this._minDistanceLocation[0] = t2[0], this._minDistanceLocation[1] = t2[1]);
        }, Ti.prototype.nearestPoints = function() {
          this.computeMinDistance();
          return [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
        }, Ti.prototype.computeMinDistance = function() {
          if (0 === arguments.length) {
            if (null !== this._minDistanceLocation)
              return null;
            if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance)
              return null;
            this.computeFacetDistance();
          } else if (3 === arguments.length) {
            if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Qt) {
              var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
              if (t2.getEnvelopeInternal().distance(e3.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var i2 = t2.getCoordinates(), r2 = e3.getCoordinate(), o2 = 0; o2 < i2.length - 1; o2++) {
                var s2 = at.distancePointLine(r2, i2[o2], i2[o2 + 1]);
                if (s2 < this._minDistance) {
                  this._minDistance = s2;
                  var a2 = new dn(i2[o2], i2[o2 + 1]).closestPoint(r2);
                  n2[0] = new Li(t2, o2, a2), n2[1] = new Li(e3, 0, r2);
                }
                if (this._minDistance <= this._terminateDistance)
                  return null;
              }
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Kt) {
              var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
              if (u2.getEnvelopeInternal().distance(l2.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var p2 = u2.getCoordinates(), h2 = l2.getCoordinates(), f2 = 0; f2 < p2.length - 1; f2++)
                for (var g2 = 0; g2 < h2.length - 1; g2++) {
                  var d2 = at.distanceLineLine(p2[f2], p2[f2 + 1], h2[g2], h2[g2 + 1]);
                  if (d2 < this._minDistance) {
                    this._minDistance = d2;
                    var y3 = new dn(p2[f2], p2[f2 + 1]), _2 = new dn(h2[g2], h2[g2 + 1]), m2 = y3.closestPoints(_2);
                    c2[0] = new Li(u2, f2, m2[0]), c2[1] = new Li(l2, g2, m2[1]);
                  }
                  if (this._minDistance <= this._terminateDistance)
                    return null;
                }
            }
          }
        }, Ti.prototype.computeMinDistancePoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2), a2 = r2.getCoordinate().distance(s2.getCoordinate());
              if (a2 < this._minDistance && (this._minDistance = a2, n2[0] = new Li(r2, 0, r2.getCoordinate()), n2[1] = new Li(s2, 0, s2.getCoordinate())), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.distance = function() {
          if (null === this._geom[0] || null === this._geom[1])
            throw new m("null geometries are not supported");
          return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
        }, Ti.prototype.computeMinDistanceLines = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.interfaces_ = function() {
          return [];
        }, Ti.prototype.getClass = function() {
          return Ti;
        }, Ti.distance = function(t2, e3) {
          return new Ti(t2, e3).distance();
        }, Ti.isWithinDistance = function(t2, e3, n2) {
          return new Ti(t2, e3, n2).distance() <= n2;
        }, Ti.nearestPoints = function(t2, e3) {
          return new Ti(t2, e3).nearestPoints();
        };
        var Ri = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        Ri.prototype.getCoordinates = function() {
          return this._pt;
        }, Ri.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, Ri.prototype.setMinimum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.initialize = function() {
          if (0 === arguments.length)
            this._isNull = true;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, Ri.prototype.toString = function() {
          return Z.toLineString(this._pt[0], this._pt[1]);
        }, Ri.prototype.getDistance = function() {
          return this._distance;
        }, Ri.prototype.setMaximum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.interfaces_ = function() {
          return [];
        }, Ri.prototype.getClass = function() {
          return Ri;
        };
        var Pi = function() {
        };
        Pi.prototype.interfaces_ = function() {
          return [];
        }, Pi.prototype.getClass = function() {
          return Pi;
        }, Pi.computeDistance = function() {
          if (arguments[2] instanceof Ri && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = new dn(), r2 = t2.getCoordinates(), o2 = 0; o2 < r2.length - 1; o2++) {
              i2.setCoordinates(r2[o2], r2[o2 + 1]);
              var s2 = i2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof Ri && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            Pi.computeDistance(a2.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
              Pi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y3 = g2.getGeometryN(d2);
                Pi.computeDistance(y3, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
            v2.setMinimum(I2, m2);
          }
        };
        var Di = function() {
          this._g0 = null, this._g1 = null, this._ptDist = new Ri(), this._densifyFrac = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._g0 = t2, this._g1 = e3;
        }, Mi = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
        Di.prototype.getCoordinates = function() {
          return this._ptDist.getCoordinates();
        }, Di.prototype.setDensifyFraction = function(t2) {
          if (t2 > 1 || t2 <= 0)
            throw new m("Fraction is not in range (0.0 - 1.0]");
          this._densifyFrac = t2;
        }, Di.prototype.compute = function(t2, e3) {
          this.computeOrientedDistance(t2, e3, this._ptDist), this.computeOrientedDistance(e3, t2, this._ptDist);
        }, Di.prototype.distance = function() {
          return this.compute(this._g0, this._g1), this._ptDist.getDistance();
        }, Di.prototype.computeOrientedDistance = function(t2, e3, n2) {
          var i2 = new Ai(e3);
          if (t2.apply(i2), n2.setMaximum(i2.getMaxPointDistance()), this._densifyFrac > 0) {
            var r2 = new Fi(e3, this._densifyFrac);
            t2.apply(r2), n2.setMaximum(r2.getMaxPointDistance());
          }
        }, Di.prototype.orientedDistance = function() {
          return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
        }, Di.prototype.interfaces_ = function() {
          return [];
        }, Di.prototype.getClass = function() {
          return Di;
        }, Di.distance = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return new Di(t2, e3).distance();
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new Di(n2, i2);
            return o2.setDensifyFraction(r2), o2.distance();
          }
        }, Mi.MaxPointDistanceFilter.get = function() {
          return Ai;
        }, Mi.MaxDensifiedByFractionDistanceFilter.get = function() {
          return Fi;
        }, Object.defineProperties(Di, Mi);
        var Ai = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._euclideanDist = new Pi(), this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        Ai.prototype.filter = function(t2) {
          this._minPtDist.initialize(), Pi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ai.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ai.prototype.interfaces_ = function() {
          return [ft];
        }, Ai.prototype.getClass = function() {
          return Ai;
        };
        var Fi = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._geom = null, this._numSubSegs = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._geom = t2, this._numSubSegs = Math.trunc(Math.round(1 / e3));
        };
        Fi.prototype.filter = function(t2, e3) {
          if (0 === e3)
            return null;
          for (var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = (i2.x - n2.x) / this._numSubSegs, o2 = (i2.y - n2.y) / this._numSubSegs, s2 = 0; s2 < this._numSubSegs; s2++) {
            var a2 = n2.x + s2 * r2, u2 = n2.y + s2 * o2, l2 = new C(a2, u2);
            this._minPtDist.initialize(), Pi.computeDistance(this._geom, l2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
          }
        }, Fi.prototype.isDone = function() {
          return false;
        }, Fi.prototype.isGeometryChanged = function() {
          return false;
        }, Fi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Fi.prototype.interfaces_ = function() {
          return [Ut];
        }, Fi.prototype.getClass = function() {
          return Fi;
        };
        var Gi = function(t2, e3, n2) {
          this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = true, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._bufDistance = e3 || null, this._result = n2 || null;
        }, qi = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
        Gi.prototype.checkMaximumDistance = function(t2, e3, n2) {
          var i2 = new Di(e3, t2);
          if (i2.setDensifyFraction(0.25), this._maxDistanceFound = i2.orientedDistance(), this._maxDistanceFound > n2) {
            this._isValid = false;
            var r2 = i2.getCoordinates();
            this._errorLocation = r2[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + ")";
          }
        }, Gi.prototype.isValid = function() {
          var t2 = Math.abs(this._bufDistance), e3 = Gi.MAX_DISTANCE_DIFF_FRAC * t2;
          return this._minValidDistance = t2 - e3, this._maxValidDistance = t2 + e3, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Gi.VERBOSE && Y.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
        }, Gi.prototype.checkNegativeValid = function() {
          if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof zt))
            return null;
          var t2 = this.getPolygonLines(this._input);
          if (this.checkMinimumDistance(t2, this._result, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(t2, this._result, this._maxValidDistance);
        }, Gi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Gi.prototype.checkMinimumDistance = function(t2, e3, n2) {
          var i2 = new Ti(t2, e3, n2);
          if (this._minDistanceFound = i2.distance(), this._minDistanceFound < n2) {
            this._isValid = false;
            var r2 = i2.nearestPoints();
            this._errorLocation = i2.nearestPoints()[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + " )";
          }
        }, Gi.prototype.checkPositiveValid = function() {
          var t2 = this._result.getBoundary();
          if (this.checkMinimumDistance(this._input, t2, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(this._input, t2, this._maxValidDistance);
        }, Gi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Gi.prototype.getPolygonLines = function(t2) {
          for (var e3 = new Nt(), n2 = new Ci(e3), i2 = Ni.getPolygons(t2).iterator(); i2.hasNext(); ) {
            i2.next().apply(n2);
          }
          return t2.getFactory().buildGeometry(e3);
        }, Gi.prototype.getErrorMessage = function() {
          return this._errMsg;
        }, Gi.prototype.interfaces_ = function() {
          return [];
        }, Gi.prototype.getClass = function() {
          return Gi;
        }, qi.VERBOSE.get = function() {
          return false;
        }, qi.MAX_DISTANCE_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Gi, qi);
        var Bi = function(t2, e3, n2) {
          this._isValid = true, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._distance = e3 || null, this._result = n2 || null;
        }, Vi = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
        Bi.prototype.isValid = function() {
          return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
        }, Bi.prototype.checkEnvelope = function() {
          if (this._distance < 0)
            return null;
          var t2 = this._distance * Bi.MAX_ENV_DIFF_FRAC;
          0 === t2 && (t2 = 1e-3);
          var e3 = new j(this._input.getEnvelopeInternal());
          e3.expandBy(this._distance);
          var n2 = new j(this._result.getEnvelopeInternal());
          n2.expandBy(t2), n2.contains(e3) || (this._isValid = false, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n2)), this.report("Envelope");
        }, Bi.prototype.checkDistance = function() {
          var t2 = new Gi(this._input, this._distance, this._result);
          t2.isValid() || (this._isValid = false, this._errorMsg = t2.getErrorMessage(), this._errorLocation = t2.getErrorLocation(), this._errorIndicator = t2.getErrorIndicator()), this.report("Distance");
        }, Bi.prototype.checkArea = function() {
          var t2 = this._input.getArea(), e3 = this._result.getArea();
          this._distance > 0 && t2 > e3 && (this._isValid = false, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t2 < e3 && (this._isValid = false, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
        }, Bi.prototype.checkPolygonal = function() {
          this._result instanceof $t || this._result instanceof ne || (this._isValid = false), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
        }, Bi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Bi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Bi.prototype.checkExpectedEmpty = function() {
          return this._input.getDimension() >= 2 ? null : this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = false, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"));
        }, Bi.prototype.report = function(t2) {
          if (!Bi.VERBOSE)
            return null;
          Y.out.println("Check " + t2 + ": " + (this._isValid ? "passed" : "FAILED"));
        }, Bi.prototype.getErrorMessage = function() {
          return this._errorMsg;
        }, Bi.prototype.interfaces_ = function() {
          return [];
        }, Bi.prototype.getClass = function() {
          return Bi;
        }, Bi.isValidMsg = function(t2, e3, n2) {
          var i2 = new Bi(t2, e3, n2);
          return i2.isValid() ? null : i2.getErrorMessage();
        }, Bi.isValid = function(t2, e3, n2) {
          return !!new Bi(t2, e3, n2).isValid();
        }, Vi.VERBOSE.get = function() {
          return false;
        }, Vi.MAX_ENV_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Bi, Vi);
        var Ui = function() {
          this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        Ui.prototype.getCoordinates = function() {
          return this._pts;
        }, Ui.prototype.size = function() {
          return this._pts.length;
        }, Ui.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, Ui.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, Ui.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : pn.octant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, Ui.prototype.setData = function(t2) {
          this._data = t2;
        }, Ui.prototype.getData = function() {
          return this._data;
        }, Ui.prototype.toString = function() {
          return Z.toLineString(new ue(this._pts));
        }, Ui.prototype.interfaces_ = function() {
          return [hn];
        }, Ui.prototype.getClass = function() {
          return Ui;
        };
        var zi = function() {
          this._findAllIntersections = false, this._isCheckEndSegmentsOnly = false, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Nt(), this._intersectionCount = 0, this._keepIntersections = true;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersection = null;
        };
        zi.prototype.getInteriorIntersection = function() {
          return this._interiorIntersection;
        }, zi.prototype.setCheckEndSegmentsOnly = function(t2) {
          this._isCheckEndSegmentsOnly = t2;
        }, zi.prototype.getIntersectionSegments = function() {
          return this._intSegments;
        }, zi.prototype.count = function() {
          return this._intersectionCount;
        }, zi.prototype.getIntersections = function() {
          return this._intersections;
        }, zi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, zi.prototype.setKeepIntersections = function(t2) {
          this._keepIntersections = t2;
        }, zi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (!this._findAllIntersections && this.hasIntersection())
            return null;
          if (t2 === n2 && e3 === i2)
            return null;
          if (this._isCheckEndSegmentsOnly) {
            if (!(this.isEndSegment(t2, e3) || this.isEndSegment(n2, i2)))
              return null;
          }
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = r2, this._intSegments[1] = o2, this._intSegments[2] = s2, this._intSegments[3] = a2, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
        }, zi.prototype.isEndSegment = function(t2, e3) {
          return 0 === e3 || e3 >= t2.size() - 2;
        }, zi.prototype.hasIntersection = function() {
          return null !== this._interiorIntersection;
        }, zi.prototype.isDone = function() {
          return !this._findAllIntersections && null !== this._interiorIntersection;
        }, zi.prototype.interfaces_ = function() {
          return [Wn];
        }, zi.prototype.getClass = function() {
          return zi;
        }, zi.createAllIntersectionsFinder = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3;
        }, zi.createAnyIntersectionFinder = function(t2) {
          return new zi(t2);
        }, zi.createIntersectionCounter = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3.setKeepIntersections(false), e3;
        };
        var Xi = function() {
          this._li = new rt(), this._segStrings = null, this._findAllIntersections = false, this._segInt = null, this._isValid = true;
          var t2 = arguments[0];
          this._segStrings = t2;
        };
        Xi.prototype.execute = function() {
          if (null !== this._segInt)
            return null;
          this.checkInteriorIntersections();
        }, Xi.prototype.getIntersections = function() {
          return this._segInt.getIntersections();
        }, Xi.prototype.isValid = function() {
          return this.execute(), this._isValid;
        }, Xi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, Xi.prototype.checkInteriorIntersections = function() {
          this._isValid = true, this._segInt = new zi(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
          var t2 = new xn();
          if (t2.setSegmentIntersector(this._segInt), t2.computeNodes(this._segStrings), this._segInt.hasIntersection())
            return this._isValid = false, null;
        }, Xi.prototype.checkValid = function() {
          if (this.execute(), !this._isValid)
            throw new we(this.getErrorMessage(), this._segInt.getInteriorIntersection());
        }, Xi.prototype.getErrorMessage = function() {
          if (this._isValid)
            return "no intersections found";
          var t2 = this._segInt.getIntersectionSegments();
          return "found non-noded intersection between " + Z.toLineString(t2[0], t2[1]) + " and " + Z.toLineString(t2[2], t2[3]);
        }, Xi.prototype.interfaces_ = function() {
          return [];
        }, Xi.prototype.getClass = function() {
          return Xi;
        }, Xi.computeIntersections = function(t2) {
          var e3 = new Xi(t2);
          return e3.setFindAllIntersections(true), e3.isValid(), e3.getIntersections();
        };
        var Yi = function t2() {
          this._nv = null;
          var e3 = arguments[0];
          this._nv = new Xi(t2.toSegmentStrings(e3));
        };
        Yi.prototype.checkValid = function() {
          this._nv.checkValid();
        }, Yi.prototype.interfaces_ = function() {
          return [];
        }, Yi.prototype.getClass = function() {
          return Yi;
        }, Yi.toSegmentStrings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3.add(new Ui(i2.getCoordinates(), i2));
          }
          return e3;
        }, Yi.checkValid = function(t2) {
          new Yi(t2).checkValid();
        };
        var ki = function(t2) {
          this._mapOp = t2;
        };
        ki.prototype.map = function(t2) {
          for (var e3 = new Nt(), n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = this._mapOp.map(t2.getGeometryN(n2));
            i2.isEmpty() || e3.add(i2);
          }
          return t2.getFactory().createGeometryCollection(_e.toGeometryArray(e3));
        }, ki.prototype.interfaces_ = function() {
          return [];
        }, ki.prototype.getClass = function() {
          return ki;
        }, ki.map = function(t2, e3) {
          return new ki(e3).map(t2);
        };
        var ji = function() {
          this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Nt(), this._resultLineList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._op = t2, this._geometryFactory = e3, this._ptLocator = n2;
        };
        ji.prototype.collectLines = function(t2) {
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.collectLineEdge(n2, t2, this._lineEdgesList), this.collectBoundaryTouchEdge(n2, t2, this._lineEdgesList);
          }
        }, ji.prototype.labelIsolatedLine = function(t2, e3) {
          var n2 = this._ptLocator.locate(t2.getCoordinate(), this._op.getArgGeometry(e3));
          t2.getLabel().setLocation(e3, n2);
        }, ji.prototype.build = function(t2) {
          return this.findCoveredLineEdges(), this.collectLines(t2), this.buildLines(t2), this._resultLineList;
        }, ji.prototype.collectLineEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel(), r2 = t2.getEdge();
          t2.isLineEdge() && (t2.isVisited() || !Lr.isResultOfOp(i2, e3) || r2.isCovered() || (n2.add(r2), t2.setVisitedEdge(true)));
        }, ji.prototype.findCoveredLineEdges = function() {
          for (var t2 = this._op.getGraph().getNodes().iterator(); t2.hasNext(); ) {
            t2.next().getEdges().findCoveredLineEdges();
          }
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getEdge();
            if (n2.isLineEdge() && !i2.isCoveredSet()) {
              var r2 = this._op.isCoveredByA(n2.getCoordinate());
              i2.setCovered(r2);
            }
          }
        }, ji.prototype.labelIsolatedLines = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getLabel();
            n2.isIsolated() && (i2.isNull(0) ? this.labelIsolatedLine(n2, 0) : this.labelIsolatedLine(n2, 1));
          }
        }, ji.prototype.buildLines = function(t2) {
          for (var e3 = this._lineEdgesList.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = this._geometryFactory.createLineString(n2.getCoordinates());
            this._resultLineList.add(i2), n2.setInResult(true);
          }
        }, ji.prototype.collectBoundaryTouchEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel();
          return t2.isLineEdge() ? null : t2.isVisited() ? null : t2.isInteriorAreaEdge() ? null : t2.getEdge().isInResult() ? null : (et.isTrue(!(t2.isInResult() || t2.getSym().isInResult()) || !t2.getEdge().isInResult()), void (Lr.isResultOfOp(i2, e3) && e3 === Lr.INTERSECTION && (n2.add(t2.getEdge()), t2.setVisitedEdge(true))));
        }, ji.prototype.interfaces_ = function() {
          return [];
        }, ji.prototype.getClass = function() {
          return ji;
        };
        var Hi = function() {
          this._op = null, this._geometryFactory = null, this._resultPointList = new Nt();
          var t2 = arguments[0], e3 = arguments[1];
          this._op = t2, this._geometryFactory = e3;
        };
        Hi.prototype.filterCoveredNodeToPoint = function(t2) {
          var e3 = t2.getCoordinate();
          if (!this._op.isCoveredByLA(e3)) {
            var n2 = this._geometryFactory.createPoint(e3);
            this._resultPointList.add(n2);
          }
        }, Hi.prototype.extractNonCoveredResultNodes = function(t2) {
          for (var e3 = this._op.getGraph().getNodes().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (!n2.isInResult() && (!n2.isIncidentEdgeInResult() && (0 === n2.getEdges().getDegree() || t2 === Lr.INTERSECTION))) {
              var i2 = n2.getLabel();
              Lr.isResultOfOp(i2, t2) && this.filterCoveredNodeToPoint(n2);
            }
          }
        }, Hi.prototype.build = function(t2) {
          return this.extractNonCoveredResultNodes(t2), this._resultPointList;
        }, Hi.prototype.interfaces_ = function() {
          return [];
        }, Hi.prototype.getClass = function() {
          return Hi;
        };
        var Wi = function() {
          this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = true, this._preserveGeometryCollectionType = true, this._preserveCollections = false, this._preserveType = false;
        };
        Wi.prototype.transformPoint = function(t2, e3) {
          return this._factory.createPoint(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformPolygon = function(t2, e3) {
          var n2 = true, i2 = this.transformLinearRing(t2.getExteriorRing(), t2);
          null !== i2 && i2 instanceof ee && !i2.isEmpty() || (n2 = false);
          for (var r2 = new Nt(), o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = this.transformLinearRing(t2.getInteriorRingN(o2), t2);
            null === s2 || s2.isEmpty() || (s2 instanceof ee || (n2 = false), r2.add(s2));
          }
          if (n2)
            return this._factory.createPolygon(i2, r2.toArray([]));
          var a2 = new Nt();
          return null !== i2 && a2.add(i2), a2.addAll(r2), this._factory.buildGeometry(a2);
        }, Wi.prototype.createCoordinateSequence = function(t2) {
          return this._factory.getCoordinateSequenceFactory().create(t2);
        }, Wi.prototype.getInputGeometry = function() {
          return this._inputGeom;
        }, Wi.prototype.transformMultiLineString = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformLineString(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformCoordinates = function(t2, e3) {
          return this.copy(t2);
        }, Wi.prototype.transformLineString = function(t2, e3) {
          return this._factory.createLineString(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformMultiPoint = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPoint(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformMultiPolygon = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPolygon(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.copy = function(t2) {
          return t2.copy();
        }, Wi.prototype.transformGeometryCollection = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transform(t2.getGeometryN(i2));
            null !== r2 && (this._pruneEmptyGeometry && r2.isEmpty() || n2.add(r2));
          }
          return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(_e.toGeometryArray(n2)) : this._factory.buildGeometry(n2);
        }, Wi.prototype.transform = function(t2) {
          if (this._inputGeom = t2, this._factory = t2.getFactory(), t2 instanceof Qt)
            return this.transformPoint(t2, null);
          if (t2 instanceof te)
            return this.transformMultiPoint(t2, null);
          if (t2 instanceof ee)
            return this.transformLinearRing(t2, null);
          if (t2 instanceof Kt)
            return this.transformLineString(t2, null);
          if (t2 instanceof Xt)
            return this.transformMultiLineString(t2, null);
          if (t2 instanceof $t)
            return this.transformPolygon(t2, null);
          if (t2 instanceof ne)
            return this.transformMultiPolygon(t2, null);
          if (t2 instanceof zt)
            return this.transformGeometryCollection(t2, null);
          throw new m("Unknown Geometry subtype: " + t2.getClass().getName());
        }, Wi.prototype.transformLinearRing = function(t2, e3) {
          var n2 = this.transformCoordinates(t2.getCoordinateSequence(), t2);
          if (null === n2)
            return this._factory.createLinearRing(null);
          var i2 = n2.size();
          return i2 > 0 && i2 < 4 && !this._preserveType ? this._factory.createLineString(n2) : this._factory.createLinearRing(n2);
        }, Wi.prototype.interfaces_ = function() {
          return [];
        }, Wi.prototype.getClass = function() {
          return Wi;
        };
        var Ki = function t2() {
          if (this._snapTolerance = 0, this._srcPts = null, this._seg = new dn(), this._allowSnappingToSourceVertices = false, this._isClosed = false, arguments[0] instanceof Kt && "number" == typeof arguments[1]) {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3.getCoordinates(), n2);
          } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
            var i2 = arguments[0], r2 = arguments[1];
            this._srcPts = i2, this._isClosed = t2.isClosed(i2), this._snapTolerance = r2;
          }
        };
        Ki.prototype.snapVertices = function(t2, e3) {
          for (var n2 = this._isClosed ? t2.size() - 1 : t2.size(), i2 = 0; i2 < n2; i2++) {
            var r2 = t2.get(i2), o2 = this.findSnapForVertex(r2, e3);
            null !== o2 && (t2.set(i2, new C(o2)), 0 === i2 && this._isClosed && t2.set(t2.size() - 1, new C(o2)));
          }
        }, Ki.prototype.findSnapForVertex = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++) {
            if (t2.equals2D(e3[n2]))
              return null;
            if (t2.distance(e3[n2]) < this._snapTolerance)
              return e3[n2];
          }
          return null;
        }, Ki.prototype.snapTo = function(t2) {
          var e3 = new St(this._srcPts);
          this.snapVertices(e3, t2), this.snapSegments(e3, t2);
          return e3.toCoordinateArray();
        }, Ki.prototype.snapSegments = function(t2, e3) {
          if (0 === e3.length)
            return null;
          var n2 = e3.length;
          e3[0].equals2D(e3[e3.length - 1]) && (n2 = e3.length - 1);
          for (var i2 = 0; i2 < n2; i2++) {
            var r2 = e3[i2], o2 = this.findSegmentIndexToSnap(r2, t2);
            o2 >= 0 && t2.add(o2 + 1, new C(r2), false);
          }
        }, Ki.prototype.findSegmentIndexToSnap = function(t2, e3) {
          for (var n2 = v.MAX_VALUE, i2 = -1, r2 = 0; r2 < e3.size() - 1; r2++) {
            if (this._seg.p0 = e3.get(r2), this._seg.p1 = e3.get(r2 + 1), this._seg.p0.equals2D(t2) || this._seg.p1.equals2D(t2)) {
              if (this._allowSnappingToSourceVertices)
                continue;
              return -1;
            }
            var o2 = this._seg.distance(t2);
            o2 < this._snapTolerance && o2 < n2 && (n2 = o2, i2 = r2);
          }
          return i2;
        }, Ki.prototype.setAllowSnappingToSourceVertices = function(t2) {
          this._allowSnappingToSourceVertices = t2;
        }, Ki.prototype.interfaces_ = function() {
          return [];
        }, Ki.prototype.getClass = function() {
          return Ki;
        }, Ki.isClosed = function(t2) {
          return !(t2.length <= 1) && t2[0].equals2D(t2[t2.length - 1]);
        };
        var Ji = function(t2) {
          this._srcGeom = t2 || null;
        }, Qi = { SNAP_PRECISION_FACTOR: { configurable: true } };
        Ji.prototype.snapTo = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(t2);
          return new Zi(e3, n2).transform(this._srcGeom);
        }, Ji.prototype.snapToSelf = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(this._srcGeom), i2 = new Zi(t2, n2, true).transform(this._srcGeom), r2 = i2;
          return e3 && T(r2, Zt) && (r2 = i2.buffer(0)), r2;
        }, Ji.prototype.computeSnapTolerance = function(t2) {
          return this.computeMinimumSegmentLength(t2) / 10;
        }, Ji.prototype.extractTargetCoordinates = function(t2) {
          for (var e3 = new f(), n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; i2++)
            e3.add(n2[i2]);
          return e3.toArray(new Array(0).fill(null));
        }, Ji.prototype.computeMinimumSegmentLength = function(t2) {
          for (var e3 = v.MAX_VALUE, n2 = 0; n2 < t2.length - 1; n2++) {
            var i2 = t2[n2].distance(t2[n2 + 1]);
            i2 < e3 && (e3 = i2);
          }
          return e3;
        }, Ji.prototype.interfaces_ = function() {
          return [];
        }, Ji.prototype.getClass = function() {
          return Ji;
        }, Ji.snap = function(t2, e3, n2) {
          var i2 = new Array(2).fill(null), r2 = new Ji(t2);
          i2[0] = r2.snapTo(e3, n2);
          var o2 = new Ji(e3);
          return i2[1] = o2.snapTo(i2[0], n2), i2;
        }, Ji.computeOverlaySnapTolerance = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = Ji.computeSizeBasedSnapTolerance(t2), n2 = t2.getPrecisionModel();
            if (n2.getType() === fe.FIXED) {
              var i2 = 1 / n2.getScale() * 2 / 1.415;
              i2 > e3 && (e3 = i2);
            }
            return e3;
          }
          if (2 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            return Math.min(Ji.computeOverlaySnapTolerance(r2), Ji.computeOverlaySnapTolerance(o2));
          }
        }, Ji.computeSizeBasedSnapTolerance = function(t2) {
          var e3 = t2.getEnvelopeInternal();
          return Math.min(e3.getHeight(), e3.getWidth()) * Ji.SNAP_PRECISION_FACTOR;
        }, Ji.snapToSelf = function(t2, e3, n2) {
          return new Ji(t2).snapToSelf(e3, n2);
        }, Qi.SNAP_PRECISION_FACTOR.get = function() {
          return 1e-9;
        }, Object.defineProperties(Ji, Qi);
        var Zi = function(t2) {
          function e3(e4, n2, i2) {
            t2.call(this), this._snapTolerance = e4 || null, this._snapPts = n2 || null, this._isSelfSnap = void 0 !== i2 && i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.snapLine = function(t3, e4) {
            var n2 = new Ki(t3, this._snapTolerance);
            return n2.setAllowSnappingToSourceVertices(this._isSelfSnap), n2.snapTo(e4);
          }, e3.prototype.transformCoordinates = function(t3, e4) {
            var n2 = t3.toCoordinateArray(), i2 = this.snapLine(n2, this._snapPts);
            return this._factory.getCoordinateSequenceFactory().create(i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Wi), $i = function() {
          this._isFirst = true, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
        };
        $i.prototype.getCommon = function() {
          return v.longBitsToDouble(this._commonBits);
        }, $i.prototype.add = function(t2) {
          var e3 = v.doubleToLongBits(t2);
          if (this._isFirst)
            return this._commonBits = e3, this._commonSignExp = $i.signExpBits(this._commonBits), this._isFirst = false, null;
          if ($i.signExpBits(e3) !== this._commonSignExp)
            return this._commonBits = 0, null;
          this._commonMantissaBitsCount = $i.numCommonMostSigMantissaBits(this._commonBits, e3), this._commonBits = $i.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
        }, $i.prototype.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = v.longBitsToDouble(t2), n2 = "0000000000000000000000000000000000000000000000000000000000000000" + v.toBinaryString(t2), i2 = n2.substring(n2.length - 64);
            return i2.substring(0, 1) + "  " + i2.substring(1, 12) + "(exp) " + i2.substring(12) + " [ " + e3 + " ]";
          }
        }, $i.prototype.interfaces_ = function() {
          return [];
        }, $i.prototype.getClass = function() {
          return $i;
        }, $i.getBit = function(t2, e3) {
          return 0 != (t2 & 1 << e3) ? 1 : 0;
        }, $i.signExpBits = function(t2) {
          return t2 >> 52;
        }, $i.zeroLowerBits = function(t2, e3) {
          return t2 & ~((1 << e3) - 1);
        }, $i.numCommonMostSigMantissaBits = function(t2, e3) {
          for (var n2 = 0, i2 = 52; i2 >= 0; i2--) {
            if ($i.getBit(t2, i2) !== $i.getBit(e3, i2))
              return n2;
            n2++;
          }
          return 52;
        };
        var tr = function() {
          this._commonCoord = null, this._ccFilter = new nr();
        }, er = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
        tr.prototype.addCommonBits = function(t2) {
          var e3 = new ir(this._commonCoord);
          t2.apply(e3), t2.geometryChanged();
        }, tr.prototype.removeCommonBits = function(t2) {
          if (0 === this._commonCoord.x && 0 === this._commonCoord.y)
            return t2;
          var e3 = new C(this._commonCoord);
          e3.x = -e3.x, e3.y = -e3.y;
          var n2 = new ir(e3);
          return t2.apply(n2), t2.geometryChanged(), t2;
        }, tr.prototype.getCommonCoordinate = function() {
          return this._commonCoord;
        }, tr.prototype.add = function(t2) {
          t2.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
        }, tr.prototype.interfaces_ = function() {
          return [];
        }, tr.prototype.getClass = function() {
          return tr;
        }, er.CommonCoordinateFilter.get = function() {
          return nr;
        }, er.Translater.get = function() {
          return ir;
        }, Object.defineProperties(tr, er);
        var nr = function() {
          this._commonBitsX = new $i(), this._commonBitsY = new $i();
        };
        nr.prototype.filter = function(t2) {
          this._commonBitsX.add(t2.x), this._commonBitsY.add(t2.y);
        }, nr.prototype.getCommonCoordinate = function() {
          return new C(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
        }, nr.prototype.interfaces_ = function() {
          return [ft];
        }, nr.prototype.getClass = function() {
          return nr;
        };
        var ir = function() {
          this.trans = null;
          var t2 = arguments[0];
          this.trans = t2;
        };
        ir.prototype.filter = function(t2, e3) {
          var n2 = t2.getOrdinate(e3, 0) + this.trans.x, i2 = t2.getOrdinate(e3, 1) + this.trans.y;
          t2.setOrdinate(e3, 0, n2), t2.setOrdinate(e3, 1, i2);
        }, ir.prototype.isDone = function() {
          return false;
        }, ir.prototype.isGeometryChanged = function() {
          return true;
        }, ir.prototype.interfaces_ = function() {
          return [Ut];
        }, ir.prototype.getClass = function() {
          return ir;
        };
        var rr = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t2, this._geom[1] = e3, this.computeSnapTolerance();
        };
        rr.prototype.selfSnap = function(t2) {
          return new Ji(t2).snapTo(t2, this._snapTolerance);
        }, rr.prototype.removeCommonBits = function(t2) {
          this._cbr = new tr(), this._cbr.add(t2[0]), this._cbr.add(t2[1]);
          var e3 = new Array(2).fill(null);
          return e3[0] = this._cbr.removeCommonBits(t2[0].copy()), e3[1] = this._cbr.removeCommonBits(t2[1].copy()), e3;
        }, rr.prototype.prepareResult = function(t2) {
          return this._cbr.addCommonBits(t2), t2;
        }, rr.prototype.getResultGeometry = function(t2) {
          var e3 = this.snap(this._geom), n2 = Lr.overlayOp(e3[0], e3[1], t2);
          return this.prepareResult(n2);
        }, rr.prototype.checkValid = function(t2) {
          t2.isValid() || Y.out.println("Snapped geometry is invalid");
        }, rr.prototype.computeSnapTolerance = function() {
          this._snapTolerance = Ji.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
        }, rr.prototype.snap = function(t2) {
          var e3 = this.removeCommonBits(t2);
          return Ji.snap(e3[0], e3[1], this._snapTolerance);
        }, rr.prototype.interfaces_ = function() {
          return [];
        }, rr.prototype.getClass = function() {
          return rr;
        }, rr.overlayOp = function(t2, e3, n2) {
          return new rr(t2, e3).getResultGeometry(n2);
        }, rr.union = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.UNION);
        }, rr.intersection = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.INTERSECTION);
        }, rr.symDifference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, rr.difference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var or = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._geom[0] = t2, this._geom[1] = e3;
        };
        or.prototype.getResultGeometry = function(t2) {
          var e3 = null, n2 = false, i2 = null;
          try {
            e3 = Lr.overlayOp(this._geom[0], this._geom[1], t2);
            n2 = true;
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            i2 = t3;
          }
          if (!n2)
            try {
              e3 = rr.overlayOp(this._geom[0], this._geom[1], t2);
            } catch (t3) {
              throw t3 instanceof $ ? i2 : t3;
            }
          return e3;
        }, or.prototype.interfaces_ = function() {
          return [];
        }, or.prototype.getClass = function() {
          return or;
        }, or.overlayOp = function(t2, e3, n2) {
          return new or(t2, e3).getResultGeometry(n2);
        }, or.union = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.UNION);
        }, or.intersection = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, or.symDifference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, or.difference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var sr = function() {
          this.mce = null, this.chainIndex = null;
          var t2 = arguments[0], e3 = arguments[1];
          this.mce = t2, this.chainIndex = e3;
        };
        sr.prototype.computeIntersections = function(t2, e3) {
          this.mce.computeIntersectsForChain(this.chainIndex, t2.mce, t2.chainIndex, e3);
        }, sr.prototype.interfaces_ = function() {
          return [];
        }, sr.prototype.getClass = function() {
          return sr;
        };
        var ar = function t2() {
          if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._eventType = t2.DELETE, this._xValue = e3, this._insertEvent = n2;
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._eventType = t2.INSERT, this._label = i2, this._xValue = r2, this._obj = o2;
          }
        }, ur = { INSERT: { configurable: true }, DELETE: { configurable: true } };
        ar.prototype.isDelete = function() {
          return this._eventType === ar.DELETE;
        }, ar.prototype.setDeleteEventIndex = function(t2) {
          this._deleteEventIndex = t2;
        }, ar.prototype.getObject = function() {
          return this._obj;
        }, ar.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._xValue < e3._xValue ? -1 : this._xValue > e3._xValue ? 1 : this._eventType < e3._eventType ? -1 : this._eventType > e3._eventType ? 1 : 0;
        }, ar.prototype.getInsertEvent = function() {
          return this._insertEvent;
        }, ar.prototype.isInsert = function() {
          return this._eventType === ar.INSERT;
        }, ar.prototype.isSameLabel = function(t2) {
          return null !== this._label && this._label === t2._label;
        }, ar.prototype.getDeleteEventIndex = function() {
          return this._deleteEventIndex;
        }, ar.prototype.interfaces_ = function() {
          return [E];
        }, ar.prototype.getClass = function() {
          return ar;
        }, ur.INSERT.get = function() {
          return 1;
        }, ur.DELETE.get = function() {
          return 2;
        }, Object.defineProperties(ar, ur);
        var lr = function() {
        };
        lr.prototype.interfaces_ = function() {
          return [];
        }, lr.prototype.getClass = function() {
          return lr;
        };
        var cr = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = false, this._isDoneWhenProperInt = false;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._li = t2, this._includeProper = e3, this._recordIsolated = n2;
        };
        cr.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
            if (cr.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.getNumPoints() - 1;
              if (0 === e3 && i2 === r2 || 0 === i2 && e3 === r2)
                return true;
            }
          }
          return false;
        }, cr.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, cr.prototype.setIsDoneIfProperInt = function(t2) {
          this._isDoneWhenProperInt = t2;
        }, cr.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, cr.prototype.isBoundaryPointInternal = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getCoordinate();
            if (t2.isIntersection(i2))
              return true;
          }
          return false;
        }, cr.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, cr.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, cr.prototype.isDone = function() {
          return this._isDone;
        }, cr.prototype.isBoundaryPoint = function(t2, e3) {
          return null !== e3 && (!!this.isBoundaryPointInternal(t2, e3[0]) || !!this.isBoundaryPointInternal(t2, e3[1]));
        }, cr.prototype.setBoundaryNodes = function(t2, e3) {
          this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t2, this._bdyNodes[1] = e3;
        }, cr.prototype.addIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this._recordIsolated && (t2.setIsolated(false), n2.setIsolated(false)), this._numIntersections++, this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, !this._includeProper && this._li.isProper() || (t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = true, this._isDoneWhenProperInt && (this._isDone = true), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = true))));
        }, cr.prototype.interfaces_ = function() {
          return [];
        }, cr.prototype.getClass = function() {
          return cr;
        }, cr.isAdjacentSegments = function(t2, e3) {
          return 1 === Math.abs(t2 - e3);
        };
        var pr = function(t2) {
          function e3() {
            t2.call(this), this.events = new Nt(), this.nOverlaps = null;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.prepareEvents = function() {
            $e.sort(this.events);
            for (var t3 = 0; t3 < this.events.size(); t3++) {
              var e4 = this.events.get(t3);
              e4.isDelete() && e4.getInsertEvent().setDeleteEventIndex(t3);
            }
          }, e3.prototype.computeIntersections = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0];
              this.nOverlaps = 0, this.prepareEvents();
              for (var e4 = 0; e4 < this.events.size(); e4++) {
                var n2 = this.events.get(e4);
                if (n2.isInsert() && this.processOverlaps(e4, n2.getDeleteEventIndex(), n2, t3), t3.isDone())
                  break;
              }
            } else if (3 === arguments.length) {
              if (arguments[2] instanceof cr && T(arguments[0], xt) && T(arguments[1], xt)) {
                var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
                this.addEdges(i2, i2), this.addEdges(r2, r2), this.computeIntersections(o2);
              } else if ("boolean" == typeof arguments[2] && T(arguments[0], xt) && arguments[1] instanceof cr) {
                var s2 = arguments[0], a2 = arguments[1];
                arguments[2] ? this.addEdges(s2, null) : this.addEdges(s2), this.computeIntersections(a2);
              }
            }
          }, e3.prototype.addEdge = function(t3, e4) {
            for (var n2 = t3.getMonotoneChainEdge(), i2 = n2.getStartIndexes(), r2 = 0; r2 < i2.length - 1; r2++) {
              var o2 = new sr(n2, r2), s2 = new ar(e4, n2.getMinX(r2), o2);
              this.events.add(s2), this.events.add(new ar(n2.getMaxX(r2), s2));
            }
          }, e3.prototype.processOverlaps = function(t3, e4, n2, i2) {
            for (var r2 = n2.getObject(), o2 = t3; o2 < e4; o2++) {
              var s2 = this.events.get(o2);
              if (s2.isInsert()) {
                var a2 = s2.getObject();
                n2.isSameLabel(s2) || (r2.computeIntersections(a2, i2), this.nOverlaps++);
              }
            }
          }, e3.prototype.addEdges = function() {
            if (1 === arguments.length)
              for (var t3 = arguments[0].iterator(); t3.hasNext(); ) {
                var e4 = t3.next();
                this.addEdge(e4, e4);
              }
            else if (2 === arguments.length)
              for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addEdge(o2, i2);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(lr), hr = function() {
          this._min = v.POSITIVE_INFINITY, this._max = v.NEGATIVE_INFINITY;
        }, fr = { NodeComparator: { configurable: true } };
        hr.prototype.getMin = function() {
          return this._min;
        }, hr.prototype.intersects = function(t2, e3) {
          return !(this._min > e3 || this._max < t2);
        }, hr.prototype.getMax = function() {
          return this._max;
        }, hr.prototype.toString = function() {
          return Z.toLineString(new C(this._min, 0), new C(this._max, 0));
        }, hr.prototype.interfaces_ = function() {
          return [];
        }, hr.prototype.getClass = function() {
          return hr;
        }, fr.NodeComparator.get = function() {
          return gr;
        }, Object.defineProperties(hr, fr);
        var gr = function() {
        };
        gr.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = (n2._min + n2._max) / 2, o2 = (i2._min + i2._max) / 2;
          return r2 < o2 ? -1 : r2 > o2 ? 1 : 0;
        }, gr.prototype.interfaces_ = function() {
          return [N];
        }, gr.prototype.getClass = function() {
          return gr;
        };
        var dr = function(t2) {
          function e3() {
            t2.call(this), this._item = null;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._min = e4, this._max = n2, this._item = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            n2.visitItem(this._item);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), yr = function(t2) {
          function e3() {
            t2.call(this), this._node1 = null, this._node2 = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._node1 = e4, this._node2 = n2, this.buildExtent(this._node1, this._node2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildExtent = function(t3, e4) {
            this._min = Math.min(t3._min, e4._min), this._max = Math.max(t3._max, e4._max);
          }, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            null !== this._node1 && this._node1.query(t3, e4, n2), null !== this._node2 && this._node2.query(t3, e4, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), _r = function() {
          this._leaves = new Nt(), this._root = null, this._level = 0;
        };
        _r.prototype.buildTree = function() {
          $e.sort(this._leaves, new hr.NodeComparator());
          for (var t2 = this._leaves, e3 = null, n2 = new Nt(); ; ) {
            if (this.buildLevel(t2, n2), 1 === n2.size())
              return n2.get(0);
            e3 = t2, t2 = n2, n2 = e3;
          }
        }, _r.prototype.insert = function(t2, e3, n2) {
          if (null !== this._root)
            throw new Error("Index cannot be added to once it has been queried");
          this._leaves.add(new dr(t2, e3, n2));
        }, _r.prototype.query = function(t2, e3, n2) {
          this.init(), this._root.query(t2, e3, n2);
        }, _r.prototype.buildRoot = function() {
          if (null !== this._root)
            return null;
          this._root = this.buildTree();
        }, _r.prototype.printNode = function(t2) {
          Y.out.println(Z.toLineString(new C(t2._min, this._level), new C(t2._max, this._level)));
        }, _r.prototype.init = function() {
          if (null !== this._root)
            return null;
          this.buildRoot();
        }, _r.prototype.buildLevel = function(t2, e3) {
          this._level++, e3.clear();
          for (var n2 = 0; n2 < t2.size(); n2 += 2) {
            var i2 = t2.get(n2);
            if (null === (n2 + 1 < t2.size() ? t2.get(n2) : null))
              e3.add(i2);
            else {
              var r2 = new yr(t2.get(n2), t2.get(n2 + 1));
              e3.add(r2);
            }
          }
        }, _r.prototype.interfaces_ = function() {
          return [];
        }, _r.prototype.getClass = function() {
          return _r;
        };
        var mr = function() {
          this._items = new Nt();
        };
        mr.prototype.visitItem = function(t2) {
          this._items.add(t2);
        }, mr.prototype.getItems = function() {
          return this._items;
        }, mr.prototype.interfaces_ = function() {
          return [Ke];
        }, mr.prototype.getClass = function() {
          return mr;
        };
        var vr = function() {
          this._index = null;
          var t2 = arguments[0];
          if (!T(t2, Zt))
            throw new m("Argument must be Polygonal");
          this._index = new xr(t2);
        }, Ir = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
        vr.prototype.locate = function(t2) {
          var e3 = new st(t2), n2 = new Er(e3);
          return this._index.query(t2.y, t2.y, n2), e3.getLocation();
        }, vr.prototype.interfaces_ = function() {
          return [Vn];
        }, vr.prototype.getClass = function() {
          return vr;
        }, Ir.SegmentVisitor.get = function() {
          return Er;
        }, Ir.IntervalIndexedGeometry.get = function() {
          return xr;
        }, Object.defineProperties(vr, Ir);
        var Er = function() {
          this._counter = null;
          var t2 = arguments[0];
          this._counter = t2;
        };
        Er.prototype.visitItem = function(t2) {
          var e3 = t2;
          this._counter.countSegment(e3.getCoordinate(0), e3.getCoordinate(1));
        }, Er.prototype.interfaces_ = function() {
          return [Ke];
        }, Er.prototype.getClass = function() {
          return Er;
        };
        var xr = function() {
          this._index = new _r();
          var t2 = arguments[0];
          this.init(t2);
        };
        xr.prototype.init = function(t2) {
          for (var e3 = Ci.getLines(t2).iterator(); e3.hasNext(); ) {
            var n2 = e3.next().getCoordinates();
            this.addLine(n2);
          }
        }, xr.prototype.addLine = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++) {
            var n2 = new dn(t2[e3 - 1], t2[e3]), i2 = Math.min(n2.p0.y, n2.p1.y), r2 = Math.max(n2.p0.y, n2.p1.y);
            this._index.insert(i2, r2, n2);
          }
        }, xr.prototype.query = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new mr();
            return this._index.query(t2, e3, n2), n2.getItems();
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._index.query(i2, r2, o2);
          }
        }, xr.prototype.interfaces_ = function() {
          return [];
        }, xr.prototype.getClass = function() {
          return xr;
        };
        var Nr = function(t2) {
          function e3() {
            if (t2.call(this), this._parentGeom = null, this._lineEdgeMap = new he(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = true, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = false, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Si(), 2 === arguments.length) {
              var e4 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
              this._argIndex = e4, this._parentGeom = n2, this._boundaryNodeRule = i2, null !== n2 && this.add(n2);
            } else if (3 === arguments.length) {
              var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
              this._argIndex = r2, this._parentGeom = o2, this._boundaryNodeRule = s2, null !== o2 && this.add(o2);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertBoundaryPoint = function(t3, n2) {
            var i2 = this._nodes.addNode(n2).getLabel(), r2 = 1;
            w.NONE;
            i2.getLocation(t3, Se.ON) === w.BOUNDARY && r2++;
            var o2 = e3.determineBoundary(this._boundaryNodeRule, r2);
            i2.setLocation(t3, o2);
          }, e3.prototype.computeSelfNodes = function() {
            if (2 === arguments.length) {
              var t3 = arguments[0], e4 = arguments[1];
              return this.computeSelfNodes(t3, e4, false);
            }
            if (3 === arguments.length) {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new cr(n2, true, false);
              o2.setIsDoneIfProperInt(r2);
              var s2 = this.createEdgeSetIntersector(), a2 = this._parentGeom instanceof ee || this._parentGeom instanceof $t || this._parentGeom instanceof ne, u2 = i2 || !a2;
              return s2.computeIntersections(this._edges, o2, u2), this.addSelfIntersectionNodes(this._argIndex), o2;
            }
          }, e3.prototype.computeSplitEdges = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); ) {
              e4.next().eiList.addSplitEdges(t3);
            }
          }, e3.prototype.computeEdgeIntersections = function(t3, e4, n2) {
            var i2 = new cr(e4, n2, true);
            i2.setBoundaryNodes(this.getBoundaryNodes(), t3.getBoundaryNodes());
            return this.createEdgeSetIntersector().computeIntersections(this._edges, t3._edges, i2), i2;
          }, e3.prototype.getGeometry = function() {
            return this._parentGeom;
          }, e3.prototype.getBoundaryNodeRule = function() {
            return this._boundaryNodeRule;
          }, e3.prototype.hasTooFewPoints = function() {
            return this._hasTooFewPoints;
          }, e3.prototype.addPoint = function() {
            if (arguments[0] instanceof Qt) {
              var t3 = arguments[0].getCoordinate();
              this.insertPoint(this._argIndex, t3, w.INTERIOR);
            } else if (arguments[0] instanceof C) {
              var e4 = arguments[0];
              this.insertPoint(this._argIndex, e4, w.INTERIOR);
            }
          }, e3.prototype.addPolygon = function(t3) {
            this.addPolygonRing(t3.getExteriorRing(), w.EXTERIOR, w.INTERIOR);
            for (var e4 = 0; e4 < t3.getNumInteriorRing(); e4++) {
              var n2 = t3.getInteriorRingN(e4);
              this.addPolygonRing(n2, w.INTERIOR, w.EXTERIOR);
            }
          }, e3.prototype.addEdge = function(t3) {
            this.insertEdge(t3);
            var e4 = t3.getCoordinates();
            this.insertPoint(this._argIndex, e4[0], w.BOUNDARY), this.insertPoint(this._argIndex, e4[e4.length - 1], w.BOUNDARY);
          }, e3.prototype.addLineString = function(t3) {
            var e4 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (e4.length < 2)
              return this._hasTooFewPoints = true, this._invalidPoint = e4[0], null;
            var n2 = new ni(e4, new Pe(this._argIndex, w.INTERIOR));
            this._lineEdgeMap.put(t3, n2), this.insertEdge(n2), et.isTrue(e4.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e4[0]), this.insertBoundaryPoint(this._argIndex, e4[e4.length - 1]);
          }, e3.prototype.getInvalidPoint = function() {
            return this._invalidPoint;
          }, e3.prototype.getBoundaryPoints = function() {
            for (var t3 = this.getBoundaryNodes(), e4 = new Array(t3.size()).fill(null), n2 = 0, i2 = t3.iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              e4[n2++] = r2.getCoordinate().copy();
            }
            return e4;
          }, e3.prototype.getBoundaryNodes = function() {
            return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
          }, e3.prototype.addSelfIntersectionNode = function(t3, e4, n2) {
            if (this.isBoundaryNode(t3, e4))
              return null;
            n2 === w.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t3, e4) : this.insertPoint(t3, e4, n2);
          }, e3.prototype.addPolygonRing = function(t3, e4, n2) {
            if (t3.isEmpty())
              return null;
            var i2 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (i2.length < 4)
              return this._hasTooFewPoints = true, this._invalidPoint = i2[0], null;
            var r2 = e4, o2 = n2;
            at.isCCW(i2) && (r2 = n2, o2 = e4);
            var s2 = new ni(i2, new Pe(this._argIndex, w.BOUNDARY, r2, o2));
            this._lineEdgeMap.put(t3, s2), this.insertEdge(s2), this.insertPoint(this._argIndex, i2[0], w.BOUNDARY);
          }, e3.prototype.insertPoint = function(t3, e4, n2) {
            var i2 = this._nodes.addNode(e4), r2 = i2.getLabel();
            null === r2 ? i2._label = new Pe(t3, n2) : r2.setLocation(t3, n2);
          }, e3.prototype.createEdgeSetIntersector = function() {
            return new pr();
          }, e3.prototype.addSelfIntersectionNodes = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); )
              for (var n2 = e4.next(), i2 = n2.getLabel().getLocation(t3), r2 = n2.eiList.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addSelfIntersectionNode(t3, o2.coord, i2);
              }
          }, e3.prototype.add = function() {
            if (1 !== arguments.length)
              return t2.prototype.add.apply(this, arguments);
            var e4 = arguments[0];
            if (e4.isEmpty())
              return null;
            if (e4 instanceof ne && (this._useBoundaryDeterminationRule = false), e4 instanceof $t)
              this.addPolygon(e4);
            else if (e4 instanceof Kt)
              this.addLineString(e4);
            else if (e4 instanceof Qt)
              this.addPoint(e4);
            else if (e4 instanceof te)
              this.addCollection(e4);
            else if (e4 instanceof Xt)
              this.addCollection(e4);
            else if (e4 instanceof ne)
              this.addCollection(e4);
            else {
              if (!(e4 instanceof zt))
                throw new Error(e4.getClass().getName());
              this.addCollection(e4);
            }
          }, e3.prototype.addCollection = function(t3) {
            for (var e4 = 0; e4 < t3.getNumGeometries(); e4++) {
              var n2 = t3.getGeometryN(e4);
              this.add(n2);
            }
          }, e3.prototype.locate = function(t3) {
            return T(this._parentGeom, Zt) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new vr(this._parentGeom)), this._areaPtLocator.locate(t3)) : this._ptLocator.locate(t3, this._parentGeom);
          }, e3.prototype.findEdge = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              return this._lineEdgeMap.get(e4);
            }
            return t2.prototype.findEdge.apply(this, arguments);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.determineBoundary = function(t3, e4) {
            return t3.isInBoundary(e4) ? w.BOUNDARY : w.INTERIOR;
          }, e3;
        }(Ye), Cr = function() {
          if (this._li = new rt(), this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this.setComputationPrecision(t2.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Nr(0, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
            e3.getPrecisionModel().compareTo(n2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e3.getPrecisionModel()) : this.setComputationPrecision(n2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, e3, i2), this._arg[1] = new Nr(1, n2, i2);
          } else if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            r2.getPrecisionModel().compareTo(o2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(r2.getPrecisionModel()) : this.setComputationPrecision(o2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, r2, s2), this._arg[1] = new Nr(1, o2, s2);
          }
        };
        Cr.prototype.getArgGeometry = function(t2) {
          return this._arg[t2].getGeometry();
        }, Cr.prototype.setComputationPrecision = function(t2) {
          this._resultPrecisionModel = t2, this._li.setPrecisionModel(this._resultPrecisionModel);
        }, Cr.prototype.interfaces_ = function() {
          return [];
        }, Cr.prototype.getClass = function() {
          return Cr;
        };
        var Sr = function() {
        };
        Sr.prototype.interfaces_ = function() {
          return [];
        }, Sr.prototype.getClass = function() {
          return Sr;
        }, Sr.map = function() {
          if (arguments[0] instanceof ct && T(arguments[1], Sr.MapOp)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
              var r2 = e3.map(t2.getGeometryN(i2));
              null !== r2 && n2.add(r2);
            }
            return t2.getFactory().buildGeometry(n2);
          }
          if (T(arguments[0], It) && T(arguments[1], Sr.MapOp)) {
            for (var o2 = arguments[0], s2 = arguments[1], a2 = new Nt(), u2 = o2.iterator(); u2.hasNext(); ) {
              var l2 = u2.next(), c2 = s2.map(l2);
              null !== c2 && a2.add(c2);
            }
            return a2;
          }
        }, Sr.MapOp = function() {
        };
        var Lr = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2), this._ptLocator = new Si(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Hn(), this._resultPolyList = new Nt(), this._resultLineList = new Nt(), this._resultPointList = new Nt(), this._graph = new Ye(new kn()), this._geomFact = e4.getFactory();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertUniqueEdge = function(t3) {
            var e4 = this._edgeList.findEqualEdge(t3);
            if (null !== e4) {
              var n2 = e4.getLabel(), i2 = t3.getLabel();
              e4.isPointwiseEqual(t3) || (i2 = new Pe(t3.getLabel())).flip();
              var r2 = e4.getDepth();
              r2.isNull() && r2.add(n2), r2.add(i2), n2.merge(i2);
            } else
              this._edgeList.add(t3);
          }, e3.prototype.getGraph = function() {
            return this._graph;
          }, e3.prototype.cancelDuplicateResultEdges = function() {
            for (var t3 = this._graph.getEdgeEnds().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getSym();
              e4.isInResult() && n2.isInResult() && (e4.setInResult(false), n2.setInResult(false));
            }
          }, e3.prototype.isCoveredByLA = function(t3) {
            return !!this.isCovered(t3, this._resultLineList) || !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.computeGeometry = function(t3, n2, i2, r2) {
            var o2 = new Nt();
            return o2.addAll(t3), o2.addAll(n2), o2.addAll(i2), o2.isEmpty() ? e3.createEmptyResult(r2, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o2);
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().mergeSymLabels();
            }
          }, e3.prototype.isCovered = function(t3, e4) {
            for (var n2 = e4.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              if (this._ptLocator.locate(t3, i2) !== w.EXTERIOR)
                return true;
            }
            return false;
          }, e3.prototype.replaceCollapsedEdges = function() {
            for (var t3 = new Nt(), e4 = this._edgeList.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              n2.isCollapsed() && (e4.remove(), t3.add(n2.getCollapsedEdge()));
            }
            this._edgeList.addAll(t3);
          }, e3.prototype.updateNodeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getEdges().getLabel();
              e4.getLabel().merge(n2);
            }
          }, e3.prototype.getResultGeometry = function(t3) {
            return this.computeOverlay(t3), this._resultGeom;
          }, e3.prototype.insertUniqueEdges = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this.insertUniqueEdge(n2);
            }
          }, e3.prototype.computeOverlay = function(t3) {
            this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, false), this._arg[1].computeSelfNodes(this._li, false), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
            var e4 = new Nt();
            this._arg[0].computeSplitEdges(e4), this._arg[1].computeSplitEdges(e4), this.insertUniqueEdges(e4), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Yi.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t3), this.cancelDuplicateResultEdges();
            var n2 = new ke(this._geomFact);
            n2.add(this._graph), this._resultPolyList = n2.getPolygons();
            var i2 = new ji(this, this._geomFact, this._ptLocator);
            this._resultLineList = i2.build(t3);
            var r2 = new Hi(this, this._geomFact, this._ptLocator);
            this._resultPointList = r2.build(t3), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t3);
          }, e3.prototype.labelIncompleteNode = function(t3, e4) {
            var n2 = this._ptLocator.locate(t3.getCoordinate(), this._arg[e4].getGeometry());
            t3.getLabel().setLocation(e4, n2);
          }, e3.prototype.copyPoints = function(t3) {
            for (var e4 = this._arg[t3].getNodeIterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this._graph.addNode(n2.getCoordinate()).setLabel(t3, n2.getLabel().getLocation(t3));
            }
          }, e3.prototype.findResultAreaEdges = function(t3) {
            for (var n2 = this._graph.getEdgeEnds().iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getLabel();
              r2.isArea() && !i2.isInteriorAreaEdge() && e3.isResultOfOp(r2.getLocation(0, Se.RIGHT), r2.getLocation(1, Se.RIGHT), t3) && i2.setInResult(true);
            }
          }, e3.prototype.computeLabelsFromDepths = function() {
            for (var t3 = this._edgeList.iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel(), i2 = e4.getDepth();
              if (!i2.isNull()) {
                i2.normalize();
                for (var r2 = 0; r2 < 2; r2++)
                  n2.isNull(r2) || !n2.isArea() || i2.isNull(r2) || (0 === i2.getDelta(r2) ? n2.toLine(r2) : (et.isTrue(!i2.isNull(r2, Se.LEFT), "depth of LEFT side has not been initialized"), n2.setLocation(r2, Se.LEFT, i2.getLocation(r2, Se.LEFT)), et.isTrue(!i2.isNull(r2, Se.RIGHT), "depth of RIGHT side has not been initialized"), n2.setLocation(r2, Se.RIGHT, i2.getLocation(r2, Se.RIGHT))));
              }
            }
          }, e3.prototype.computeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().computeLabelling(this._arg);
            }
            this.mergeSymLabels(), this.updateNodeLabelling();
          }, e3.prototype.labelIncompleteNodes = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel();
              e4.isIsolated() && (n2.isNull(0) ? this.labelIncompleteNode(e4, 0) : this.labelIncompleteNode(e4, 1)), e4.getEdges().updateLabelling(n2);
            }
          }, e3.prototype.isCoveredByA = function(t3) {
            return !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Cr);
        Lr.overlayOp = function(t2, e3, n2) {
          return new Lr(t2, e3).getResultGeometry(n2);
        }, Lr.intersection = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty())
            return Lr.createEmptyResult(Lr.INTERSECTION, t2, e3, t2.getFactory());
          if (t2.isGeometryCollection()) {
            var n2 = e3;
            return ki.map(t2, { interfaces_: function() {
              return [Sr.MapOp];
            }, map: function(t3) {
              return t3.intersection(n2);
            } });
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, Lr.symDifference = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.SYMDIFFERENCE, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, Lr.resultDimension = function(t2, e3, n2) {
          var i2 = e3.getDimension(), r2 = n2.getDimension(), o2 = -1;
          switch (t2) {
            case Lr.INTERSECTION:
              o2 = Math.min(i2, r2);
              break;
            case Lr.UNION:
              o2 = Math.max(i2, r2);
              break;
            case Lr.DIFFERENCE:
              o2 = i2;
              break;
            case Lr.SYMDIFFERENCE:
              o2 = Math.max(i2, r2);
          }
          return o2;
        }, Lr.createEmptyResult = function(t2, e3, n2, i2) {
          var r2 = null;
          switch (Lr.resultDimension(t2, e3, n2)) {
            case -1:
              r2 = i2.createGeometryCollection(new Array(0).fill(null));
              break;
            case 0:
              r2 = i2.createPoint();
              break;
            case 1:
              r2 = i2.createLineString();
              break;
            case 2:
              r2 = i2.createPolygon();
          }
          return r2;
        }, Lr.difference = function(t2, e3) {
          return t2.isEmpty() ? Lr.createEmptyResult(Lr.DIFFERENCE, t2, e3, t2.getFactory()) : e3.isEmpty() ? t2.copy() : (t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.DIFFERENCE));
        }, Lr.isResultOfOp = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = t2.getLocation(0), i2 = t2.getLocation(1);
            return Lr.isResultOfOp(n2, i2, e3);
          }
          if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            switch (r2 === w.BOUNDARY && (r2 = w.INTERIOR), o2 === w.BOUNDARY && (o2 = w.INTERIOR), s2) {
              case Lr.INTERSECTION:
                return r2 === w.INTERIOR && o2 === w.INTERIOR;
              case Lr.UNION:
                return r2 === w.INTERIOR || o2 === w.INTERIOR;
              case Lr.DIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR;
              case Lr.SYMDIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR || r2 !== w.INTERIOR && o2 === w.INTERIOR;
            }
            return false;
          }
        }, Lr.INTERSECTION = 1, Lr.UNION = 2, Lr.DIFFERENCE = 3, Lr.SYMDIFFERENCE = 4;
        var br = function() {
          this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Si(), this._seg = new dn();
          var t2 = arguments[0], e3 = arguments[1];
          this._g = t2, this._boundaryDistanceTolerance = e3, this._linework = this.extractLinework(t2);
        };
        br.prototype.isWithinToleranceOfBoundary = function(t2) {
          for (var e3 = 0; e3 < this._linework.getNumGeometries(); e3++)
            for (var n2 = this._linework.getGeometryN(e3).getCoordinateSequence(), i2 = 0; i2 < n2.size() - 1; i2++) {
              n2.getCoordinate(i2, this._seg.p0), n2.getCoordinate(i2 + 1, this._seg.p1);
              if (this._seg.distance(t2) <= this._boundaryDistanceTolerance)
                return true;
            }
          return false;
        }, br.prototype.getLocation = function(t2) {
          return this.isWithinToleranceOfBoundary(t2) ? w.BOUNDARY : this._ptLocator.locate(t2, this._g);
        }, br.prototype.extractLinework = function(t2) {
          var e3 = new wr();
          t2.apply(e3);
          var n2 = e3.getLinework(), i2 = _e.toLineStringArray(n2);
          return t2.getFactory().createMultiLineString(i2);
        }, br.prototype.interfaces_ = function() {
          return [];
        }, br.prototype.getClass = function() {
          return br;
        };
        var wr = function() {
          this._linework = null, this._linework = new Nt();
        };
        wr.prototype.getLinework = function() {
          return this._linework;
        }, wr.prototype.filter = function(t2) {
          if (t2 instanceof $t) {
            var e3 = t2;
            this._linework.add(e3.getExteriorRing());
            for (var n2 = 0; n2 < e3.getNumInteriorRing(); n2++)
              this._linework.add(e3.getInteriorRingN(n2));
          }
        }, wr.prototype.interfaces_ = function() {
          return [Vt];
        }, wr.prototype.getClass = function() {
          return wr;
        };
        var Or = function() {
          this._g = null, this._doLeft = true, this._doRight = true;
          var t2 = arguments[0];
          this._g = t2;
        };
        Or.prototype.extractPoints = function(t2, e3, n2) {
          for (var i2 = t2.getCoordinates(), r2 = 0; r2 < i2.length - 1; r2++)
            this.computeOffsetPoints(i2[r2], i2[r2 + 1], e3, n2);
        }, Or.prototype.setSidesToGenerate = function(t2, e3) {
          this._doLeft = t2, this._doRight = e3;
        }, Or.prototype.getPoints = function(t2) {
          for (var e3 = new Nt(), n2 = Ci.getLines(this._g).iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this.extractPoints(i2, t2, e3);
          }
          return e3;
        }, Or.prototype.computeOffsetPoints = function(t2, e3, n2, i2) {
          var r2 = e3.x - t2.x, o2 = e3.y - t2.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = n2 * r2 / s2, u2 = n2 * o2 / s2, l2 = (e3.x + t2.x) / 2, c2 = (e3.y + t2.y) / 2;
          if (this._doLeft) {
            var p2 = new C(l2 - u2, c2 + a2);
            i2.add(p2);
          }
          if (this._doRight) {
            var h2 = new C(l2 + u2, c2 - a2);
            i2.add(h2);
          }
        }, Or.prototype.interfaces_ = function() {
          return [];
        }, Or.prototype.getClass = function() {
          return Or;
        };
        var Tr = function t2() {
          this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t2.TOLERANCE, this._testCoords = new Nt();
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._boundaryDistanceTolerance = t2.computeBoundaryDistanceTolerance(e3, n2), this._geom = [e3, n2, i2], this._locFinder = [new br(this._geom[0], this._boundaryDistanceTolerance), new br(this._geom[1], this._boundaryDistanceTolerance), new br(this._geom[2], this._boundaryDistanceTolerance)];
        }, Rr = { TOLERANCE: { configurable: true } };
        Tr.prototype.reportResult = function(t2, e3, n2) {
          Y.out.println("Overlay result invalid - A:" + w.toLocationSymbol(e3[0]) + " B:" + w.toLocationSymbol(e3[1]) + " expected:" + (n2 ? "i" : "e") + " actual:" + w.toLocationSymbol(e3[2]));
        }, Tr.prototype.isValid = function(t2) {
          this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
          var e3 = this.checkValid(t2);
          return e3;
        }, Tr.prototype.checkValid = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._testCoords.size(); e3++) {
              var n2 = this._testCoords.get(e3);
              if (!this.checkValid(t2, n2))
                return this._invalidLocation = n2, false;
            }
            return true;
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._location[0] = this._locFinder[0].getLocation(r2), this._location[1] = this._locFinder[1].getLocation(r2), this._location[2] = this._locFinder[2].getLocation(r2), !!Tr.hasLocation(this._location, w.BOUNDARY) || this.isValidResult(i2, this._location);
          }
        }, Tr.prototype.addTestPts = function(t2) {
          var e3 = new Or(t2);
          this._testCoords.addAll(e3.getPoints(5 * this._boundaryDistanceTolerance));
        }, Tr.prototype.isValidResult = function(t2, e3) {
          var n2 = Lr.isResultOfOp(e3[0], e3[1], t2), i2 = !(n2 ^ e3[2] === w.INTERIOR);
          return i2 || this.reportResult(t2, e3, n2), i2;
        }, Tr.prototype.getInvalidLocation = function() {
          return this._invalidLocation;
        }, Tr.prototype.interfaces_ = function() {
          return [];
        }, Tr.prototype.getClass = function() {
          return Tr;
        }, Tr.hasLocation = function(t2, e3) {
          for (var n2 = 0; n2 < 3; n2++)
            if (t2[n2] === e3)
              return true;
          return false;
        }, Tr.computeBoundaryDistanceTolerance = function(t2, e3) {
          return Math.min(Ji.computeSizeBasedSnapTolerance(t2), Ji.computeSizeBasedSnapTolerance(e3));
        }, Tr.isValid = function(t2, e3, n2, i2) {
          return new Tr(t2, e3, i2).isValid(n2);
        }, Rr.TOLERANCE.get = function() {
          return 1e-6;
        }, Object.defineProperties(Tr, Rr);
        var Pr = function t2(e3) {
          this._geomFactory = null, this._skipEmpty = false, this._inputGeoms = null, this._geomFactory = t2.extractFactory(e3), this._inputGeoms = e3;
        };
        Pr.prototype.extractElements = function(t2, e3) {
          if (null === t2)
            return null;
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            this._skipEmpty && i2.isEmpty() || e3.add(i2);
          }
        }, Pr.prototype.combine = function() {
          for (var t2 = new Nt(), e3 = this._inputGeoms.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.extractElements(n2, t2);
          }
          return 0 === t2.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t2);
        }, Pr.prototype.interfaces_ = function() {
          return [];
        }, Pr.prototype.getClass = function() {
          return Pr;
        }, Pr.combine = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Pr(t2).combine();
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Pr(Pr.createList(e3, n2)).combine();
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return new Pr(Pr.createList(i2, r2, o2)).combine();
          }
        }, Pr.extractFactory = function(t2) {
          return t2.isEmpty() ? null : t2.iterator().next().getFactory();
        }, Pr.createList = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new Nt();
            return n2.add(t2), n2.add(e3), n2;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = new Nt();
            return s2.add(i2), s2.add(r2), s2.add(o2), s2;
          }
        };
        var Dr = function() {
          this._inputPolys = null, this._geomFactory = null;
          var t2 = arguments[0];
          this._inputPolys = t2, null === this._inputPolys && (this._inputPolys = new Nt());
        }, Mr = { STRTREE_NODE_CAPACITY: { configurable: true } };
        Dr.prototype.reduceToGeometries = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next(), r2 = null;
            T(i2, xt) ? r2 = this.unionTree(i2) : i2 instanceof ct && (r2 = i2), e3.add(r2);
          }
          return e3;
        }, Dr.prototype.extractByEnvelope = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = 0; r2 < e3.getNumGeometries(); r2++) {
            var o2 = e3.getGeometryN(r2);
            o2.getEnvelopeInternal().intersects(t2) ? i2.add(o2) : n2.add(o2);
          }
          return this._geomFactory.buildGeometry(i2);
        }, Dr.prototype.unionOptimized = function(t2, e3) {
          var n2 = t2.getEnvelopeInternal(), i2 = e3.getEnvelopeInternal();
          if (!n2.intersects(i2)) {
            return Pr.combine(t2, e3);
          }
          if (t2.getNumGeometries() <= 1 && e3.getNumGeometries() <= 1)
            return this.unionActual(t2, e3);
          var r2 = n2.intersection(i2);
          return this.unionUsingEnvelopeIntersection(t2, e3, r2);
        }, Dr.prototype.union = function() {
          if (null === this._inputPolys)
            throw new Error("union() method cannot be called twice");
          if (this._inputPolys.isEmpty())
            return null;
          this._geomFactory = this._inputPolys.iterator().next().getFactory();
          for (var t2 = new sn(Dr.STRTREE_NODE_CAPACITY), e3 = this._inputPolys.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.insert(n2.getEnvelopeInternal(), n2);
          }
          this._inputPolys = null;
          var i2 = t2.itemsTree();
          return this.unionTree(i2);
        }, Dr.prototype.binaryUnion = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.binaryUnion(t2, 0, t2.size());
          }
          if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (i2 - n2 <= 1) {
              var r2 = Dr.getGeometry(e3, n2);
              return this.unionSafe(r2, null);
            }
            if (i2 - n2 == 2)
              return this.unionSafe(Dr.getGeometry(e3, n2), Dr.getGeometry(e3, n2 + 1));
            var o2 = Math.trunc((i2 + n2) / 2), s2 = this.binaryUnion(e3, n2, o2), a2 = this.binaryUnion(e3, o2, i2);
            return this.unionSafe(s2, a2);
          }
        }, Dr.prototype.repeatedUnion = function(t2) {
          for (var e3 = null, n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3 = null === e3 ? i2.copy() : e3.union(i2);
          }
          return e3;
        }, Dr.prototype.unionSafe = function(t2, e3) {
          return null === t2 && null === e3 ? null : null === t2 ? e3.copy() : null === e3 ? t2.copy() : this.unionOptimized(t2, e3);
        }, Dr.prototype.unionActual = function(t2, e3) {
          return Dr.restrictToPolygons(t2.union(e3));
        }, Dr.prototype.unionTree = function(t2) {
          var e3 = this.reduceToGeometries(t2);
          return this.binaryUnion(e3);
        }, Dr.prototype.unionUsingEnvelopeIntersection = function(t2, e3, n2) {
          var i2 = new Nt(), r2 = this.extractByEnvelope(n2, t2, i2), o2 = this.extractByEnvelope(n2, e3, i2), s2 = this.unionActual(r2, o2);
          i2.add(s2);
          return Pr.combine(i2);
        }, Dr.prototype.bufferUnion = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2.get(0).getFactory().buildGeometry(t2).buffer(0);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().createGeometryCollection([e3, n2]).buffer(0);
          }
        }, Dr.prototype.interfaces_ = function() {
          return [];
        }, Dr.prototype.getClass = function() {
          return Dr;
        }, Dr.restrictToPolygons = function(t2) {
          if (T(t2, Zt))
            return t2;
          var e3 = Ni.getPolygons(t2);
          return 1 === e3.size() ? e3.get(0) : t2.getFactory().createMultiPolygon(_e.toPolygonArray(e3));
        }, Dr.getGeometry = function(t2, e3) {
          return e3 >= t2.size() ? null : t2.get(e3);
        }, Dr.union = function(t2) {
          return new Dr(t2).union();
        }, Mr.STRTREE_NODE_CAPACITY.get = function() {
          return 4;
        }, Object.defineProperties(Dr, Mr);
        var Ar = function() {
        };
        Ar.prototype.interfaces_ = function() {
          return [];
        }, Ar.prototype.getClass = function() {
          return Ar;
        }, Ar.union = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.UNION, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.UNION);
        }, t.GeoJSONReader = Ne, t.GeoJSONWriter = Ce, t.OverlayOp = Lr, t.UnionOp = Ar, t.BufferOp = di, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // ../../../../../../../node_modules/osmtogeojson/lodash.custom.js
  var require_lodash_custom = __commonJS({
    "../../../../../../../node_modules/osmtogeojson/lodash.custom.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.15.0";
        var LARGE_ARRAY_SIZE = 200;
        var FUNC_ERROR_TEXT = "Expected a function";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reEscapeChar = /\\(\\)?/g;
        var reFlags = /\w*$/;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            return freeProcess && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function addMapEntry(map3, pair2) {
          map3.set(pair2[0], pair2[1]);
          return map3;
        }
        function addSetEntry(set, value) {
          set.add(value);
          return set;
        }
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayEach(array2, iteratee2) {
          var index = -1, length2 = array2 ? array2.length : 0;
          while (++index < length2) {
            if (iteratee2(array2[index], index, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayPush(array2, values) {
          var index = -1, length2 = values.length, offset = array2.length;
          while (++index < length2) {
            array2[offset + index] = values[index];
          }
          return array2;
        }
        function arrayReduce(array2, iteratee2, accumulator, initAccum) {
          var index = -1, length2 = array2 ? array2.length : 0;
          if (initAccum && length2) {
            accumulator = array2[++index];
          }
          while (++index < length2) {
            accumulator = iteratee2(accumulator, array2[index], index, array2);
          }
          return accumulator;
        }
        function arraySome(array2, predicate) {
          var index = -1, length2 = array2 ? array2.length : 0;
          while (++index < length2) {
            if (predicate(array2[index], index, array2)) {
              return true;
            }
          }
          return false;
        }
        function baseProperty(key) {
          return function(object2) {
            return object2 == null ? undefined2 : object2[key];
          };
        }
        function baseTimes(n, iteratee2) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee2(index);
          }
          return result;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function getValue(object2, key) {
          return object2 == null ? undefined2 : object2[key];
        }
        function isHostObject(value) {
          var result = false;
          if (value != null && typeof value.toString != "function") {
            try {
              result = !!(value + "");
            } catch (e) {
            }
          }
          return result;
        }
        function mapToArray(map3) {
          var index = -1, result = Array(map3.size);
          map3.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
        var coreJsData = root["__core-js_shared__"];
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var objectCtorString = funcToString.call(Object);
        var objectToString = objectProto.toString;
        var reIsNative = RegExp(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? root.Buffer : undefined2, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
        var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max;
        var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
        var nonEnumShadows = !propertyIsEnumerable.call({ "valueOf": 1 }, "valueOf");
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash() {
        }
        function Hash(entries) {
          var index = -1, length2 = entries ? entries.length : 0;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
        }
        function hashDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined2 : result;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length2 = entries ? entries.length : 0;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length2 = entries ? entries.length : 0;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          return getMapData(this, key)["delete"](key);
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          getMapData(this, key).set(key, value);
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values) {
          var index = -1, length2 = values ? values.length : 0;
          this.__data__ = new MapCache();
          while (++index < length2) {
            this.add(values[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          this.__data__ = new ListCache(entries);
        }
        function stackClear() {
          this.__data__ = new ListCache();
        }
        function stackDelete(key) {
          return this.__data__["delete"](key);
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var cache = this.__data__;
          if (cache instanceof ListCache) {
            var pairs = cache.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              return this;
            }
            cache = this.__data__ = new MapCache(pairs);
          }
          cache.set(key, value);
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
          var length2 = result.length, skipIndexes = !!length2;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length2)))) {
              result.push(key);
            }
          }
          return result;
        }
        function assignMergeValue(object2, key, value) {
          if (value !== undefined2 && !eq(object2[key], value) || typeof key == "number" && value === undefined2 && !(key in object2)) {
            object2[key] = value;
          }
        }
        function assignValue(object2, key, value) {
          var objValue = object2[key];
          if (!(hasOwnProperty2.call(object2, key) && eq(objValue, value)) || value === undefined2 && !(key in object2)) {
            object2[key] = value;
          }
        }
        function assocIndexOf(array2, key) {
          var length2 = array2.length;
          while (length2--) {
            if (eq(array2[length2][0], key)) {
              return length2;
            }
          }
          return -1;
        }
        function baseAssign(object2, source) {
          return object2 && copyObject(source, keys(source), object2);
        }
        function baseClone(value, isDeep, isFull, customizer, key, object2, stack) {
          var result;
          if (customizer) {
            result = object2 ? customizer(value, key, object2, stack) : customizer(value);
          }
          if (result !== undefined2) {
            return result;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object2) {
              if (isHostObject(value)) {
                return object2 ? value : {};
              }
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object2 ? value : {};
              }
              result = initCloneByTag(value, tag, baseClone, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);
          if (!isArr) {
            var props = isFull ? getAllKeys(value) : keys(value);
          }
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
          });
          return result;
        }
        function baseCreate(proto) {
          return isObject2(proto) ? objectCreate(proto) : {};
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseFor = createBaseFor();
        function baseForOwn(object2, iteratee2) {
          return object2 && baseFor(object2, iteratee2, keys);
        }
        function baseGet(object2, path) {
          path = isKey(path, object2) ? [path] : castPath(path);
          var index = 0, length2 = path.length;
          while (object2 != null && index < length2) {
            object2 = object2[toKey(path[index++])];
          }
          return index && index == length2 ? object2 : undefined2;
        }
        function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
          var result = keysFunc(object2);
          return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
        }
        function baseGetTag(value) {
          return objectToString.call(value);
        }
        function baseHasIn(object2, key) {
          return object2 != null && key in Object(object2);
        }
        function baseIsEqual(value, other, customizer, bitmask, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObject2(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
        }
        function baseIsEqualDeep(object2, other, equalFunc, customizer, bitmask, stack) {
          var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
          if (!objIsArr) {
            objTag = getTag(object2);
            objTag = objTag == argsTag ? objectTag : objTag;
          }
          if (!othIsArr) {
            othTag = getTag(other);
            othTag = othTag == argsTag ? objectTag : othTag;
          }
          var objIsObj = objTag == objectTag && !isHostObject(object2), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, equalFunc, customizer, bitmask, stack) : equalByTag(object2, other, objTag, equalFunc, customizer, bitmask, stack);
          }
          if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object2, other, equalFunc, customizer, bitmask, stack);
        }
        function baseIsMatch(object2, source, matchData, customizer) {
          var index = matchData.length, length2 = index, noCustomizer = !customizer;
          if (object2 == null) {
            return !length2;
          }
          object2 = Object(object2);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
              return false;
            }
          }
          while (++index < length2) {
            data = matchData[index];
            var key = data[0], objValue = object2[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object2)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object2, source, stack);
              }
              if (!(result === undefined2 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result = [];
          for (var key in Object(object2)) {
            if (hasOwnProperty2.call(object2, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        function baseKeysIn(object2) {
          if (!isObject2(object2)) {
            return nativeKeysIn(object2);
          }
          var isProto = isPrototype(object2), result = [];
          for (var key in object2) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object2) {
            return object2 === source || baseIsMatch(object2, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object2) {
            var objValue = get(object2, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, undefined2, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
          };
        }
        function baseMerge(object2, source, srcIndex, customizer, stack) {
          if (object2 === source) {
            return;
          }
          if (!(isArray(source) || isTypedArray(source))) {
            var props = baseKeysIn(source);
          }
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObject2(srcValue)) {
              stack || (stack = new Stack());
              baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(object2[key], srcValue, key + "", object2, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object2, key, newValue);
            }
          });
        }
        function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = object2[key], srcValue = source[key], stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object2, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            newValue = srcValue;
            if (isArray(srcValue) || isTypedArray(srcValue)) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else {
                isCommon = false;
                newValue = baseClone(srcValue, true);
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || srcIndex && isFunction(objValue)) {
                isCommon = false;
                newValue = baseClone(srcValue, true);
              } else {
                newValue = objValue;
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object2, key, newValue);
        }
        function basePropertyDeep(path) {
          return function(object2) {
            return baseGet(object2, path);
          };
        }
        function baseRest(func, start) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length2 = nativeMax(args.length - start, 0), array2 = Array(length2);
            while (++index < length2) {
              array2[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = array2;
            return apply(func, this, otherArgs);
          };
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function castPath(value) {
          return isArray(value) ? value : stringToPath(value);
        }
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep) {
            return buffer2.slice();
          }
          var result = new buffer2.constructor(buffer2.length);
          buffer2.copy(result);
          return result;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
          return result;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map3, isDeep, cloneFunc) {
          var array2 = isDeep ? cloneFunc(mapToArray(map3), true) : mapToArray(map3);
          return arrayReduce(array2, addMapEntry, new map3.constructor());
        }
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
          var array2 = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
          return arrayReduce(array2, addSetEntry, new set.constructor());
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        function copyArray(source, array2) {
          var index = -1, length2 = source.length;
          array2 || (array2 = Array(length2));
          while (++index < length2) {
            array2[index] = source[index];
          }
          return array2;
        }
        function copyObject(source, props, object2, customizer) {
          object2 || (object2 = {});
          var index = -1, length2 = props.length;
          while (++index < length2) {
            var key = props[index];
            var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined2;
            assignValue(object2, key, newValue === undefined2 ? source[key] : newValue);
          }
          return object2;
        }
        function copySymbols(source, object2) {
          return copyObject(source, getSymbols(source), object2);
        }
        function createAssigner(assigner) {
          return baseRest(function(object2, sources) {
            var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined2, guard = length2 > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length2 < 3 ? undefined2 : customizer;
              length2 = 1;
            }
            object2 = Object(object2);
            while (++index < length2) {
              var source = sources[index];
              if (source) {
                assigner(object2, source, index, customizer);
              }
            }
            return object2;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object(collection);
            while (fromRight ? index-- : ++index < length2) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee2, keysFunc) {
            var index = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
            while (length2--) {
              var key = props[fromRight ? length2 : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        function equalArrays(array2, other, equalFunc, customizer, bitmask, stack) {
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var stacked = stack.get(array2);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined2;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index < arrLength) {
            var arrValue = array2[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
                  return seen.add(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              result = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result;
        }
        function equalByTag(object2, other, tag, equalFunc, customizer, bitmask, stack) {
          switch (tag) {
            case dataViewTag:
              if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
              }
              object2 = object2.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object2, +other);
            case errorTag:
              return object2.name == other.name && object2.message == other.message;
            case regexpTag:
            case stringTag:
              return object2 == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
              convert || (convert = setToArray);
              if (object2.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object2);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= UNORDERED_COMPARE_FLAG;
              stack.set(object2, other);
              var result = equalArrays(convert(object2), convert(other), equalFunc, customizer, bitmask, stack);
              stack["delete"](object2);
              return result;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object2, other, equalFunc, customizer, bitmask, stack) {
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object2), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var stacked = stack.get(object2);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var result = true;
          stack.set(object2, other);
          stack.set(other, object2);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object2[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result && !skipCtor) {
            var objCtor = object2.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack["delete"](object2);
          stack["delete"](other);
          return result;
        }
        function getAllKeys(object2) {
          return baseGetAllKeys(object2, keys, getSymbols);
        }
        function getIteratee() {
          var result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object2) {
          var result = keys(object2), length2 = result.length;
          while (length2--) {
            var key = result[length2], value = object2[key];
            result[length2] = [key, value, isStrictComparable(value)];
          }
          return result;
        }
        function getNative(object2, key) {
          var value = getValue(object2, key);
          return baseIsNative(value) ? value : undefined2;
        }
        var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : undefined2;
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result;
          };
        }
        function hasPath(object2, path, hasFunc) {
          path = isKey(path, object2) ? [path] : castPath(path);
          var result, index = -1, length2 = path.length;
          while (++index < length2) {
            var key = toKey(path[index]);
            if (!(result = object2 != null && hasFunc(object2, key))) {
              break;
            }
            object2 = object2[key];
          }
          if (result) {
            return result;
          }
          var length2 = object2 ? object2.length : 0;
          return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object2) || isArguments(object2));
        }
        function initCloneArray(array2) {
          var length2 = array2.length, result = array2.constructor(length2);
          if (length2 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
            result.index = array2.index;
            result.input = array2.input;
          }
          return result;
        }
        function initCloneObject(object2) {
          return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
        }
        function initCloneByTag(object2, tag, cloneFunc, isDeep) {
          var Ctor = object2.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object2);
            case boolTag:
            case dateTag:
              return new Ctor(+object2);
            case dataViewTag:
              return cloneDataView(object2, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object2, isDeep);
            case mapTag:
              return cloneMap(object2, isDeep, cloneFunc);
            case numberTag:
            case stringTag:
              return new Ctor(object2);
            case regexpTag:
              return cloneRegExp(object2);
            case setTag:
              return cloneSet(object2, isDeep, cloneFunc);
            case symbolTag:
              return cloneSymbol(object2);
          }
        }
        function isIndex(value, length2) {
          length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
          return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
        }
        function isIterateeCall(value, index, object2) {
          if (!isObject2(object2)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
            return eq(object2[index], value);
          }
          return false;
        }
        function isKey(value, object2) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object2) {
            if (object2 == null) {
              return false;
            }
            return object2[key] === srcValue && (srcValue !== undefined2 || key in Object(object2));
          };
        }
        function nativeKeysIn(object2) {
          var result = [];
          if (object2 != null) {
            for (var key in Object(object2)) {
              result.push(key);
            }
          }
          return result;
        }
        var stringToPath = memoize(function(string) {
          string = toString(string);
          var result = [];
          if (reLeadingDot.test(string)) {
            result.push("");
          }
          string.replace(rePropName, function(match, number, quote, string2) {
            result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
          });
          return result;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function compact(array2) {
          var index = -1, length2 = array2 ? array2.length : 0, resIndex = 0, result = [];
          while (++index < length2) {
            var value = array2[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver && typeof resolver != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function clone2(value) {
          return baseClone(value, false, true);
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        function isArguments(value) {
          return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
        }
        var isArray = Array.isArray;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        function isEmpty(value) {
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (nonEnumShadows || isPrototype(value)) {
            return !nativeKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isFunction(value) {
          var tag = isObject2(value) ? objectToString.call(value) : "";
          return tag == funcTag || tag == genTag;
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return !!value && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return !!value && typeof value == "object";
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        function get(object2, path, defaultValue) {
          var result = object2 == null ? undefined2 : baseGet(object2, path);
          return result === undefined2 ? defaultValue : result;
        }
        function hasIn(object2, path) {
          return object2 != null && hasPath(object2, path, baseHasIn);
        }
        function keys(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function keysIn(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
        }
        var merge = createAssigner(function(object2, source, srcIndex) {
          baseMerge(object2, source, srcIndex);
        });
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, true));
        }
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        lodash.compact = compact;
        lodash.iteratee = iteratee;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.property = property;
        lodash.toPlainObject = toPlainObject;
        lodash.clone = clone2;
        lodash.eq = eq;
        lodash.forEach = forEach;
        lodash.get = get;
        lodash.hasIn = hasIn;
        lodash.identity = identity;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBuffer = isBuffer;
        lodash.isEmpty = isEmpty;
        lodash.isFunction = isFunction;
        lodash.isLength = isLength;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.toString = toString;
        lodash.each = forEach;
        lodash.VERSION = VERSION;
        if (freeModule) {
          (freeModule.exports = lodash)._ = lodash;
          freeExports._ = lodash;
        }
      }).call(exports);
    }
  });

  // ../../../../../../../node_modules/@mapbox/geojson-rewind/index.js
  var require_geojson_rewind = __commonJS({
    "../../../../../../../node_modules/@mapbox/geojson-rewind/index.js"(exports, module) {
      module.exports = rewind;
      function rewind(gj, outer) {
        var type = gj && gj.type, i;
        if (type === "FeatureCollection") {
          for (i = 0; i < gj.features.length; i++)
            rewind(gj.features[i], outer);
        } else if (type === "GeometryCollection") {
          for (i = 0; i < gj.geometries.length; i++)
            rewind(gj.geometries[i], outer);
        } else if (type === "Feature") {
          rewind(gj.geometry, outer);
        } else if (type === "Polygon") {
          rewindRings(gj.coordinates, outer);
        } else if (type === "MultiPolygon") {
          for (i = 0; i < gj.coordinates.length; i++)
            rewindRings(gj.coordinates[i], outer);
        }
        return gj;
      }
      function rewindRings(rings, outer) {
        if (rings.length === 0)
          return;
        rewindRing(rings[0], outer);
        for (var i = 1; i < rings.length; i++) {
          rewindRing(rings[i], !outer);
        }
      }
      function rewindRing(ring, dir) {
        var area2 = 0, err = 0;
        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
          var k = (ring[i][0] - ring[j][0]) * (ring[j][1] + ring[i][1]);
          var m = area2 + k;
          err += Math.abs(area2) >= Math.abs(k) ? area2 - m + k : k - m + area2;
          area2 = m;
        }
        if (area2 + err >= 0 !== !!dir)
          ring.reverse();
      }
    }
  });

  // ../../../../../../../node_modules/osm-polygon-features/polygon-features.json
  var require_polygon_features = __commonJS({
    "../../../../../../../node_modules/osm-polygon-features/polygon-features.json"(exports, module) {
      module.exports = [
        {
          key: "building",
          polygon: "all"
        },
        {
          key: "highway",
          polygon: "whitelist",
          values: [
            "services",
            "rest_area",
            "escape",
            "elevator"
          ]
        },
        {
          key: "natural",
          polygon: "blacklist",
          values: [
            "coastline",
            "cliff",
            "ridge",
            "arete",
            "tree_row"
          ]
        },
        {
          key: "landuse",
          polygon: "all"
        },
        {
          key: "waterway",
          polygon: "whitelist",
          values: [
            "riverbank",
            "dock",
            "boatyard",
            "dam"
          ]
        },
        {
          key: "amenity",
          polygon: "all"
        },
        {
          key: "leisure",
          polygon: "all"
        },
        {
          key: "barrier",
          polygon: "whitelist",
          values: [
            "city_wall",
            "ditch",
            "hedge",
            "retaining_wall",
            "wall",
            "spikes"
          ]
        },
        {
          key: "railway",
          polygon: "whitelist",
          values: [
            "station",
            "turntable",
            "roundhouse",
            "platform"
          ]
        },
        {
          key: "area",
          polygon: "all"
        },
        {
          key: "boundary",
          polygon: "all"
        },
        {
          key: "man_made",
          polygon: "blacklist",
          values: [
            "cutline",
            "embankment",
            "pipeline"
          ]
        },
        {
          key: "power",
          polygon: "whitelist",
          values: [
            "plant",
            "substation",
            "generator",
            "transformer"
          ]
        },
        {
          key: "place",
          polygon: "all"
        },
        {
          key: "shop",
          polygon: "all"
        },
        {
          key: "aeroway",
          polygon: "blacklist",
          values: [
            "taxiway"
          ]
        },
        {
          key: "tourism",
          polygon: "all"
        },
        {
          key: "historic",
          polygon: "all"
        },
        {
          key: "public_transport",
          polygon: "all"
        },
        {
          key: "office",
          polygon: "all"
        },
        {
          key: "building:part",
          polygon: "all"
        },
        {
          key: "military",
          polygon: "all"
        },
        {
          key: "ruins",
          polygon: "all"
        },
        {
          key: "area:highway",
          polygon: "all"
        },
        {
          key: "craft",
          polygon: "all"
        },
        {
          key: "golf",
          polygon: "all"
        },
        {
          key: "indoor",
          polygon: "all"
        }
      ];
    }
  });

  // ../../../../../../../node_modules/osm-polygon-features/index.js
  var require_osm_polygon_features = __commonJS({
    "../../../../../../../node_modules/osm-polygon-features/index.js"(exports, module) {
      module.exports = require_polygon_features();
    }
  });

  // ../../../../../../../node_modules/osmtogeojson/index.js
  var require_osmtogeojson = __commonJS({
    "../../../../../../../node_modules/osmtogeojson/index.js"(exports, module) {
      var _ = require_lodash_custom();
      var rewind = require_geojson_rewind();
      var polygonFeatures = {};
      require_osm_polygon_features().forEach(function(tags) {
        if (tags.polygon === "all")
          polygonFeatures[tags.key] = true;
        else {
          var list = tags.polygon === "whitelist" ? "included_values" : "excluded_values", tagValuesObj = {};
          tags.values.forEach(function(value) {
            tagValuesObj[value] = true;
          });
          polygonFeatures[tags.key] = {};
          polygonFeatures[tags.key][list] = tagValuesObj;
        }
      });
      function default_deduplicator(objectA, objectB) {
        if ((objectA.version || objectB.version) && objectA.version !== objectB.version) {
          return (+objectA.version || 0) > (+objectB.version || 0) ? objectA : objectB;
        }
        return _.merge(objectA, objectB);
      }
      var osmtogeojson2 = {};
      osmtogeojson2 = function(data, options, featureCallback) {
        options = _.merge(
          {
            verbose: false,
            flatProperties: true,
            uninterestingTags: {
              "source": true,
              "source_ref": true,
              "source:ref": true,
              "history": true,
              "attribution": true,
              "created_by": true,
              "tiger:county": true,
              "tiger:tlid": true,
              "tiger:upload_uuid": true
            },
            polygonFeatures,
            deduplicator: default_deduplicator
          },
          options
        );
        var result;
        if (typeof XMLDocument !== "undefined" && data instanceof XMLDocument || typeof XMLDocument === "undefined" && data.childNodes)
          result = _osmXML2geoJSON(data);
        else
          result = _overpassJSON2geoJSON(data);
        return result;
        function _overpassJSON2geoJSON(json) {
          var nodes = new Array();
          var ways = new Array();
          var rels = new Array();
          function centerGeometry(object2) {
            var pseudoNode = _.clone(object2);
            pseudoNode.lat = object2.center.lat;
            pseudoNode.lon = object2.center.lon;
            pseudoNode.__is_center_placeholder = true;
            nodes.push(pseudoNode);
          }
          function boundsGeometry(object2) {
            var pseudoWay = _.clone(object2);
            pseudoWay.nodes = [];
            function addPseudoNode(lat, lon, i2) {
              var pseudoNode = {
                type: "node",
                id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i2,
                lat,
                lon
              };
              pseudoWay.nodes.push(pseudoNode.id);
              nodes.push(pseudoNode);
            }
            addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.minlon, 1);
            addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.minlon, 2);
            addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.maxlon, 3);
            addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.maxlon, 4);
            pseudoWay.nodes.push(pseudoWay.nodes[0]);
            pseudoWay.__is_bounds_placeholder = true;
            ways.push(pseudoWay);
          }
          function fullGeometryWay(way2) {
            function addFullGeometryNode(lat, lon, id) {
              var geometryNode = {
                type: "node",
                id,
                lat,
                lon
              };
              nodes.push(geometryNode);
            }
            if (!_.isArray(way2.nodes)) {
              way2.nodes = way2.geometry.map(function(nd) {
                if (nd !== null)
                  return "_anonymous@" + nd.lat + "/" + nd.lon;
                else
                  return "_anonymous@unknown_location";
              });
            }
            way2.geometry.forEach(function(nd, i2) {
              if (nd) {
                addFullGeometryNode(
                  nd.lat,
                  nd.lon,
                  way2.nodes[i2]
                );
              }
            });
          }
          function fullGeometryRelation(rel2) {
            function addFullGeometryNode(lat, lon, id) {
              var geometryNode = {
                type: "node",
                id,
                lat,
                lon
              };
              nodes.push(geometryNode);
            }
            function addFullGeometryWay(geometry, id) {
              if (ways.some(function(way2) {
                return way2.type == "way" && way2.id == id;
              }))
                return;
              var geometryWay = {
                type: "way",
                id,
                nodes: []
              };
              function addFullGeometryWayPseudoNode(lat, lon) {
                var geometryPseudoNode = {
                  type: "node",
                  id: "_anonymous@" + lat + "/" + lon,
                  lat,
                  lon
                };
                geometryWay.nodes.push(geometryPseudoNode.id);
                nodes.push(geometryPseudoNode);
              }
              geometry.forEach(function(nd) {
                if (nd) {
                  addFullGeometryWayPseudoNode(
                    nd.lat,
                    nd.lon
                  );
                } else {
                  geometryWay.nodes.push(void 0);
                }
              });
              ways.push(geometryWay);
            }
            rel2.members.forEach(function(member, i2) {
              if (member.type == "node") {
                if (member.lat) {
                  addFullGeometryNode(
                    member.lat,
                    member.lon,
                    member.ref
                  );
                }
              } else if (member.type == "way") {
                if (member.geometry) {
                  member.ref = "_fullGeom" + member.ref;
                  addFullGeometryWay(
                    member.geometry,
                    member.ref
                  );
                }
              }
            });
          }
          for (var i = 0; i < json.elements.length; i++) {
            switch (json.elements[i].type) {
              case "node":
                var node = json.elements[i];
                nodes.push(node);
                break;
              case "way":
                var way = _.clone(json.elements[i]);
                way.nodes = _.clone(way.nodes);
                ways.push(way);
                if (way.center)
                  centerGeometry(way);
                if (way.geometry)
                  fullGeometryWay(way);
                else if (way.bounds)
                  boundsGeometry(way);
                break;
              case "relation":
                var rel = _.clone(json.elements[i]);
                rel.members = _.clone(rel.members);
                rels.push(rel);
                var has_full_geometry = rel.members && rel.members.some(function(member) {
                  return member.type == "node" && member.lat || member.type == "way" && member.geometry && member.geometry.length > 0;
                });
                if (rel.center)
                  centerGeometry(rel);
                if (has_full_geometry)
                  fullGeometryRelation(rel);
                else if (rel.bounds)
                  boundsGeometry(rel);
                break;
              default:
            }
          }
          return _convert2geoJSON(nodes, ways, rels);
        }
        function _osmXML2geoJSON(xml) {
          var nodes = new Array();
          var ways = new Array();
          var rels = new Array();
          function copy_attribute(x2, o, attr) {
            if (x2.hasAttribute(attr))
              o[attr] = x2.getAttribute(attr);
          }
          function centerGeometry(object2, centroid2) {
            var pseudoNode = _.clone(object2);
            copy_attribute(centroid2, pseudoNode, "lat");
            copy_attribute(centroid2, pseudoNode, "lon");
            pseudoNode.__is_center_placeholder = true;
            nodes.push(pseudoNode);
          }
          function boundsGeometry(object2, bounds2) {
            var pseudoWay = _.clone(object2);
            pseudoWay.nodes = [];
            function addPseudoNode(lat, lon, i) {
              var pseudoNode = {
                type: "node",
                id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i,
                lat,
                lon
              };
              pseudoWay.nodes.push(pseudoNode.id);
              nodes.push(pseudoNode);
            }
            addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("minlon"), 1);
            addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("minlon"), 2);
            addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("maxlon"), 3);
            addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("maxlon"), 4);
            pseudoWay.nodes.push(pseudoWay.nodes[0]);
            pseudoWay.__is_bounds_placeholder = true;
            ways.push(pseudoWay);
          }
          function fullGeometryWay(way, nds) {
            function addFullGeometryNode(lat, lon, id) {
              var geometryNode = {
                type: "node",
                id,
                lat,
                lon
              };
              nodes.push(geometryNode);
              return geometryNode.id;
            }
            if (!_.isArray(way.nodes)) {
              way.nodes = [];
              _.each(nds, function(nd, i) {
                way.nodes.push("_anonymous@" + nd.getAttribute("lat") + "/" + nd.getAttribute("lon"));
              });
            }
            _.each(nds, function(nd, i) {
              if (nd.getAttribute("lat")) {
                addFullGeometryNode(
                  nd.getAttribute("lat"),
                  nd.getAttribute("lon"),
                  way.nodes[i]
                );
              }
            });
          }
          function fullGeometryRelation(rel, members) {
            function addFullGeometryNode(lat, lon, id) {
              var geometryNode = {
                type: "node",
                id,
                lat,
                lon
              };
              nodes.push(geometryNode);
            }
            function addFullGeometryWay(nds, id) {
              if (ways.some(function(way) {
                return way.type == "way" && way.id == id;
              }))
                return;
              var geometryWay = {
                type: "way",
                id,
                nodes: []
              };
              function addFullGeometryWayPseudoNode(lat, lon) {
                var geometryPseudoNode = {
                  type: "node",
                  id: "_anonymous@" + lat + "/" + lon,
                  lat,
                  lon
                };
                geometryWay.nodes.push(geometryPseudoNode.id);
                nodes.push(geometryPseudoNode);
              }
              _.each(nds, function(nd) {
                if (nd.getAttribute("lat")) {
                  addFullGeometryWayPseudoNode(
                    nd.getAttribute("lat"),
                    nd.getAttribute("lon")
                  );
                } else {
                  geometryWay.nodes.push(void 0);
                }
              });
              ways.push(geometryWay);
            }
            _.each(members, function(member, i) {
              if (rel.members[i].type == "node") {
                if (member.getAttribute("lat")) {
                  addFullGeometryNode(
                    member.getAttribute("lat"),
                    member.getAttribute("lon"),
                    rel.members[i].ref
                  );
                }
              } else if (rel.members[i].type == "way") {
                if (member.getElementsByTagName("nd").length > 0) {
                  rel.members[i].ref = "_fullGeom" + rel.members[i].ref;
                  addFullGeometryWay(
                    member.getElementsByTagName("nd"),
                    rel.members[i].ref
                  );
                }
              }
            });
          }
          _.each(xml.getElementsByTagName("node"), function(node, i) {
            var tags = {};
            _.each(node.getElementsByTagName("tag"), function(tag) {
              tags[tag.getAttribute("k")] = tag.getAttribute("v");
            });
            var nodeObject = {
              "type": "node"
            };
            copy_attribute(node, nodeObject, "id");
            copy_attribute(node, nodeObject, "lat");
            copy_attribute(node, nodeObject, "lon");
            copy_attribute(node, nodeObject, "version");
            copy_attribute(node, nodeObject, "timestamp");
            copy_attribute(node, nodeObject, "changeset");
            copy_attribute(node, nodeObject, "uid");
            copy_attribute(node, nodeObject, "user");
            if (!_.isEmpty(tags))
              nodeObject.tags = tags;
            nodes.push(nodeObject);
          });
          var centroid, bounds;
          _.each(xml.getElementsByTagName("way"), function(way, i) {
            var tags = {};
            var wnodes = [];
            _.each(way.getElementsByTagName("tag"), function(tag) {
              tags[tag.getAttribute("k")] = tag.getAttribute("v");
            });
            var has_full_geometry = false;
            _.each(way.getElementsByTagName("nd"), function(nd, i2) {
              var id;
              if (id = nd.getAttribute("ref"))
                wnodes[i2] = id;
              if (!has_full_geometry && nd.getAttribute("lat"))
                has_full_geometry = true;
            });
            var wayObject = {
              "type": "way"
            };
            copy_attribute(way, wayObject, "id");
            copy_attribute(way, wayObject, "version");
            copy_attribute(way, wayObject, "timestamp");
            copy_attribute(way, wayObject, "changeset");
            copy_attribute(way, wayObject, "uid");
            copy_attribute(way, wayObject, "user");
            if (wnodes.length > 0)
              wayObject.nodes = wnodes;
            if (!_.isEmpty(tags))
              wayObject.tags = tags;
            if (centroid = way.getElementsByTagName("center")[0])
              centerGeometry(wayObject, centroid);
            if (has_full_geometry)
              fullGeometryWay(wayObject, way.getElementsByTagName("nd"));
            else if (bounds = way.getElementsByTagName("bounds")[0])
              boundsGeometry(wayObject, bounds);
            ways.push(wayObject);
          });
          _.each(xml.getElementsByTagName("relation"), function(relation, i) {
            var tags = {};
            var members = [];
            _.each(relation.getElementsByTagName("tag"), function(tag) {
              tags[tag.getAttribute("k")] = tag.getAttribute("v");
            });
            var has_full_geometry = false;
            _.each(relation.getElementsByTagName("member"), function(member, i2) {
              members[i2] = {};
              copy_attribute(member, members[i2], "ref");
              copy_attribute(member, members[i2], "role");
              copy_attribute(member, members[i2], "type");
              if (!has_full_geometry && (members[i2].type == "node" && member.getAttribute("lat")) || members[i2].type == "way" && member.getElementsByTagName("nd").length > 0)
                has_full_geometry = true;
            });
            var relObject = {
              "type": "relation"
            };
            copy_attribute(relation, relObject, "id");
            copy_attribute(relation, relObject, "version");
            copy_attribute(relation, relObject, "timestamp");
            copy_attribute(relation, relObject, "changeset");
            copy_attribute(relation, relObject, "uid");
            copy_attribute(relation, relObject, "user");
            if (members.length > 0)
              relObject.members = members;
            if (!_.isEmpty(tags))
              relObject.tags = tags;
            if (centroid = relation.getElementsByTagName("center")[0])
              centerGeometry(relObject, centroid);
            if (has_full_geometry)
              fullGeometryRelation(relObject, relation.getElementsByTagName("member"));
            else if (bounds = relation.getElementsByTagName("bounds")[0])
              boundsGeometry(relObject, bounds);
            rels.push(relObject);
          });
          return _convert2geoJSON(nodes, ways, rels);
        }
        function _convert2geoJSON(nodes, ways, rels) {
          function has_interesting_tags(t, ignore_tags) {
            if (typeof ignore_tags !== "object")
              ignore_tags = {};
            if (typeof options.uninterestingTags === "function")
              return !options.uninterestingTags(t, ignore_tags);
            for (var k in t)
              if (!(options.uninterestingTags[k] === true) && !(ignore_tags[k] === true || ignore_tags[k] === t[k]))
                return true;
            return false;
          }
          ;
          function build_meta_information(object2) {
            var res = {
              "timestamp": object2.timestamp,
              "version": object2.version,
              "changeset": object2.changeset,
              "user": object2.user,
              "uid": object2.uid
            };
            for (var k in res)
              if (res[k] === void 0)
                delete res[k];
            return res;
          }
          var nodeids = new Object();
          var poinids = new Object();
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (nodeids[node.id] !== void 0) {
              node = options.deduplicator(node, nodeids[node.id]);
            }
            nodeids[node.id] = node;
            if (typeof node.tags != "undefined" && has_interesting_tags(node.tags))
              poinids[node.id] = true;
          }
          for (var i = 0; i < rels.length; i++) {
            if (_.isArray(rels[i].members)) {
              for (var j = 0; j < rels[i].members.length; j++) {
                if (rels[i].members[j].type == "node")
                  poinids[rels[i].members[j].ref] = true;
              }
            }
          }
          var wayids = new Object();
          var waynids = new Object();
          for (var i = 0; i < ways.length; i++) {
            var way = ways[i];
            if (wayids[way.id]) {
              way = options.deduplicator(way, wayids[way.id]);
            }
            wayids[way.id] = way;
            if (_.isArray(way.nodes)) {
              for (var j = 0; j < way.nodes.length; j++) {
                if (typeof way.nodes[j] === "object")
                  continue;
                waynids[way.nodes[j]] = true;
                way.nodes[j] = nodeids[way.nodes[j]];
              }
            }
          }
          var pois = new Array();
          for (var id in nodeids) {
            var node = nodeids[id];
            if (!waynids[id] || poinids[id])
              pois.push(node);
          }
          var relids = new Array();
          for (var i = 0; i < rels.length; i++) {
            var rel = rels[i];
            if (relids[rel.id]) {
              rel = options.deduplicator(rel, relids[rel.id]);
            }
            relids[rel.id] = rel;
          }
          var relsmap = { node: {}, way: {}, relation: {} };
          for (var id in relids) {
            var rel = relids[id];
            if (!_.isArray(rel.members)) {
              if (options.verbose)
                console.warn("Relation", rel.type + "/" + rel.id, "ignored because it has no members");
              continue;
            }
            for (var j = 0; j < rel.members.length; j++) {
              var m_type = rel.members[j].type;
              var m_ref = rel.members[j].ref;
              if (typeof m_ref !== "number") {
                m_ref = m_ref.replace("_fullGeom", "");
              }
              if (!relsmap[m_type]) {
                if (options.verbose)
                  console.warn("Relation", rel.type + "/" + rel.id, "member", m_type + "/" + m_ref, "ignored because it has an invalid type");
                continue;
              }
              if (typeof relsmap[m_type][m_ref] === "undefined")
                relsmap[m_type][m_ref] = [];
              relsmap[m_type][m_ref].push({
                "role": rel.members[j].role,
                "rel": rel.id,
                "reltags": rel.tags
              });
            }
          }
          var geojson;
          var geojsonnodes = [];
          for (i = 0; i < pois.length; i++) {
            if (typeof pois[i].lon == "undefined" || typeof pois[i].lat == "undefined") {
              if (options.verbose)
                console.warn("POI", pois[i].type + "/" + pois[i].id, "ignored because it lacks coordinates");
              continue;
            }
            var feature2 = {
              "type": "Feature",
              "id": pois[i].type + "/" + pois[i].id,
              "properties": {
                "type": pois[i].type,
                "id": pois[i].id,
                "tags": pois[i].tags || {},
                "relations": relsmap["node"][pois[i].id] || [],
                "meta": build_meta_information(pois[i])
              },
              "geometry": {
                "type": "Point",
                "coordinates": [+pois[i].lon, +pois[i].lat]
              }
            };
            if (pois[i].__is_center_placeholder)
              feature2.properties["geometry"] = "center";
            if (!featureCallback)
              geojsonnodes.push(feature2);
            else
              featureCallback(feature2);
          }
          var geojsonlines = [];
          var geojsonpolygons = [];
          for (var i = 0; i < rels.length; i++) {
            if (relids[rels[i].id] !== rels[i]) {
              continue;
            }
            if (typeof rels[i].tags != "undefined" && (rels[i].tags["type"] == "route" || rels[i].tags["type"] == "waterway")) {
              let construct_multilinestring2 = function(rel2) {
                var is_tainted = false;
                var members;
                members = rel2.members.filter(function(m) {
                  return m.type === "way";
                });
                members = members.map(function(m) {
                  var way2 = wayids[m.ref];
                  if (way2 === void 0 || way2.nodes === void 0) {
                    if (options.verbose)
                      console.warn("Route " + rel2.type + "/" + rel2.id, "tainted by a missing or incomplete  way", m.type + "/" + m.ref);
                    is_tainted = true;
                    return;
                  }
                  return {
                    // TODO: this is slow! :(
                    id: m.ref,
                    role: m.role,
                    way: way2,
                    nodes: way2.nodes.filter(function(n) {
                      if (n !== void 0)
                        return true;
                      is_tainted = true;
                      if (options.verbose)
                        console.warn("Route", rel2.type + "/" + rel2.id, "tainted by a way", m.type + "/" + m.ref, "with a missing node");
                      return false;
                    })
                  };
                });
                members = _.compact(members);
                var linestrings;
                linestrings = join(members);
                var coords2 = [];
                coords2 = _.compact(linestrings.map(function(linestring) {
                  return _.compact(linestring.map(function(node2) {
                    return [+node2.lon, +node2.lat];
                  }));
                }));
                if (coords2.length == 0) {
                  if (options.verbose)
                    console.warn("Route", rel2.type + "/" + rel2.id, "contains no coordinates");
                  return false;
                }
                var feature3 = {
                  "type": "Feature",
                  "id": rel2.type + "/" + rel2.id,
                  "properties": {
                    "type": rel2.type,
                    "id": rel2.id,
                    "tags": rel2.tags || {},
                    "relations": relsmap[rel2.type][rel2.id] || [],
                    "meta": build_meta_information(rel2)
                  },
                  "geometry": {
                    "type": coords2.length === 1 ? "LineString" : "MultiLineString",
                    "coordinates": coords2.length === 1 ? coords2[0] : coords2
                  }
                };
                if (is_tainted) {
                  if (options.verbose)
                    console.warn("Route", rel2.type + "/" + rel2.id, "is tainted");
                  feature3.properties["tainted"] = true;
                }
                return feature3;
              };
              var construct_multilinestring = construct_multilinestring2;
              if (!_.isArray(rels[i].members)) {
                if (options.verbose)
                  console.warn("Route", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
                continue;
              }
              rels[i].members.forEach(function(m) {
                if (wayids[m.ref] && !has_interesting_tags(wayids[m.ref].tags))
                  wayids[m.ref].is_skippablerelationmember = true;
              });
              feature2 = construct_multilinestring2(rels[i]);
              if (feature2 === false) {
                if (options.verbose)
                  console.warn("Route relation", rels[i].type + "/" + rels[i].id, "ignored because it has invalid geometry");
                continue;
              }
              if (!featureCallback)
                geojsonpolygons.push(feature2);
              else
                featureCallback(rewind(feature2));
            }
            if (typeof rels[i].tags != "undefined" && (rels[i].tags["type"] == "multipolygon" || rels[i].tags["type"] == "boundary")) {
              let construct_multipolygon2 = function(tag_object, rel2) {
                var is_tainted = false;
                var mp_geometry = simple_mp ? "way" : "relation", mp_id = typeof tag_object.id === "number" ? tag_object.id : +tag_object.id.replace("_fullGeom", "");
                var members;
                members = rel2.members.filter(function(m) {
                  return m.type === "way";
                });
                members = members.map(function(m) {
                  var way2 = wayids[m.ref];
                  if (way2 === void 0 || way2.nodes === void 0) {
                    if (options.verbose)
                      console.warn("Multipolygon", mp_geometry + "/" + mp_id, "tainted by a missing or incomplete way", m.type + "/" + m.ref);
                    is_tainted = true;
                    return;
                  }
                  return {
                    // TODO: this is slow! :(
                    id: m.ref,
                    role: m.role || "outer",
                    way: way2,
                    nodes: way2.nodes.filter(function(n) {
                      if (n !== void 0)
                        return true;
                      is_tainted = true;
                      if (options.verbose)
                        console.warn("Multipolygon", mp_geometry + "/" + mp_id, "tainted by a way", m.type + "/" + m.ref, "with a missing node");
                      return false;
                    })
                  };
                });
                members = _.compact(members);
                var outers, inners;
                outers = join(members.filter(function(m) {
                  return m.role === "outer";
                }));
                inners = join(members.filter(function(m) {
                  return m.role === "inner";
                }));
                var mp;
                function findOuter(inner) {
                  var polygonIntersectsPolygon = function(outer2, inner2) {
                    for (var i2 = 0; i2 < inner2.length; i2++)
                      if (pointInPolygon(inner2[i2], outer2))
                        return true;
                    return false;
                  };
                  var mapCoordinates = function(from) {
                    return from.map(function(n) {
                      return [+n.lat, +n.lon];
                    });
                  };
                  var pointInPolygon = function(point2, polygon2) {
                    var x2 = point2[0], y2 = point2[1], inside = false;
                    for (var i2 = 0, j3 = polygon2.length - 1; i2 < polygon2.length; j3 = i2++) {
                      var xi = polygon2[i2][0], yi = polygon2[i2][1];
                      var xj = polygon2[j3][0], yj = polygon2[j3][1];
                      var intersect2 = yi > y2 != yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
                      if (intersect2)
                        inside = !inside;
                    }
                    return inside;
                  };
                  var o2, outer;
                  inner = mapCoordinates(inner);
                  for (o2 = 0; o2 < outers.length; o2++) {
                    outer = mapCoordinates(outers[o2]);
                    if (polygonIntersectsPolygon(outer, inner))
                      return o2;
                  }
                }
                mp = outers.map(function(o2) {
                  return [o2];
                });
                for (var j2 = 0; j2 < inners.length; j2++) {
                  var o = findOuter(inners[j2]);
                  if (o !== void 0)
                    mp[o].push(inners[j2]);
                  else if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains an inner ring with no containing outer");
                  ;
                }
                var mp_coords = [];
                mp_coords = _.compact(mp.map(function(cluster) {
                  var cl = _.compact(cluster.map(function(ring) {
                    if (ring.length < 4) {
                      if (options.verbose)
                        console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains a ring with less than four nodes");
                      return;
                    }
                    return _.compact(ring.map(function(node2) {
                      return [+node2.lon, +node2.lat];
                    }));
                  }));
                  if (cl.length == 0) {
                    if (options.verbose)
                      console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains an empty ring cluster");
                    return;
                  }
                  return cl;
                }));
                if (mp_coords.length == 0) {
                  if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "contains no coordinates");
                  return false;
                }
                var mp_type = "MultiPolygon";
                if (mp_coords.length === 1) {
                  mp_type = "Polygon";
                  mp_coords = mp_coords[0];
                }
                var feature3 = {
                  "type": "Feature",
                  "id": tag_object.type + "/" + mp_id,
                  "properties": {
                    "type": tag_object.type,
                    "id": mp_id,
                    "tags": tag_object.tags || {},
                    "relations": relsmap[tag_object.type][tag_object.id] || [],
                    "meta": build_meta_information(tag_object)
                  },
                  "geometry": {
                    "type": mp_type,
                    "coordinates": mp_coords
                  }
                };
                if (is_tainted) {
                  if (options.verbose)
                    console.warn("Multipolygon", mp_geometry + "/" + mp_id, "is tainted");
                  feature3.properties["tainted"] = true;
                }
                return feature3;
              };
              var construct_multipolygon = construct_multipolygon2;
              if (!_.isArray(rels[i].members)) {
                if (options.verbose)
                  console.warn("Multipolygon", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
                continue;
              }
              var outer_count = 0;
              for (var j = 0; j < rels[i].members.length; j++)
                if (rels[i].members[j].role == "outer")
                  outer_count++;
                else if (options.verbose && rels[i].members[j].role != "inner")
                  console.warn("Multipolygon", rels[i].type + "/" + rels[i].id, "member", rels[i].members[j].type + "/" + rels[i].members[j].ref, 'ignored because it has an invalid role: "' + rels[i].members[j].role + '"');
              rels[i].members.forEach(function(m) {
                if (wayids[m.ref]) {
                  if (m.role === "outer" && !has_interesting_tags(wayids[m.ref].tags, rels[i].tags))
                    wayids[m.ref].is_skippablerelationmember = true;
                  if (m.role === "inner" && !has_interesting_tags(wayids[m.ref].tags))
                    wayids[m.ref].is_skippablerelationmember = true;
                }
              });
              if (outer_count == 0) {
                if (options.verbose)
                  console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because it has no outer ways");
                continue;
              }
              var simple_mp = false;
              if (outer_count == 1 && !has_interesting_tags(rels[i].tags, { "type": true }))
                simple_mp = true;
              var feature2 = null;
              if (!simple_mp) {
                feature2 = construct_multipolygon2(rels[i], rels[i]);
              } else {
                var outer_way = rels[i].members.filter(function(m) {
                  return m.role === "outer";
                })[0];
                outer_way = wayids[outer_way.ref];
                if (outer_way === void 0) {
                  if (options.verbose)
                    console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because outer way", outer_way.type + "/" + outer_way.ref, "is missing");
                  continue;
                }
                outer_way.is_skippablerelationmember = true;
                feature2 = construct_multipolygon2(outer_way, rels[i]);
              }
              if (feature2 === false) {
                if (options.verbose)
                  console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because it has invalid geometry");
                continue;
              }
              if (!featureCallback)
                geojsonpolygons.push(feature2);
              else
                featureCallback(rewind(feature2));
            }
          }
          for (var i = 0; i < ways.length; i++) {
            if (wayids[ways[i].id] !== ways[i]) {
              continue;
            }
            if (!_.isArray(ways[i].nodes)) {
              if (options.verbose)
                console.warn("Way", ways[i].type + "/" + ways[i].id, "ignored because it has no nodes");
              continue;
            }
            if (ways[i].is_skippablerelationmember)
              continue;
            if (typeof ways[i].id !== "number") {
              ways[i].id = +ways[i].id.replace("_fullGeom", "");
            }
            ways[i].tainted = false;
            ways[i].hidden = false;
            var coords = new Array();
            for (j = 0; j < ways[i].nodes.length; j++) {
              if (typeof ways[i].nodes[j] == "object")
                coords.push([+ways[i].nodes[j].lon, +ways[i].nodes[j].lat]);
              else {
                if (options.verbose)
                  console.warn("Way", ways[i].type + "/" + ways[i].id, "is tainted by an invalid node");
                ways[i].tainted = true;
              }
            }
            if (coords.length <= 1) {
              if (options.verbose)
                console.warn("Way", ways[i].type + "/" + ways[i].id, "ignored because it contains too few nodes");
              continue;
            }
            var way_type = "LineString";
            if (typeof ways[i].nodes[0] != "undefined" && typeof ways[i].nodes[ways[i].nodes.length - 1] != "undefined" && // way has its start/end nodes loaded
            ways[i].nodes[0].id === ways[i].nodes[ways[i].nodes.length - 1].id && // ... and forms a closed ring
            (typeof ways[i].tags != "undefined" && // ... and has tags
            _isPolygonFeature(ways[i].tags) || // or is a placeholder for a bounds geometry
            ways[i].__is_bounds_placeholder)) {
              way_type = "Polygon";
              coords = [coords];
            }
            var feature2 = {
              "type": "Feature",
              "id": ways[i].type + "/" + ways[i].id,
              "properties": {
                "type": ways[i].type,
                "id": ways[i].id,
                "tags": ways[i].tags || {},
                "relations": relsmap["way"][ways[i].id] || [],
                "meta": build_meta_information(ways[i])
              },
              "geometry": {
                "type": way_type,
                "coordinates": coords
              }
            };
            if (ways[i].tainted) {
              if (options.verbose)
                console.warn("Way", ways[i].type + "/" + ways[i].id, "is tainted");
              feature2.properties["tainted"] = true;
            }
            if (ways[i].__is_bounds_placeholder)
              feature2.properties["geometry"] = "bounds";
            if (!featureCallback) {
              if (way_type == "LineString")
                geojsonlines.push(feature2);
              else
                geojsonpolygons.push(feature2);
            } else {
              featureCallback(rewind(feature2));
            }
          }
          if (featureCallback)
            return true;
          geojson = {
            "type": "FeatureCollection",
            "features": []
          };
          geojson.features = geojson.features.concat(geojsonpolygons);
          geojson.features = geojson.features.concat(geojsonlines);
          geojson.features = geojson.features.concat(geojsonnodes);
          if (options.flatProperties) {
            geojson.features.forEach(function(f) {
              f.properties = _.merge(
                f.properties.meta,
                f.properties.tags,
                { id: f.properties.type + "/" + f.properties.id }
              );
            });
          }
          geojson = rewind(geojson);
          return geojson;
        }
        function _isPolygonFeature(tags) {
          var polygonFeatures2 = options.polygonFeatures;
          if (typeof polygonFeatures2 === "function")
            return polygonFeatures2(tags);
          if (tags["area"] === "no")
            return false;
          for (var key in tags) {
            var val = tags[key];
            var pfk = polygonFeatures2[key];
            if (typeof pfk === "undefined")
              continue;
            if (val === "no")
              continue;
            if (pfk === true)
              return true;
            if (pfk.included_values && pfk.included_values[val] === true)
              return true;
            if (pfk.excluded_values && pfk.excluded_values[val] !== true)
              return true;
          }
          return false;
        }
      };
      function join(ways) {
        var _first = function(arr) {
          return arr[0];
        };
        var _last = function(arr) {
          return arr[arr.length - 1];
        };
        var _fitTogether = function(n1, n2) {
          return n1 !== void 0 && n2 !== void 0 && n1.id === n2.id;
        };
        var joined = [], current, first, last, i, how, what;
        while (ways.length) {
          current = ways.pop().nodes.slice();
          joined.push(current);
          while (ways.length && !_fitTogether(_first(current), _last(current))) {
            first = _first(current);
            last = _last(current);
            for (i = 0; i < ways.length; i++) {
              what = ways[i].nodes;
              if (_fitTogether(last, _first(what))) {
                how = current.push;
                what = what.slice(1);
                break;
              } else if (_fitTogether(last, _last(what))) {
                how = current.push;
                what = what.slice(0, -1).reverse();
                break;
              } else if (_fitTogether(first, _last(what))) {
                how = current.unshift;
                what = what.slice(0, -1);
                break;
              } else if (_fitTogether(first, _first(what))) {
                how = current.unshift;
                what = what.slice(1).reverse();
                break;
              } else {
                what = how = null;
              }
            }
            if (!what)
              break;
            ways.splice(i, 1);
            how.apply(current, what);
          }
        }
        return joined;
      }
      osmtogeojson2.toGeojson = osmtogeojson2;
      module.exports = osmtogeojson2;
    }
  });

  // ../../../../../../../node_modules/chroma-js/chroma.js
  var require_chroma = __commonJS({
    "../../../../../../../node_modules/chroma-js/chroma.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.chroma = factory());
      })(exports, function() {
        "use strict";
        var limit$2 = function(x2, min2, max2) {
          if (min2 === void 0)
            min2 = 0;
          if (max2 === void 0)
            max2 = 1;
          return x2 < min2 ? min2 : x2 > max2 ? max2 : x2;
        };
        var limit$1 = limit$2;
        var clip_rgb$3 = function(rgb2) {
          rgb2._clipped = false;
          rgb2._unclipped = rgb2.slice(0);
          for (var i2 = 0; i2 <= 3; i2++) {
            if (i2 < 3) {
              if (rgb2[i2] < 0 || rgb2[i2] > 255) {
                rgb2._clipped = true;
              }
              rgb2[i2] = limit$1(rgb2[i2], 0, 255);
            } else if (i2 === 3) {
              rgb2[i2] = limit$1(rgb2[i2], 0, 1);
            }
          }
          return rgb2;
        };
        var classToType = {};
        for (var i$1 = 0, list$1 = ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"]; i$1 < list$1.length; i$1 += 1) {
          var name = list$1[i$1];
          classToType["[object " + name + "]"] = name.toLowerCase();
        }
        var type$p = function(obj) {
          return classToType[Object.prototype.toString.call(obj)] || "object";
        };
        var type$o = type$p;
        var unpack$B = function(args, keyOrder) {
          if (keyOrder === void 0)
            keyOrder = null;
          if (args.length >= 3) {
            return Array.prototype.slice.call(args);
          }
          if (type$o(args[0]) == "object" && keyOrder) {
            return keyOrder.split("").filter(function(k) {
              return args[0][k] !== void 0;
            }).map(function(k) {
              return args[0][k];
            });
          }
          return args[0];
        };
        var type$n = type$p;
        var last$4 = function(args) {
          if (args.length < 2) {
            return null;
          }
          var l = args.length - 1;
          if (type$n(args[l]) == "string") {
            return args[l].toLowerCase();
          }
          return null;
        };
        var PI$2 = Math.PI;
        var utils = {
          clip_rgb: clip_rgb$3,
          limit: limit$2,
          type: type$p,
          unpack: unpack$B,
          last: last$4,
          PI: PI$2,
          TWOPI: PI$2 * 2,
          PITHIRD: PI$2 / 3,
          DEG2RAD: PI$2 / 180,
          RAD2DEG: 180 / PI$2
        };
        var input$h = {
          format: {},
          autodetect: []
        };
        var last$3 = utils.last;
        var clip_rgb$2 = utils.clip_rgb;
        var type$m = utils.type;
        var _input = input$h;
        var Color$D = function Color2() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var me = this;
          if (type$m(args[0]) === "object" && args[0].constructor && args[0].constructor === this.constructor) {
            return args[0];
          }
          var mode = last$3(args);
          var autodetect = false;
          if (!mode) {
            autodetect = true;
            if (!_input.sorted) {
              _input.autodetect = _input.autodetect.sort(function(a, b) {
                return b.p - a.p;
              });
              _input.sorted = true;
            }
            for (var i2 = 0, list2 = _input.autodetect; i2 < list2.length; i2 += 1) {
              var chk = list2[i2];
              mode = chk.test.apply(chk, args);
              if (mode) {
                break;
              }
            }
          }
          if (_input.format[mode]) {
            var rgb2 = _input.format[mode].apply(null, autodetect ? args : args.slice(0, -1));
            me._rgb = clip_rgb$2(rgb2);
          } else {
            throw new Error("unknown format: " + args);
          }
          if (me._rgb.length === 3) {
            me._rgb.push(1);
          }
        };
        Color$D.prototype.toString = function toString() {
          if (type$m(this.hex) == "function") {
            return this.hex();
          }
          return "[" + this._rgb.join(",") + "]";
        };
        var Color_1 = Color$D;
        var chroma$k = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(chroma$k.Color, [null].concat(args)))();
        };
        chroma$k.Color = Color_1;
        chroma$k.version = "2.4.2";
        var chroma_1 = chroma$k;
        var unpack$A = utils.unpack;
        var max$2 = Math.max;
        var rgb2cmyk$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$A(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          r = r / 255;
          g = g / 255;
          b = b / 255;
          var k = 1 - max$2(r, max$2(g, b));
          var f = k < 1 ? 1 / (1 - k) : 0;
          var c = (1 - r - k) * f;
          var m = (1 - g - k) * f;
          var y2 = (1 - b - k) * f;
          return [c, m, y2, k];
        };
        var rgb2cmyk_1 = rgb2cmyk$1;
        var unpack$z = utils.unpack;
        var cmyk2rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$z(args, "cmyk");
          var c = args[0];
          var m = args[1];
          var y2 = args[2];
          var k = args[3];
          var alpha = args.length > 4 ? args[4] : 1;
          if (k === 1) {
            return [0, 0, 0, alpha];
          }
          return [
            c >= 1 ? 0 : 255 * (1 - c) * (1 - k),
            // r
            m >= 1 ? 0 : 255 * (1 - m) * (1 - k),
            // g
            y2 >= 1 ? 0 : 255 * (1 - y2) * (1 - k),
            // b
            alpha
          ];
        };
        var cmyk2rgb_1 = cmyk2rgb;
        var chroma$j = chroma_1;
        var Color$C = Color_1;
        var input$g = input$h;
        var unpack$y = utils.unpack;
        var type$l = utils.type;
        var rgb2cmyk = rgb2cmyk_1;
        Color$C.prototype.cmyk = function() {
          return rgb2cmyk(this._rgb);
        };
        chroma$j.cmyk = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$C, [null].concat(args, ["cmyk"])))();
        };
        input$g.format.cmyk = cmyk2rgb_1;
        input$g.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$y(args, "cmyk");
            if (type$l(args) === "array" && args.length === 4) {
              return "cmyk";
            }
          }
        });
        var unpack$x = utils.unpack;
        var last$2 = utils.last;
        var rnd = function(a) {
          return Math.round(a * 100) / 100;
        };
        var hsl2css$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var hsla = unpack$x(args, "hsla");
          var mode = last$2(args) || "lsa";
          hsla[0] = rnd(hsla[0] || 0);
          hsla[1] = rnd(hsla[1] * 100) + "%";
          hsla[2] = rnd(hsla[2] * 100) + "%";
          if (mode === "hsla" || hsla.length > 3 && hsla[3] < 1) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = "hsla";
          } else {
            hsla.length = 3;
          }
          return mode + "(" + hsla.join(",") + ")";
        };
        var hsl2css_1 = hsl2css$1;
        var unpack$w = utils.unpack;
        var rgb2hsl$3 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$w(args, "rgba");
          var r = args[0];
          var g = args[1];
          var b = args[2];
          r /= 255;
          g /= 255;
          b /= 255;
          var min2 = Math.min(r, g, b);
          var max2 = Math.max(r, g, b);
          var l = (max2 + min2) / 2;
          var s, h;
          if (max2 === min2) {
            s = 0;
            h = Number.NaN;
          } else {
            s = l < 0.5 ? (max2 - min2) / (max2 + min2) : (max2 - min2) / (2 - max2 - min2);
          }
          if (r == max2) {
            h = (g - b) / (max2 - min2);
          } else if (g == max2) {
            h = 2 + (b - r) / (max2 - min2);
          } else if (b == max2) {
            h = 4 + (r - g) / (max2 - min2);
          }
          h *= 60;
          if (h < 0) {
            h += 360;
          }
          if (args.length > 3 && args[3] !== void 0) {
            return [h, s, l, args[3]];
          }
          return [h, s, l];
        };
        var rgb2hsl_1 = rgb2hsl$3;
        var unpack$v = utils.unpack;
        var last$1 = utils.last;
        var hsl2css = hsl2css_1;
        var rgb2hsl$2 = rgb2hsl_1;
        var round$6 = Math.round;
        var rgb2css$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var rgba = unpack$v(args, "rgba");
          var mode = last$1(args) || "rgb";
          if (mode.substr(0, 3) == "hsl") {
            return hsl2css(rgb2hsl$2(rgba), mode);
          }
          rgba[0] = round$6(rgba[0]);
          rgba[1] = round$6(rgba[1]);
          rgba[2] = round$6(rgba[2]);
          if (mode === "rgba" || rgba.length > 3 && rgba[3] < 1) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = "rgba";
          }
          return mode + "(" + rgba.slice(0, mode === "rgb" ? 3 : 4).join(",") + ")";
        };
        var rgb2css_1 = rgb2css$1;
        var unpack$u = utils.unpack;
        var round$5 = Math.round;
        var hsl2rgb$1 = function() {
          var assign;
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$u(args, "hsl");
          var h = args[0];
          var s = args[1];
          var l = args[2];
          var r, g, b;
          if (s === 0) {
            r = g = b = l * 255;
          } else {
            var t3 = [0, 0, 0];
            var c = [0, 0, 0];
            var t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1 / 3;
            t3[1] = h_;
            t3[2] = h_ - 1 / 3;
            for (var i2 = 0; i2 < 3; i2++) {
              if (t3[i2] < 0) {
                t3[i2] += 1;
              }
              if (t3[i2] > 1) {
                t3[i2] -= 1;
              }
              if (6 * t3[i2] < 1) {
                c[i2] = t1 + (t2 - t1) * 6 * t3[i2];
              } else if (2 * t3[i2] < 1) {
                c[i2] = t2;
              } else if (3 * t3[i2] < 2) {
                c[i2] = t1 + (t2 - t1) * (2 / 3 - t3[i2]) * 6;
              } else {
                c[i2] = t1;
              }
            }
            assign = [round$5(c[0] * 255), round$5(c[1] * 255), round$5(c[2] * 255)], r = assign[0], g = assign[1], b = assign[2];
          }
          if (args.length > 3) {
            return [r, g, b, args[3]];
          }
          return [r, g, b, 1];
        };
        var hsl2rgb_1 = hsl2rgb$1;
        var hsl2rgb = hsl2rgb_1;
        var input$f = input$h;
        var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
        var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
        var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
        var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
        var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
        var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
        var round$4 = Math.round;
        var css2rgb$1 = function(css) {
          css = css.toLowerCase().trim();
          var m;
          if (input$f.format.named) {
            try {
              return input$f.format.named(css);
            } catch (e) {
            }
          }
          if (m = css.match(RE_RGB)) {
            var rgb2 = m.slice(1, 4);
            for (var i2 = 0; i2 < 3; i2++) {
              rgb2[i2] = +rgb2[i2];
            }
            rgb2[3] = 1;
            return rgb2;
          }
          if (m = css.match(RE_RGBA)) {
            var rgb$1 = m.slice(1, 5);
            for (var i$12 = 0; i$12 < 4; i$12++) {
              rgb$1[i$12] = +rgb$1[i$12];
            }
            return rgb$1;
          }
          if (m = css.match(RE_RGB_PCT)) {
            var rgb$2 = m.slice(1, 4);
            for (var i$2 = 0; i$2 < 3; i$2++) {
              rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1;
            return rgb$2;
          }
          if (m = css.match(RE_RGBA_PCT)) {
            var rgb$3 = m.slice(1, 5);
            for (var i$3 = 0; i$3 < 3; i$3++) {
              rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
          }
          if (m = css.match(RE_HSL)) {
            var hsl2 = m.slice(1, 4);
            hsl2[1] *= 0.01;
            hsl2[2] *= 0.01;
            var rgb$4 = hsl2rgb(hsl2);
            rgb$4[3] = 1;
            return rgb$4;
          }
          if (m = css.match(RE_HSLA)) {
            var hsl$1 = m.slice(1, 4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb(hsl$1);
            rgb$5[3] = +m[4];
            return rgb$5;
          }
        };
        css2rgb$1.test = function(s) {
          return RE_RGB.test(s) || RE_RGBA.test(s) || RE_RGB_PCT.test(s) || RE_RGBA_PCT.test(s) || RE_HSL.test(s) || RE_HSLA.test(s);
        };
        var css2rgb_1 = css2rgb$1;
        var chroma$i = chroma_1;
        var Color$B = Color_1;
        var input$e = input$h;
        var type$k = utils.type;
        var rgb2css = rgb2css_1;
        var css2rgb = css2rgb_1;
        Color$B.prototype.css = function(mode) {
          return rgb2css(this._rgb, mode);
        };
        chroma$i.css = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$B, [null].concat(args, ["css"])))();
        };
        input$e.format.css = css2rgb;
        input$e.autodetect.push({
          p: 5,
          test: function(h) {
            var rest = [], len = arguments.length - 1;
            while (len-- > 0)
              rest[len] = arguments[len + 1];
            if (!rest.length && type$k(h) === "string" && css2rgb.test(h)) {
              return "css";
            }
          }
        });
        var Color$A = Color_1;
        var chroma$h = chroma_1;
        var input$d = input$h;
        var unpack$t = utils.unpack;
        input$d.format.gl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var rgb2 = unpack$t(args, "rgba");
          rgb2[0] *= 255;
          rgb2[1] *= 255;
          rgb2[2] *= 255;
          return rgb2;
        };
        chroma$h.gl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$A, [null].concat(args, ["gl"])))();
        };
        Color$A.prototype.gl = function() {
          var rgb2 = this._rgb;
          return [rgb2[0] / 255, rgb2[1] / 255, rgb2[2] / 255, rgb2[3]];
        };
        var unpack$s = utils.unpack;
        var rgb2hcg$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$s(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var min2 = Math.min(r, g, b);
          var max2 = Math.max(r, g, b);
          var delta = max2 - min2;
          var c = delta * 100 / 255;
          var _g = min2 / (255 - delta) * 100;
          var h;
          if (delta === 0) {
            h = Number.NaN;
          } else {
            if (r === max2) {
              h = (g - b) / delta;
            }
            if (g === max2) {
              h = 2 + (b - r) / delta;
            }
            if (b === max2) {
              h = 4 + (r - g) / delta;
            }
            h *= 60;
            if (h < 0) {
              h += 360;
            }
          }
          return [h, c, _g];
        };
        var rgb2hcg_1 = rgb2hcg$1;
        var unpack$r = utils.unpack;
        var floor$3 = Math.floor;
        var hcg2rgb = function() {
          var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$r(args, "hcg");
          var h = args[0];
          var c = args[1];
          var _g = args[2];
          var r, g, b;
          _g = _g * 255;
          var _c = c * 255;
          if (c === 0) {
            r = g = b = _g;
          } else {
            if (h === 360) {
              h = 0;
            }
            if (h > 360) {
              h -= 360;
            }
            if (h < 0) {
              h += 360;
            }
            h /= 60;
            var i2 = floor$3(h);
            var f = h - i2;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i2) {
              case 0:
                assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];
                break;
              case 1:
                assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];
                break;
              case 2:
                assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];
                break;
              case 3:
                assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];
                break;
              case 4:
                assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];
                break;
              case 5:
                assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];
                break;
            }
          }
          return [r, g, b, args.length > 3 ? args[3] : 1];
        };
        var hcg2rgb_1 = hcg2rgb;
        var unpack$q = utils.unpack;
        var type$j = utils.type;
        var chroma$g = chroma_1;
        var Color$z = Color_1;
        var input$c = input$h;
        var rgb2hcg = rgb2hcg_1;
        Color$z.prototype.hcg = function() {
          return rgb2hcg(this._rgb);
        };
        chroma$g.hcg = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$z, [null].concat(args, ["hcg"])))();
        };
        input$c.format.hcg = hcg2rgb_1;
        input$c.autodetect.push({
          p: 1,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$q(args, "hcg");
            if (type$j(args) === "array" && args.length === 3) {
              return "hcg";
            }
          }
        });
        var unpack$p = utils.unpack;
        var last = utils.last;
        var round$3 = Math.round;
        var rgb2hex$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$p(args, "rgba");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var a = ref[3];
          var mode = last(args) || "auto";
          if (a === void 0) {
            a = 1;
          }
          if (mode === "auto") {
            mode = a < 1 ? "rgba" : "rgb";
          }
          r = round$3(r);
          g = round$3(g);
          b = round$3(b);
          var u = r << 16 | g << 8 | b;
          var str = "000000" + u.toString(16);
          str = str.substr(str.length - 6);
          var hxa = "0" + round$3(a * 255).toString(16);
          hxa = hxa.substr(hxa.length - 2);
          switch (mode.toLowerCase()) {
            case "rgba":
              return "#" + str + hxa;
            case "argb":
              return "#" + hxa + str;
            default:
              return "#" + str;
          }
        };
        var rgb2hex_1 = rgb2hex$2;
        var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
        var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
        var hex2rgb$1 = function(hex) {
          if (hex.match(RE_HEX)) {
            if (hex.length === 4 || hex.length === 7) {
              hex = hex.substr(1);
            }
            if (hex.length === 3) {
              hex = hex.split("");
              hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = u >> 8 & 255;
            var b = u & 255;
            return [r, g, b, 1];
          }
          if (hex.match(RE_HEXA)) {
            if (hex.length === 5 || hex.length === 9) {
              hex = hex.substr(1);
            }
            if (hex.length === 4) {
              hex = hex.split("");
              hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = u$1 >> 24 & 255;
            var g$1 = u$1 >> 16 & 255;
            var b$1 = u$1 >> 8 & 255;
            var a = Math.round((u$1 & 255) / 255 * 100) / 100;
            return [r$1, g$1, b$1, a];
          }
          throw new Error("unknown hex color: " + hex);
        };
        var hex2rgb_1 = hex2rgb$1;
        var chroma$f = chroma_1;
        var Color$y = Color_1;
        var type$i = utils.type;
        var input$b = input$h;
        var rgb2hex$1 = rgb2hex_1;
        Color$y.prototype.hex = function(mode) {
          return rgb2hex$1(this._rgb, mode);
        };
        chroma$f.hex = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$y, [null].concat(args, ["hex"])))();
        };
        input$b.format.hex = hex2rgb_1;
        input$b.autodetect.push({
          p: 4,
          test: function(h) {
            var rest = [], len = arguments.length - 1;
            while (len-- > 0)
              rest[len] = arguments[len + 1];
            if (!rest.length && type$i(h) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0) {
              return "hex";
            }
          }
        });
        var unpack$o = utils.unpack;
        var TWOPI$2 = utils.TWOPI;
        var min$2 = Math.min;
        var sqrt$4 = Math.sqrt;
        var acos2 = Math.acos;
        var rgb2hsi$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$o(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          r /= 255;
          g /= 255;
          b /= 255;
          var h;
          var min_ = min$2(r, g, b);
          var i2 = (r + g + b) / 3;
          var s = i2 > 0 ? 1 - min_ / i2 : 0;
          if (s === 0) {
            h = NaN;
          } else {
            h = (r - g + (r - b)) / 2;
            h /= sqrt$4((r - g) * (r - g) + (r - b) * (g - b));
            h = acos2(h);
            if (b > g) {
              h = TWOPI$2 - h;
            }
            h /= TWOPI$2;
          }
          return [h * 360, s, i2];
        };
        var rgb2hsi_1 = rgb2hsi$1;
        var unpack$n = utils.unpack;
        var limit = utils.limit;
        var TWOPI$1 = utils.TWOPI;
        var PITHIRD = utils.PITHIRD;
        var cos$4 = Math.cos;
        var hsi2rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$n(args, "hsi");
          var h = args[0];
          var s = args[1];
          var i2 = args[2];
          var r, g, b;
          if (isNaN(h)) {
            h = 0;
          }
          if (isNaN(s)) {
            s = 0;
          }
          if (h > 360) {
            h -= 360;
          }
          if (h < 0) {
            h += 360;
          }
          h /= 360;
          if (h < 1 / 3) {
            b = (1 - s) / 3;
            r = (1 + s * cos$4(TWOPI$1 * h) / cos$4(PITHIRD - TWOPI$1 * h)) / 3;
            g = 1 - (b + r);
          } else if (h < 2 / 3) {
            h -= 1 / 3;
            r = (1 - s) / 3;
            g = (1 + s * cos$4(TWOPI$1 * h) / cos$4(PITHIRD - TWOPI$1 * h)) / 3;
            b = 1 - (r + g);
          } else {
            h -= 2 / 3;
            g = (1 - s) / 3;
            b = (1 + s * cos$4(TWOPI$1 * h) / cos$4(PITHIRD - TWOPI$1 * h)) / 3;
            r = 1 - (g + b);
          }
          r = limit(i2 * r * 3);
          g = limit(i2 * g * 3);
          b = limit(i2 * b * 3);
          return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
        };
        var hsi2rgb_1 = hsi2rgb;
        var unpack$m = utils.unpack;
        var type$h = utils.type;
        var chroma$e = chroma_1;
        var Color$x = Color_1;
        var input$a = input$h;
        var rgb2hsi = rgb2hsi_1;
        Color$x.prototype.hsi = function() {
          return rgb2hsi(this._rgb);
        };
        chroma$e.hsi = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$x, [null].concat(args, ["hsi"])))();
        };
        input$a.format.hsi = hsi2rgb_1;
        input$a.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$m(args, "hsi");
            if (type$h(args) === "array" && args.length === 3) {
              return "hsi";
            }
          }
        });
        var unpack$l = utils.unpack;
        var type$g = utils.type;
        var chroma$d = chroma_1;
        var Color$w = Color_1;
        var input$9 = input$h;
        var rgb2hsl$1 = rgb2hsl_1;
        Color$w.prototype.hsl = function() {
          return rgb2hsl$1(this._rgb);
        };
        chroma$d.hsl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$w, [null].concat(args, ["hsl"])))();
        };
        input$9.format.hsl = hsl2rgb_1;
        input$9.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$l(args, "hsl");
            if (type$g(args) === "array" && args.length === 3) {
              return "hsl";
            }
          }
        });
        var unpack$k = utils.unpack;
        var min$1 = Math.min;
        var max$1 = Math.max;
        var rgb2hsl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$k(args, "rgb");
          var r = args[0];
          var g = args[1];
          var b = args[2];
          var min_ = min$1(r, g, b);
          var max_ = max$1(r, g, b);
          var delta = max_ - min_;
          var h, s, v;
          v = max_ / 255;
          if (max_ === 0) {
            h = Number.NaN;
            s = 0;
          } else {
            s = delta / max_;
            if (r === max_) {
              h = (g - b) / delta;
            }
            if (g === max_) {
              h = 2 + (b - r) / delta;
            }
            if (b === max_) {
              h = 4 + (r - g) / delta;
            }
            h *= 60;
            if (h < 0) {
              h += 360;
            }
          }
          return [h, s, v];
        };
        var rgb2hsv$1 = rgb2hsl;
        var unpack$j = utils.unpack;
        var floor$2 = Math.floor;
        var hsv2rgb = function() {
          var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$j(args, "hsv");
          var h = args[0];
          var s = args[1];
          var v = args[2];
          var r, g, b;
          v *= 255;
          if (s === 0) {
            r = g = b = v;
          } else {
            if (h === 360) {
              h = 0;
            }
            if (h > 360) {
              h -= 360;
            }
            if (h < 0) {
              h += 360;
            }
            h /= 60;
            var i2 = floor$2(h);
            var f = h - i2;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));
            switch (i2) {
              case 0:
                assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];
                break;
              case 1:
                assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];
                break;
              case 2:
                assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];
                break;
              case 3:
                assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];
                break;
              case 4:
                assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];
                break;
              case 5:
                assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];
                break;
            }
          }
          return [r, g, b, args.length > 3 ? args[3] : 1];
        };
        var hsv2rgb_1 = hsv2rgb;
        var unpack$i = utils.unpack;
        var type$f = utils.type;
        var chroma$c = chroma_1;
        var Color$v = Color_1;
        var input$8 = input$h;
        var rgb2hsv = rgb2hsv$1;
        Color$v.prototype.hsv = function() {
          return rgb2hsv(this._rgb);
        };
        chroma$c.hsv = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$v, [null].concat(args, ["hsv"])))();
        };
        input$8.format.hsv = hsv2rgb_1;
        input$8.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$i(args, "hsv");
            if (type$f(args) === "array" && args.length === 3) {
              return "hsv";
            }
          }
        });
        var labConstants = {
          // Corresponds roughly to RGB brighter/darker
          Kn: 18,
          // D65 standard referent
          Xn: 0.95047,
          Yn: 1,
          Zn: 1.08883,
          t0: 0.137931034,
          // 4 / 29
          t1: 0.206896552,
          // 6 / 29
          t2: 0.12841855,
          // 3 * t1 * t1
          t3: 8856452e-9
          // t1 * t1 * t1
        };
        var LAB_CONSTANTS$3 = labConstants;
        var unpack$h = utils.unpack;
        var pow$a = Math.pow;
        var rgb2lab$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$h(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var ref$1 = rgb2xyz(r, g, b);
          var x2 = ref$1[0];
          var y2 = ref$1[1];
          var z = ref$1[2];
          var l = 116 * y2 - 16;
          return [l < 0 ? 0 : l, 500 * (x2 - y2), 200 * (y2 - z)];
        };
        var rgb_xyz = function(r) {
          if ((r /= 255) <= 0.04045) {
            return r / 12.92;
          }
          return pow$a((r + 0.055) / 1.055, 2.4);
        };
        var xyz_lab = function(t) {
          if (t > LAB_CONSTANTS$3.t3) {
            return pow$a(t, 1 / 3);
          }
          return t / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
        };
        var rgb2xyz = function(r, g, b) {
          r = rgb_xyz(r);
          g = rgb_xyz(g);
          b = rgb_xyz(b);
          var x2 = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS$3.Xn);
          var y2 = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / LAB_CONSTANTS$3.Yn);
          var z = xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / LAB_CONSTANTS$3.Zn);
          return [x2, y2, z];
        };
        var rgb2lab_1 = rgb2lab$2;
        var LAB_CONSTANTS$2 = labConstants;
        var unpack$g = utils.unpack;
        var pow$9 = Math.pow;
        var lab2rgb$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$g(args, "lab");
          var l = args[0];
          var a = args[1];
          var b = args[2];
          var x2, y2, z, r, g, b_;
          y2 = (l + 16) / 116;
          x2 = isNaN(a) ? y2 : y2 + a / 500;
          z = isNaN(b) ? y2 : y2 - b / 200;
          y2 = LAB_CONSTANTS$2.Yn * lab_xyz(y2);
          x2 = LAB_CONSTANTS$2.Xn * lab_xyz(x2);
          z = LAB_CONSTANTS$2.Zn * lab_xyz(z);
          r = xyz_rgb(3.2404542 * x2 - 1.5371385 * y2 - 0.4985314 * z);
          g = xyz_rgb(-0.969266 * x2 + 1.8760108 * y2 + 0.041556 * z);
          b_ = xyz_rgb(0.0556434 * x2 - 0.2040259 * y2 + 1.0572252 * z);
          return [r, g, b_, args.length > 3 ? args[3] : 1];
        };
        var xyz_rgb = function(r) {
          return 255 * (r <= 304e-5 ? 12.92 * r : 1.055 * pow$9(r, 1 / 2.4) - 0.055);
        };
        var lab_xyz = function(t) {
          return t > LAB_CONSTANTS$2.t1 ? t * t * t : LAB_CONSTANTS$2.t2 * (t - LAB_CONSTANTS$2.t0);
        };
        var lab2rgb_1 = lab2rgb$1;
        var unpack$f = utils.unpack;
        var type$e = utils.type;
        var chroma$b = chroma_1;
        var Color$u = Color_1;
        var input$7 = input$h;
        var rgb2lab$1 = rgb2lab_1;
        Color$u.prototype.lab = function() {
          return rgb2lab$1(this._rgb);
        };
        chroma$b.lab = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$u, [null].concat(args, ["lab"])))();
        };
        input$7.format.lab = lab2rgb_1;
        input$7.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$f(args, "lab");
            if (type$e(args) === "array" && args.length === 3) {
              return "lab";
            }
          }
        });
        var unpack$e = utils.unpack;
        var RAD2DEG = utils.RAD2DEG;
        var sqrt$3 = Math.sqrt;
        var atan2$2 = Math.atan2;
        var round$2 = Math.round;
        var lab2lch$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$e(args, "lab");
          var l = ref[0];
          var a = ref[1];
          var b = ref[2];
          var c = sqrt$3(a * a + b * b);
          var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;
          if (round$2(c * 1e4) === 0) {
            h = Number.NaN;
          }
          return [l, c, h];
        };
        var lab2lch_1 = lab2lch$2;
        var unpack$d = utils.unpack;
        var rgb2lab = rgb2lab_1;
        var lab2lch$1 = lab2lch_1;
        var rgb2lch$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$d(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var ref$1 = rgb2lab(r, g, b);
          var l = ref$1[0];
          var a = ref$1[1];
          var b_ = ref$1[2];
          return lab2lch$1(l, a, b_);
        };
        var rgb2lch_1 = rgb2lch$1;
        var unpack$c = utils.unpack;
        var DEG2RAD = utils.DEG2RAD;
        var sin$3 = Math.sin;
        var cos$3 = Math.cos;
        var lch2lab$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$c(args, "lch");
          var l = ref[0];
          var c = ref[1];
          var h = ref[2];
          if (isNaN(h)) {
            h = 0;
          }
          h = h * DEG2RAD;
          return [l, cos$3(h) * c, sin$3(h) * c];
        };
        var lch2lab_1 = lch2lab$2;
        var unpack$b = utils.unpack;
        var lch2lab$1 = lch2lab_1;
        var lab2rgb = lab2rgb_1;
        var lch2rgb$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$b(args, "lch");
          var l = args[0];
          var c = args[1];
          var h = args[2];
          var ref = lch2lab$1(l, c, h);
          var L3 = ref[0];
          var a = ref[1];
          var b_ = ref[2];
          var ref$1 = lab2rgb(L3, a, b_);
          var r = ref$1[0];
          var g = ref$1[1];
          var b = ref$1[2];
          return [r, g, b, args.length > 3 ? args[3] : 1];
        };
        var lch2rgb_1 = lch2rgb$1;
        var unpack$a = utils.unpack;
        var lch2rgb = lch2rgb_1;
        var hcl2rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var hcl = unpack$a(args, "hcl").reverse();
          return lch2rgb.apply(void 0, hcl);
        };
        var hcl2rgb_1 = hcl2rgb;
        var unpack$9 = utils.unpack;
        var type$d = utils.type;
        var chroma$a = chroma_1;
        var Color$t = Color_1;
        var input$6 = input$h;
        var rgb2lch = rgb2lch_1;
        Color$t.prototype.lch = function() {
          return rgb2lch(this._rgb);
        };
        Color$t.prototype.hcl = function() {
          return rgb2lch(this._rgb).reverse();
        };
        chroma$a.lch = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$t, [null].concat(args, ["lch"])))();
        };
        chroma$a.hcl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$t, [null].concat(args, ["hcl"])))();
        };
        input$6.format.lch = lch2rgb_1;
        input$6.format.hcl = hcl2rgb_1;
        ["lch", "hcl"].forEach(function(m) {
          return input$6.autodetect.push({
            p: 2,
            test: function() {
              var args = [], len = arguments.length;
              while (len--)
                args[len] = arguments[len];
              args = unpack$9(args, m);
              if (type$d(args) === "array" && args.length === 3) {
                return m;
              }
            }
          });
        });
        var w3cx11$1 = {
          aliceblue: "#f0f8ff",
          antiquewhite: "#faebd7",
          aqua: "#00ffff",
          aquamarine: "#7fffd4",
          azure: "#f0ffff",
          beige: "#f5f5dc",
          bisque: "#ffe4c4",
          black: "#000000",
          blanchedalmond: "#ffebcd",
          blue: "#0000ff",
          blueviolet: "#8a2be2",
          brown: "#a52a2a",
          burlywood: "#deb887",
          cadetblue: "#5f9ea0",
          chartreuse: "#7fff00",
          chocolate: "#d2691e",
          coral: "#ff7f50",
          cornflower: "#6495ed",
          cornflowerblue: "#6495ed",
          cornsilk: "#fff8dc",
          crimson: "#dc143c",
          cyan: "#00ffff",
          darkblue: "#00008b",
          darkcyan: "#008b8b",
          darkgoldenrod: "#b8860b",
          darkgray: "#a9a9a9",
          darkgreen: "#006400",
          darkgrey: "#a9a9a9",
          darkkhaki: "#bdb76b",
          darkmagenta: "#8b008b",
          darkolivegreen: "#556b2f",
          darkorange: "#ff8c00",
          darkorchid: "#9932cc",
          darkred: "#8b0000",
          darksalmon: "#e9967a",
          darkseagreen: "#8fbc8f",
          darkslateblue: "#483d8b",
          darkslategray: "#2f4f4f",
          darkslategrey: "#2f4f4f",
          darkturquoise: "#00ced1",
          darkviolet: "#9400d3",
          deeppink: "#ff1493",
          deepskyblue: "#00bfff",
          dimgray: "#696969",
          dimgrey: "#696969",
          dodgerblue: "#1e90ff",
          firebrick: "#b22222",
          floralwhite: "#fffaf0",
          forestgreen: "#228b22",
          fuchsia: "#ff00ff",
          gainsboro: "#dcdcdc",
          ghostwhite: "#f8f8ff",
          gold: "#ffd700",
          goldenrod: "#daa520",
          gray: "#808080",
          green: "#008000",
          greenyellow: "#adff2f",
          grey: "#808080",
          honeydew: "#f0fff0",
          hotpink: "#ff69b4",
          indianred: "#cd5c5c",
          indigo: "#4b0082",
          ivory: "#fffff0",
          khaki: "#f0e68c",
          laserlemon: "#ffff54",
          lavender: "#e6e6fa",
          lavenderblush: "#fff0f5",
          lawngreen: "#7cfc00",
          lemonchiffon: "#fffacd",
          lightblue: "#add8e6",
          lightcoral: "#f08080",
          lightcyan: "#e0ffff",
          lightgoldenrod: "#fafad2",
          lightgoldenrodyellow: "#fafad2",
          lightgray: "#d3d3d3",
          lightgreen: "#90ee90",
          lightgrey: "#d3d3d3",
          lightpink: "#ffb6c1",
          lightsalmon: "#ffa07a",
          lightseagreen: "#20b2aa",
          lightskyblue: "#87cefa",
          lightslategray: "#778899",
          lightslategrey: "#778899",
          lightsteelblue: "#b0c4de",
          lightyellow: "#ffffe0",
          lime: "#00ff00",
          limegreen: "#32cd32",
          linen: "#faf0e6",
          magenta: "#ff00ff",
          maroon: "#800000",
          maroon2: "#7f0000",
          maroon3: "#b03060",
          mediumaquamarine: "#66cdaa",
          mediumblue: "#0000cd",
          mediumorchid: "#ba55d3",
          mediumpurple: "#9370db",
          mediumseagreen: "#3cb371",
          mediumslateblue: "#7b68ee",
          mediumspringgreen: "#00fa9a",
          mediumturquoise: "#48d1cc",
          mediumvioletred: "#c71585",
          midnightblue: "#191970",
          mintcream: "#f5fffa",
          mistyrose: "#ffe4e1",
          moccasin: "#ffe4b5",
          navajowhite: "#ffdead",
          navy: "#000080",
          oldlace: "#fdf5e6",
          olive: "#808000",
          olivedrab: "#6b8e23",
          orange: "#ffa500",
          orangered: "#ff4500",
          orchid: "#da70d6",
          palegoldenrod: "#eee8aa",
          palegreen: "#98fb98",
          paleturquoise: "#afeeee",
          palevioletred: "#db7093",
          papayawhip: "#ffefd5",
          peachpuff: "#ffdab9",
          peru: "#cd853f",
          pink: "#ffc0cb",
          plum: "#dda0dd",
          powderblue: "#b0e0e6",
          purple: "#800080",
          purple2: "#7f007f",
          purple3: "#a020f0",
          rebeccapurple: "#663399",
          red: "#ff0000",
          rosybrown: "#bc8f8f",
          royalblue: "#4169e1",
          saddlebrown: "#8b4513",
          salmon: "#fa8072",
          sandybrown: "#f4a460",
          seagreen: "#2e8b57",
          seashell: "#fff5ee",
          sienna: "#a0522d",
          silver: "#c0c0c0",
          skyblue: "#87ceeb",
          slateblue: "#6a5acd",
          slategray: "#708090",
          slategrey: "#708090",
          snow: "#fffafa",
          springgreen: "#00ff7f",
          steelblue: "#4682b4",
          tan: "#d2b48c",
          teal: "#008080",
          thistle: "#d8bfd8",
          tomato: "#ff6347",
          turquoise: "#40e0d0",
          violet: "#ee82ee",
          wheat: "#f5deb3",
          white: "#ffffff",
          whitesmoke: "#f5f5f5",
          yellow: "#ffff00",
          yellowgreen: "#9acd32"
        };
        var w3cx11_1 = w3cx11$1;
        var Color$s = Color_1;
        var input$5 = input$h;
        var type$c = utils.type;
        var w3cx11 = w3cx11_1;
        var hex2rgb = hex2rgb_1;
        var rgb2hex = rgb2hex_1;
        Color$s.prototype.name = function() {
          var hex = rgb2hex(this._rgb, "rgb");
          for (var i2 = 0, list2 = Object.keys(w3cx11); i2 < list2.length; i2 += 1) {
            var n = list2[i2];
            if (w3cx11[n] === hex) {
              return n.toLowerCase();
            }
          }
          return hex;
        };
        input$5.format.named = function(name2) {
          name2 = name2.toLowerCase();
          if (w3cx11[name2]) {
            return hex2rgb(w3cx11[name2]);
          }
          throw new Error("unknown color name: " + name2);
        };
        input$5.autodetect.push({
          p: 5,
          test: function(h) {
            var rest = [], len = arguments.length - 1;
            while (len-- > 0)
              rest[len] = arguments[len + 1];
            if (!rest.length && type$c(h) === "string" && w3cx11[h.toLowerCase()]) {
              return "named";
            }
          }
        });
        var unpack$8 = utils.unpack;
        var rgb2num$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$8(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          return (r << 16) + (g << 8) + b;
        };
        var rgb2num_1 = rgb2num$1;
        var type$b = utils.type;
        var num2rgb = function(num2) {
          if (type$b(num2) == "number" && num2 >= 0 && num2 <= 16777215) {
            var r = num2 >> 16;
            var g = num2 >> 8 & 255;
            var b = num2 & 255;
            return [r, g, b, 1];
          }
          throw new Error("unknown num color: " + num2);
        };
        var num2rgb_1 = num2rgb;
        var chroma$9 = chroma_1;
        var Color$r = Color_1;
        var input$4 = input$h;
        var type$a = utils.type;
        var rgb2num = rgb2num_1;
        Color$r.prototype.num = function() {
          return rgb2num(this._rgb);
        };
        chroma$9.num = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$r, [null].concat(args, ["num"])))();
        };
        input$4.format.num = num2rgb_1;
        input$4.autodetect.push({
          p: 5,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            if (args.length === 1 && type$a(args[0]) === "number" && args[0] >= 0 && args[0] <= 16777215) {
              return "num";
            }
          }
        });
        var chroma$8 = chroma_1;
        var Color$q = Color_1;
        var input$3 = input$h;
        var unpack$7 = utils.unpack;
        var type$9 = utils.type;
        var round$1 = Math.round;
        Color$q.prototype.rgb = function(rnd2) {
          if (rnd2 === void 0)
            rnd2 = true;
          if (rnd2 === false) {
            return this._rgb.slice(0, 3);
          }
          return this._rgb.slice(0, 3).map(round$1);
        };
        Color$q.prototype.rgba = function(rnd2) {
          if (rnd2 === void 0)
            rnd2 = true;
          return this._rgb.slice(0, 4).map(function(v, i2) {
            return i2 < 3 ? rnd2 === false ? v : round$1(v) : v;
          });
        };
        chroma$8.rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$q, [null].concat(args, ["rgb"])))();
        };
        input$3.format.rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var rgba = unpack$7(args, "rgba");
          if (rgba[3] === void 0) {
            rgba[3] = 1;
          }
          return rgba;
        };
        input$3.autodetect.push({
          p: 3,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$7(args, "rgba");
            if (type$9(args) === "array" && (args.length === 3 || args.length === 4 && type$9(args[3]) == "number" && args[3] >= 0 && args[3] <= 1)) {
              return "rgb";
            }
          }
        });
        var log$1 = Math.log;
        var temperature2rgb$1 = function(kelvin) {
          var temp2 = kelvin / 100;
          var r, g, b;
          if (temp2 < 66) {
            r = 255;
            g = temp2 < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp2 - 2) + 104.49216199393888 * log$1(g);
            b = temp2 < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp2 - 10) + 115.67994401066147 * log$1(b);
          } else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp2 - 55) - 40.25366309332127 * log$1(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp2 - 50) - 28.0852963507957 * log$1(g);
            b = 255;
          }
          return [r, g, b, 1];
        };
        var temperature2rgb_1 = temperature2rgb$1;
        var temperature2rgb = temperature2rgb_1;
        var unpack$6 = utils.unpack;
        var round2 = Math.round;
        var rgb2temperature$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var rgb2 = unpack$6(args, "rgb");
          var r = rgb2[0], b = rgb2[2];
          var minTemp = 1e3;
          var maxTemp = 4e4;
          var eps = 0.4;
          var temp2;
          while (maxTemp - minTemp > eps) {
            temp2 = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb(temp2);
            if (rgb$1[2] / rgb$1[0] >= b / r) {
              maxTemp = temp2;
            } else {
              minTemp = temp2;
            }
          }
          return round2(temp2);
        };
        var rgb2temperature_1 = rgb2temperature$1;
        var chroma$7 = chroma_1;
        var Color$p = Color_1;
        var input$2 = input$h;
        var rgb2temperature = rgb2temperature_1;
        Color$p.prototype.temp = Color$p.prototype.kelvin = Color$p.prototype.temperature = function() {
          return rgb2temperature(this._rgb);
        };
        chroma$7.temp = chroma$7.kelvin = chroma$7.temperature = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$p, [null].concat(args, ["temp"])))();
        };
        input$2.format.temp = input$2.format.kelvin = input$2.format.temperature = temperature2rgb_1;
        var unpack$5 = utils.unpack;
        var cbrt = Math.cbrt;
        var pow$8 = Math.pow;
        var sign$1 = Math.sign;
        var rgb2oklab$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$5(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var ref$1 = [rgb2lrgb(r / 255), rgb2lrgb(g / 255), rgb2lrgb(b / 255)];
          var lr = ref$1[0];
          var lg = ref$1[1];
          var lb = ref$1[2];
          var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
          var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
          var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);
          return [
            0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
            1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
            0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
          ];
        };
        var rgb2oklab_1 = rgb2oklab$2;
        function rgb2lrgb(c) {
          var abs3 = Math.abs(c);
          if (abs3 < 0.04045) {
            return c / 12.92;
          }
          return (sign$1(c) || 1) * pow$8((abs3 + 0.055) / 1.055, 2.4);
        }
        var unpack$4 = utils.unpack;
        var pow$7 = Math.pow;
        var sign2 = Math.sign;
        var oklab2rgb$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$4(args, "lab");
          var L3 = args[0];
          var a = args[1];
          var b = args[2];
          var l = pow$7(L3 + 0.3963377774 * a + 0.2158037573 * b, 3);
          var m = pow$7(L3 - 0.1055613458 * a - 0.0638541728 * b, 3);
          var s = pow$7(L3 - 0.0894841775 * a - 1.291485548 * b, 3);
          return [
            255 * lrgb2rgb(4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
            255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
            255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
            args.length > 3 ? args[3] : 1
          ];
        };
        var oklab2rgb_1 = oklab2rgb$1;
        function lrgb2rgb(c) {
          var abs3 = Math.abs(c);
          if (abs3 > 31308e-7) {
            return (sign2(c) || 1) * (1.055 * pow$7(abs3, 1 / 2.4) - 0.055);
          }
          return c * 12.92;
        }
        var unpack$3 = utils.unpack;
        var type$8 = utils.type;
        var chroma$6 = chroma_1;
        var Color$o = Color_1;
        var input$1 = input$h;
        var rgb2oklab$1 = rgb2oklab_1;
        Color$o.prototype.oklab = function() {
          return rgb2oklab$1(this._rgb);
        };
        chroma$6.oklab = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$o, [null].concat(args, ["oklab"])))();
        };
        input$1.format.oklab = oklab2rgb_1;
        input$1.autodetect.push({
          p: 3,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$3(args, "oklab");
            if (type$8(args) === "array" && args.length === 3) {
              return "oklab";
            }
          }
        });
        var unpack$2 = utils.unpack;
        var rgb2oklab = rgb2oklab_1;
        var lab2lch = lab2lch_1;
        var rgb2oklch$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$2(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var ref$1 = rgb2oklab(r, g, b);
          var l = ref$1[0];
          var a = ref$1[1];
          var b_ = ref$1[2];
          return lab2lch(l, a, b_);
        };
        var rgb2oklch_1 = rgb2oklch$1;
        var unpack$1 = utils.unpack;
        var lch2lab = lch2lab_1;
        var oklab2rgb = oklab2rgb_1;
        var oklch2rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$1(args, "lch");
          var l = args[0];
          var c = args[1];
          var h = args[2];
          var ref = lch2lab(l, c, h);
          var L3 = ref[0];
          var a = ref[1];
          var b_ = ref[2];
          var ref$1 = oklab2rgb(L3, a, b_);
          var r = ref$1[0];
          var g = ref$1[1];
          var b = ref$1[2];
          return [r, g, b, args.length > 3 ? args[3] : 1];
        };
        var oklch2rgb_1 = oklch2rgb;
        var unpack = utils.unpack;
        var type$7 = utils.type;
        var chroma$5 = chroma_1;
        var Color$n = Color_1;
        var input = input$h;
        var rgb2oklch = rgb2oklch_1;
        Color$n.prototype.oklch = function() {
          return rgb2oklch(this._rgb);
        };
        chroma$5.oklch = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$n, [null].concat(args, ["oklch"])))();
        };
        input.format.oklch = oklch2rgb_1;
        input.autodetect.push({
          p: 3,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack(args, "oklch");
            if (type$7(args) === "array" && args.length === 3) {
              return "oklch";
            }
          }
        });
        var Color$m = Color_1;
        var type$6 = utils.type;
        Color$m.prototype.alpha = function(a, mutate) {
          if (mutate === void 0)
            mutate = false;
          if (a !== void 0 && type$6(a) === "number") {
            if (mutate) {
              this._rgb[3] = a;
              return this;
            }
            return new Color$m([this._rgb[0], this._rgb[1], this._rgb[2], a], "rgb");
          }
          return this._rgb[3];
        };
        var Color$l = Color_1;
        Color$l.prototype.clipped = function() {
          return this._rgb._clipped || false;
        };
        var Color$k = Color_1;
        var LAB_CONSTANTS$1 = labConstants;
        Color$k.prototype.darken = function(amount) {
          if (amount === void 0)
            amount = 1;
          var me = this;
          var lab2 = me.lab();
          lab2[0] -= LAB_CONSTANTS$1.Kn * amount;
          return new Color$k(lab2, "lab").alpha(me.alpha(), true);
        };
        Color$k.prototype.brighten = function(amount) {
          if (amount === void 0)
            amount = 1;
          return this.darken(-amount);
        };
        Color$k.prototype.darker = Color$k.prototype.darken;
        Color$k.prototype.brighter = Color$k.prototype.brighten;
        var Color$j = Color_1;
        Color$j.prototype.get = function(mc) {
          var ref = mc.split(".");
          var mode = ref[0];
          var channel = ref[1];
          var src = this[mode]();
          if (channel) {
            var i2 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
            if (i2 > -1) {
              return src[i2];
            }
            throw new Error("unknown channel " + channel + " in mode " + mode);
          } else {
            return src;
          }
        };
        var Color$i = Color_1;
        var type$5 = utils.type;
        var pow$6 = Math.pow;
        var EPS = 1e-7;
        var MAX_ITER = 20;
        Color$i.prototype.luminance = function(lum) {
          if (lum !== void 0 && type$5(lum) === "number") {
            if (lum === 0) {
              return new Color$i([0, 0, 0, this._rgb[3]], "rgb");
            }
            if (lum === 1) {
              return new Color$i([255, 255, 255, this._rgb[3]], "rgb");
            }
            var cur_lum = this.luminance();
            var mode = "rgb";
            var max_iter = MAX_ITER;
            var test = function(low, high) {
              var mid = low.interpolate(high, 0.5, mode);
              var lm = mid.luminance();
              if (Math.abs(lum - lm) < EPS || !max_iter--) {
                return mid;
              }
              return lm > lum ? test(low, mid) : test(mid, high);
            };
            var rgb2 = (cur_lum > lum ? test(new Color$i([0, 0, 0]), this) : test(this, new Color$i([255, 255, 255]))).rgb();
            return new Color$i(rgb2.concat([this._rgb[3]]));
          }
          return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));
        };
        var rgb2luminance = function(r, g, b) {
          r = luminance_x(r);
          g = luminance_x(g);
          b = luminance_x(b);
          return 0.2126 * r + 0.7152 * g + 0.0722 * b;
        };
        var luminance_x = function(x2) {
          x2 /= 255;
          return x2 <= 0.03928 ? x2 / 12.92 : pow$6((x2 + 0.055) / 1.055, 2.4);
        };
        var interpolator$1 = {};
        var Color$h = Color_1;
        var type$4 = utils.type;
        var interpolator = interpolator$1;
        var mix$1 = function(col1, col2, f) {
          if (f === void 0)
            f = 0.5;
          var rest = [], len = arguments.length - 3;
          while (len-- > 0)
            rest[len] = arguments[len + 3];
          var mode = rest[0] || "lrgb";
          if (!interpolator[mode] && !rest.length) {
            mode = Object.keys(interpolator)[0];
          }
          if (!interpolator[mode]) {
            throw new Error("interpolation mode " + mode + " is not defined");
          }
          if (type$4(col1) !== "object") {
            col1 = new Color$h(col1);
          }
          if (type$4(col2) !== "object") {
            col2 = new Color$h(col2);
          }
          return interpolator[mode](col1, col2, f).alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
        };
        var Color$g = Color_1;
        var mix = mix$1;
        Color$g.prototype.mix = Color$g.prototype.interpolate = function(col2, f) {
          if (f === void 0)
            f = 0.5;
          var rest = [], len = arguments.length - 2;
          while (len-- > 0)
            rest[len] = arguments[len + 2];
          return mix.apply(void 0, [this, col2, f].concat(rest));
        };
        var Color$f = Color_1;
        Color$f.prototype.premultiply = function(mutate) {
          if (mutate === void 0)
            mutate = false;
          var rgb2 = this._rgb;
          var a = rgb2[3];
          if (mutate) {
            this._rgb = [rgb2[0] * a, rgb2[1] * a, rgb2[2] * a, a];
            return this;
          } else {
            return new Color$f([rgb2[0] * a, rgb2[1] * a, rgb2[2] * a, a], "rgb");
          }
        };
        var Color$e = Color_1;
        var LAB_CONSTANTS = labConstants;
        Color$e.prototype.saturate = function(amount) {
          if (amount === void 0)
            amount = 1;
          var me = this;
          var lch2 = me.lch();
          lch2[1] += LAB_CONSTANTS.Kn * amount;
          if (lch2[1] < 0) {
            lch2[1] = 0;
          }
          return new Color$e(lch2, "lch").alpha(me.alpha(), true);
        };
        Color$e.prototype.desaturate = function(amount) {
          if (amount === void 0)
            amount = 1;
          return this.saturate(-amount);
        };
        var Color$d = Color_1;
        var type$3 = utils.type;
        Color$d.prototype.set = function(mc, value, mutate) {
          if (mutate === void 0)
            mutate = false;
          var ref = mc.split(".");
          var mode = ref[0];
          var channel = ref[1];
          var src = this[mode]();
          if (channel) {
            var i2 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
            if (i2 > -1) {
              if (type$3(value) == "string") {
                switch (value.charAt(0)) {
                  case "+":
                    src[i2] += +value;
                    break;
                  case "-":
                    src[i2] += +value;
                    break;
                  case "*":
                    src[i2] *= +value.substr(1);
                    break;
                  case "/":
                    src[i2] /= +value.substr(1);
                    break;
                  default:
                    src[i2] = +value;
                }
              } else if (type$3(value) === "number") {
                src[i2] = value;
              } else {
                throw new Error("unsupported value for Color.set");
              }
              var out = new Color$d(src, mode);
              if (mutate) {
                this._rgb = out._rgb;
                return this;
              }
              return out;
            }
            throw new Error("unknown channel " + channel + " in mode " + mode);
          } else {
            return src;
          }
        };
        var Color$c = Color_1;
        var rgb = function(col1, col2, f) {
          var xyz0 = col1._rgb;
          var xyz1 = col2._rgb;
          return new Color$c(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            "rgb"
          );
        };
        interpolator$1.rgb = rgb;
        var Color$b = Color_1;
        var sqrt$2 = Math.sqrt;
        var pow$5 = Math.pow;
        var lrgb = function(col1, col2, f) {
          var ref = col1._rgb;
          var x12 = ref[0];
          var y1 = ref[1];
          var z1 = ref[2];
          var ref$1 = col2._rgb;
          var x2 = ref$1[0];
          var y2 = ref$1[1];
          var z2 = ref$1[2];
          return new Color$b(
            sqrt$2(pow$5(x12, 2) * (1 - f) + pow$5(x2, 2) * f),
            sqrt$2(pow$5(y1, 2) * (1 - f) + pow$5(y2, 2) * f),
            sqrt$2(pow$5(z1, 2) * (1 - f) + pow$5(z2, 2) * f),
            "rgb"
          );
        };
        interpolator$1.lrgb = lrgb;
        var Color$a = Color_1;
        var lab = function(col1, col2, f) {
          var xyz0 = col1.lab();
          var xyz1 = col2.lab();
          return new Color$a(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            "lab"
          );
        };
        interpolator$1.lab = lab;
        var Color$9 = Color_1;
        var _hsx = function(col1, col2, f, m) {
          var assign, assign$1;
          var xyz0, xyz1;
          if (m === "hsl") {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
          } else if (m === "hsv") {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
          } else if (m === "hcg") {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
          } else if (m === "hsi") {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
          } else if (m === "lch" || m === "hcl") {
            m = "hcl";
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
          } else if (m === "oklch") {
            xyz0 = col1.oklch().reverse();
            xyz1 = col2.oklch().reverse();
          }
          var hue0, hue1, sat0, sat1, lbv0, lbv1;
          if (m.substr(0, 1) === "h" || m === "oklch") {
            assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2];
            assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2];
          }
          var sat, hue, lbv, dh;
          if (!isNaN(hue0) && !isNaN(hue1)) {
            if (hue1 > hue0 && hue1 - hue0 > 180) {
              dh = hue1 - (hue0 + 360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
              dh = hue1 + 360 - hue0;
            } else {
              dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
          } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != "hsv") {
              sat = sat0;
            }
          } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != "hsv") {
              sat = sat1;
            }
          } else {
            hue = Number.NaN;
          }
          if (sat === void 0) {
            sat = sat0 + f * (sat1 - sat0);
          }
          lbv = lbv0 + f * (lbv1 - lbv0);
          return m === "oklch" ? new Color$9([lbv, sat, hue], m) : new Color$9([hue, sat, lbv], m);
        };
        var interpolate_hsx$5 = _hsx;
        var lch = function(col1, col2, f) {
          return interpolate_hsx$5(col1, col2, f, "lch");
        };
        interpolator$1.lch = lch;
        interpolator$1.hcl = lch;
        var Color$8 = Color_1;
        var num = function(col1, col2, f) {
          var c1 = col1.num();
          var c2 = col2.num();
          return new Color$8(c1 + f * (c2 - c1), "num");
        };
        interpolator$1.num = num;
        var interpolate_hsx$4 = _hsx;
        var hcg = function(col1, col2, f) {
          return interpolate_hsx$4(col1, col2, f, "hcg");
        };
        interpolator$1.hcg = hcg;
        var interpolate_hsx$3 = _hsx;
        var hsi = function(col1, col2, f) {
          return interpolate_hsx$3(col1, col2, f, "hsi");
        };
        interpolator$1.hsi = hsi;
        var interpolate_hsx$2 = _hsx;
        var hsl = function(col1, col2, f) {
          return interpolate_hsx$2(col1, col2, f, "hsl");
        };
        interpolator$1.hsl = hsl;
        var interpolate_hsx$1 = _hsx;
        var hsv = function(col1, col2, f) {
          return interpolate_hsx$1(col1, col2, f, "hsv");
        };
        interpolator$1.hsv = hsv;
        var Color$7 = Color_1;
        var oklab = function(col1, col2, f) {
          var xyz0 = col1.oklab();
          var xyz1 = col2.oklab();
          return new Color$7(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            "oklab"
          );
        };
        interpolator$1.oklab = oklab;
        var interpolate_hsx = _hsx;
        var oklch = function(col1, col2, f) {
          return interpolate_hsx(col1, col2, f, "oklch");
        };
        interpolator$1.oklch = oklch;
        var Color$6 = Color_1;
        var clip_rgb$1 = utils.clip_rgb;
        var pow$4 = Math.pow;
        var sqrt$1 = Math.sqrt;
        var PI$1 = Math.PI;
        var cos$2 = Math.cos;
        var sin$2 = Math.sin;
        var atan2$1 = Math.atan2;
        var average = function(colors, mode, weights) {
          if (mode === void 0)
            mode = "lrgb";
          if (weights === void 0)
            weights = null;
          var l = colors.length;
          if (!weights) {
            weights = Array.from(new Array(l)).map(function() {
              return 1;
            });
          }
          var k = l / weights.reduce(function(a, b) {
            return a + b;
          });
          weights.forEach(function(w, i3) {
            weights[i3] *= k;
          });
          colors = colors.map(function(c) {
            return new Color$6(c);
          });
          if (mode === "lrgb") {
            return _average_lrgb(colors, weights);
          }
          var first = colors.shift();
          var xyz = first.get(mode);
          var cnt = [];
          var dx = 0;
          var dy = 0;
          for (var i2 = 0; i2 < xyz.length; i2++) {
            xyz[i2] = (xyz[i2] || 0) * weights[0];
            cnt.push(isNaN(xyz[i2]) ? 0 : weights[0]);
            if (mode.charAt(i2) === "h" && !isNaN(xyz[i2])) {
              var A = xyz[i2] / 180 * PI$1;
              dx += cos$2(A) * weights[0];
              dy += sin$2(A) * weights[0];
            }
          }
          var alpha = first.alpha() * weights[0];
          colors.forEach(function(c, ci) {
            var xyz2 = c.get(mode);
            alpha += c.alpha() * weights[ci + 1];
            for (var i3 = 0; i3 < xyz.length; i3++) {
              if (!isNaN(xyz2[i3])) {
                cnt[i3] += weights[ci + 1];
                if (mode.charAt(i3) === "h") {
                  var A2 = xyz2[i3] / 180 * PI$1;
                  dx += cos$2(A2) * weights[ci + 1];
                  dy += sin$2(A2) * weights[ci + 1];
                } else {
                  xyz[i3] += xyz2[i3] * weights[ci + 1];
                }
              }
            }
          });
          for (var i$12 = 0; i$12 < xyz.length; i$12++) {
            if (mode.charAt(i$12) === "h") {
              var A$1 = atan2$1(dy / cnt[i$12], dx / cnt[i$12]) / PI$1 * 180;
              while (A$1 < 0) {
                A$1 += 360;
              }
              while (A$1 >= 360) {
                A$1 -= 360;
              }
              xyz[i$12] = A$1;
            } else {
              xyz[i$12] = xyz[i$12] / cnt[i$12];
            }
          }
          alpha /= l;
          return new Color$6(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);
        };
        var _average_lrgb = function(colors, weights) {
          var l = colors.length;
          var xyz = [0, 0, 0, 0];
          for (var i2 = 0; i2 < colors.length; i2++) {
            var col = colors[i2];
            var f = weights[i2] / l;
            var rgb2 = col._rgb;
            xyz[0] += pow$4(rgb2[0], 2) * f;
            xyz[1] += pow$4(rgb2[1], 2) * f;
            xyz[2] += pow$4(rgb2[2], 2) * f;
            xyz[3] += rgb2[3] * f;
          }
          xyz[0] = sqrt$1(xyz[0]);
          xyz[1] = sqrt$1(xyz[1]);
          xyz[2] = sqrt$1(xyz[2]);
          if (xyz[3] > 0.9999999) {
            xyz[3] = 1;
          }
          return new Color$6(clip_rgb$1(xyz));
        };
        var chroma$4 = chroma_1;
        var type$2 = utils.type;
        var pow$3 = Math.pow;
        var scale$2 = function(colors) {
          var _mode = "rgb";
          var _nacol = chroma$4("#ccc");
          var _spread = 0;
          var _domain = [0, 1];
          var _pos = [];
          var _padding = [0, 0];
          var _classes = false;
          var _colors = [];
          var _out = false;
          var _min = 0;
          var _max = 1;
          var _correctLightness = false;
          var _colorCache = {};
          var _useCache = true;
          var _gamma = 1;
          var setColors = function(colors2) {
            colors2 = colors2 || ["#fff", "#000"];
            if (colors2 && type$2(colors2) === "string" && chroma$4.brewer && chroma$4.brewer[colors2.toLowerCase()]) {
              colors2 = chroma$4.brewer[colors2.toLowerCase()];
            }
            if (type$2(colors2) === "array") {
              if (colors2.length === 1) {
                colors2 = [colors2[0], colors2[0]];
              }
              colors2 = colors2.slice(0);
              for (var c = 0; c < colors2.length; c++) {
                colors2[c] = chroma$4(colors2[c]);
              }
              _pos.length = 0;
              for (var c$1 = 0; c$1 < colors2.length; c$1++) {
                _pos.push(c$1 / (colors2.length - 1));
              }
            }
            resetCache();
            return _colors = colors2;
          };
          var getClass = function(value) {
            if (_classes != null) {
              var n = _classes.length - 1;
              var i2 = 0;
              while (i2 < n && value >= _classes[i2]) {
                i2++;
              }
              return i2 - 1;
            }
            return 0;
          };
          var tMapLightness = function(t) {
            return t;
          };
          var tMapDomain = function(t) {
            return t;
          };
          var getColor = function(val, bypassMap) {
            var col, t;
            if (bypassMap == null) {
              bypassMap = false;
            }
            if (isNaN(val) || val === null) {
              return _nacol;
            }
            if (!bypassMap) {
              if (_classes && _classes.length > 2) {
                var c = getClass(val);
                t = c / (_classes.length - 2);
              } else if (_max !== _min) {
                t = (val - _min) / (_max - _min);
              } else {
                t = 1;
              }
            } else {
              t = val;
            }
            t = tMapDomain(t);
            if (!bypassMap) {
              t = tMapLightness(t);
            }
            if (_gamma !== 1) {
              t = pow$3(t, _gamma);
            }
            t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
            t = Math.min(1, Math.max(0, t));
            var k = Math.floor(t * 1e4);
            if (_useCache && _colorCache[k]) {
              col = _colorCache[k];
            } else {
              if (type$2(_colors) === "array") {
                for (var i2 = 0; i2 < _pos.length; i2++) {
                  var p = _pos[i2];
                  if (t <= p) {
                    col = _colors[i2];
                    break;
                  }
                  if (t >= p && i2 === _pos.length - 1) {
                    col = _colors[i2];
                    break;
                  }
                  if (t > p && t < _pos[i2 + 1]) {
                    t = (t - p) / (_pos[i2 + 1] - p);
                    col = chroma$4.interpolate(_colors[i2], _colors[i2 + 1], t, _mode);
                    break;
                  }
                }
              } else if (type$2(_colors) === "function") {
                col = _colors(t);
              }
              if (_useCache) {
                _colorCache[k] = col;
              }
            }
            return col;
          };
          var resetCache = function() {
            return _colorCache = {};
          };
          setColors(colors);
          var f = function(v) {
            var c = chroma$4(getColor(v));
            if (_out && c[_out]) {
              return c[_out]();
            } else {
              return c;
            }
          };
          f.classes = function(classes) {
            if (classes != null) {
              if (type$2(classes) === "array") {
                _classes = classes;
                _domain = [classes[0], classes[classes.length - 1]];
              } else {
                var d = chroma$4.analyze(_domain);
                if (classes === 0) {
                  _classes = [d.min, d.max];
                } else {
                  _classes = chroma$4.limits(d, "e", classes);
                }
              }
              return f;
            }
            return _classes;
          };
          f.domain = function(domain) {
            if (!arguments.length) {
              return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length - 1];
            _pos = [];
            var k = _colors.length;
            if (domain.length === k && _min !== _max) {
              for (var i2 = 0, list2 = Array.from(domain); i2 < list2.length; i2 += 1) {
                var d = list2[i2];
                _pos.push((d - _min) / (_max - _min));
              }
            } else {
              for (var c = 0; c < k; c++) {
                _pos.push(c / (k - 1));
              }
              if (domain.length > 2) {
                var tOut = domain.map(function(d2, i3) {
                  return i3 / (domain.length - 1);
                });
                var tBreaks = domain.map(function(d2) {
                  return (d2 - _min) / (_max - _min);
                });
                if (!tBreaks.every(function(val, i3) {
                  return tOut[i3] === val;
                })) {
                  tMapDomain = function(t) {
                    if (t <= 0 || t >= 1) {
                      return t;
                    }
                    var i3 = 0;
                    while (t >= tBreaks[i3 + 1]) {
                      i3++;
                    }
                    var f2 = (t - tBreaks[i3]) / (tBreaks[i3 + 1] - tBreaks[i3]);
                    var out = tOut[i3] + f2 * (tOut[i3 + 1] - tOut[i3]);
                    return out;
                  };
                }
              }
            }
            _domain = [_min, _max];
            return f;
          };
          f.mode = function(_m) {
            if (!arguments.length) {
              return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
          };
          f.range = function(colors2, _pos2) {
            setColors(colors2);
            return f;
          };
          f.out = function(_o) {
            _out = _o;
            return f;
          };
          f.spread = function(val) {
            if (!arguments.length) {
              return _spread;
            }
            _spread = val;
            return f;
          };
          f.correctLightness = function(v) {
            if (v == null) {
              v = true;
            }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
              tMapLightness = function(t) {
                var L0 = getColor(0, true).lab()[0];
                var L1 = getColor(1, true).lab()[0];
                var pol = L0 > L1;
                var L_actual = getColor(t, true).lab()[0];
                var L_ideal = L0 + (L1 - L0) * t;
                var L_diff = L_actual - L_ideal;
                var t0 = 0;
                var t1 = 1;
                var max_iter = 20;
                while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
                  (function() {
                    if (pol) {
                      L_diff *= -1;
                    }
                    if (L_diff < 0) {
                      t0 = t;
                      t += (t1 - t) * 0.5;
                    } else {
                      t1 = t;
                      t += (t0 - t) * 0.5;
                    }
                    L_actual = getColor(t, true).lab()[0];
                    return L_diff = L_actual - L_ideal;
                  })();
                }
                return t;
              };
            } else {
              tMapLightness = function(t) {
                return t;
              };
            }
            return f;
          };
          f.padding = function(p) {
            if (p != null) {
              if (type$2(p) === "number") {
                p = [p, p];
              }
              _padding = p;
              return f;
            } else {
              return _padding;
            }
          };
          f.colors = function(numColors, out) {
            if (arguments.length < 2) {
              out = "hex";
            }
            var result = [];
            if (arguments.length === 0) {
              result = _colors.slice(0);
            } else if (numColors === 1) {
              result = [f(0.5)];
            } else if (numColors > 1) {
              var dm = _domain[0];
              var dd = _domain[1] - dm;
              result = __range__(0, numColors, false).map(function(i3) {
                return f(dm + i3 / (numColors - 1) * dd);
              });
            } else {
              colors = [];
              var samples = [];
              if (_classes && _classes.length > 2) {
                for (var i2 = 1, end = _classes.length, asc = 1 <= end; asc ? i2 < end : i2 > end; asc ? i2++ : i2--) {
                  samples.push((_classes[i2 - 1] + _classes[i2]) * 0.5);
                }
              } else {
                samples = _domain;
              }
              result = samples.map(function(v) {
                return f(v);
              });
            }
            if (chroma$4[out]) {
              result = result.map(function(c) {
                return c[out]();
              });
            }
            return result;
          };
          f.cache = function(c) {
            if (c != null) {
              _useCache = c;
              return f;
            } else {
              return _useCache;
            }
          };
          f.gamma = function(g) {
            if (g != null) {
              _gamma = g;
              return f;
            } else {
              return _gamma;
            }
          };
          f.nodata = function(d) {
            if (d != null) {
              _nacol = chroma$4(d);
              return f;
            } else {
              return _nacol;
            }
          };
          return f;
        };
        function __range__(left, right, inclusive) {
          var range = [];
          var ascending = left < right;
          var end = !inclusive ? right : ascending ? right + 1 : right - 1;
          for (var i2 = left; ascending ? i2 < end : i2 > end; ascending ? i2++ : i2--) {
            range.push(i2);
          }
          return range;
        }
        var Color$5 = Color_1;
        var scale$1 = scale$2;
        var binom_row = function(n) {
          var row = [1, 1];
          for (var i2 = 1; i2 < n; i2++) {
            var newrow = [1];
            for (var j = 1; j <= row.length; j++) {
              newrow[j] = (row[j] || 0) + row[j - 1];
            }
            row = newrow;
          }
          return row;
        };
        var bezier2 = function(colors) {
          var assign, assign$1, assign$2;
          var I, lab0, lab1, lab2;
          colors = colors.map(function(c) {
            return new Color$5(c);
          });
          if (colors.length === 2) {
            assign = colors.map(function(c) {
              return c.lab();
            }), lab0 = assign[0], lab1 = assign[1];
            I = function(t) {
              var lab4 = [0, 1, 2].map(function(i2) {
                return lab0[i2] + t * (lab1[i2] - lab0[i2]);
              });
              return new Color$5(lab4, "lab");
            };
          } else if (colors.length === 3) {
            assign$1 = colors.map(function(c) {
              return c.lab();
            }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2];
            I = function(t) {
              var lab4 = [0, 1, 2].map(function(i2) {
                return (1 - t) * (1 - t) * lab0[i2] + 2 * (1 - t) * t * lab1[i2] + t * t * lab2[i2];
              });
              return new Color$5(lab4, "lab");
            };
          } else if (colors.length === 4) {
            var lab3;
            assign$2 = colors.map(function(c) {
              return c.lab();
            }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3];
            I = function(t) {
              var lab4 = [0, 1, 2].map(function(i2) {
                return (1 - t) * (1 - t) * (1 - t) * lab0[i2] + 3 * (1 - t) * (1 - t) * t * lab1[i2] + 3 * (1 - t) * t * t * lab2[i2] + t * t * t * lab3[i2];
              });
              return new Color$5(lab4, "lab");
            };
          } else if (colors.length >= 5) {
            var labs, row, n;
            labs = colors.map(function(c) {
              return c.lab();
            });
            n = colors.length - 1;
            row = binom_row(n);
            I = function(t) {
              var u = 1 - t;
              var lab4 = [0, 1, 2].map(function(i2) {
                return labs.reduce(function(sum2, el, j) {
                  return sum2 + row[j] * Math.pow(u, n - j) * Math.pow(t, j) * el[i2];
                }, 0);
              });
              return new Color$5(lab4, "lab");
            };
          } else {
            throw new RangeError("No point in running bezier with only one color.");
          }
          return I;
        };
        var bezier_1 = function(colors) {
          var f = bezier2(colors);
          f.scale = function() {
            return scale$1(f);
          };
          return f;
        };
        var chroma$3 = chroma_1;
        var blend = function(bottom, top, mode) {
          if (!blend[mode]) {
            throw new Error("unknown blend mode " + mode);
          }
          return blend[mode](bottom, top);
        };
        var blend_f = function(f) {
          return function(bottom, top) {
            var c0 = chroma$3(top).rgb();
            var c1 = chroma$3(bottom).rgb();
            return chroma$3.rgb(f(c0, c1));
          };
        };
        var each = function(f) {
          return function(c0, c1) {
            var out = [];
            out[0] = f(c0[0], c1[0]);
            out[1] = f(c0[1], c1[1]);
            out[2] = f(c0[2], c1[2]);
            return out;
          };
        };
        var normal = function(a) {
          return a;
        };
        var multiply = function(a, b) {
          return a * b / 255;
        };
        var darken = function(a, b) {
          return a > b ? b : a;
        };
        var lighten = function(a, b) {
          return a > b ? a : b;
        };
        var screen = function(a, b) {
          return 255 * (1 - (1 - a / 255) * (1 - b / 255));
        };
        var overlay = function(a, b) {
          return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
        };
        var burn = function(a, b) {
          return 255 * (1 - (1 - b / 255) / (a / 255));
        };
        var dodge = function(a, b) {
          if (a === 255) {
            return 255;
          }
          a = 255 * (b / 255) / (1 - a / 255);
          return a > 255 ? 255 : a;
        };
        blend.normal = blend_f(each(normal));
        blend.multiply = blend_f(each(multiply));
        blend.screen = blend_f(each(screen));
        blend.overlay = blend_f(each(overlay));
        blend.darken = blend_f(each(darken));
        blend.lighten = blend_f(each(lighten));
        blend.dodge = blend_f(each(dodge));
        blend.burn = blend_f(each(burn));
        var blend_1 = blend;
        var type$1 = utils.type;
        var clip_rgb = utils.clip_rgb;
        var TWOPI = utils.TWOPI;
        var pow$2 = Math.pow;
        var sin$1 = Math.sin;
        var cos$1 = Math.cos;
        var chroma$2 = chroma_1;
        var cubehelix = function(start, rotations, hue, gamma, lightness) {
          if (start === void 0)
            start = 300;
          if (rotations === void 0)
            rotations = -1.5;
          if (hue === void 0)
            hue = 1;
          if (gamma === void 0)
            gamma = 1;
          if (lightness === void 0)
            lightness = [0, 1];
          var dh = 0, dl;
          if (type$1(lightness) === "array") {
            dl = lightness[1] - lightness[0];
          } else {
            dl = 0;
            lightness = [lightness, lightness];
          }
          var f = function(fract) {
            var a = TWOPI * ((start + 120) / 360 + rotations * fract);
            var l = pow$2(lightness[0] + dl * fract, gamma);
            var h = dh !== 0 ? hue[0] + fract * dh : hue;
            var amp = h * l * (1 - l) / 2;
            var cos_a = cos$1(a);
            var sin_a = sin$1(a);
            var r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
            var g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
            var b = l + amp * (1.97294 * cos_a);
            return chroma$2(clip_rgb([r * 255, g * 255, b * 255, 1]));
          };
          f.start = function(s) {
            if (s == null) {
              return start;
            }
            start = s;
            return f;
          };
          f.rotations = function(r) {
            if (r == null) {
              return rotations;
            }
            rotations = r;
            return f;
          };
          f.gamma = function(g) {
            if (g == null) {
              return gamma;
            }
            gamma = g;
            return f;
          };
          f.hue = function(h) {
            if (h == null) {
              return hue;
            }
            hue = h;
            if (type$1(hue) === "array") {
              dh = hue[1] - hue[0];
              if (dh === 0) {
                hue = hue[1];
              }
            } else {
              dh = 0;
            }
            return f;
          };
          f.lightness = function(h) {
            if (h == null) {
              return lightness;
            }
            if (type$1(h) === "array") {
              lightness = h;
              dl = h[1] - h[0];
            } else {
              lightness = [h, h];
              dl = 0;
            }
            return f;
          };
          f.scale = function() {
            return chroma$2.scale(f);
          };
          f.hue(hue);
          return f;
        };
        var Color$4 = Color_1;
        var digits = "0123456789abcdef";
        var floor$1 = Math.floor;
        var random = Math.random;
        var random_1 = function() {
          var code = "#";
          for (var i2 = 0; i2 < 6; i2++) {
            code += digits.charAt(floor$1(random() * 16));
          }
          return new Color$4(code, "hex");
        };
        var type = type$p;
        var log2 = Math.log;
        var pow$1 = Math.pow;
        var floor = Math.floor;
        var abs$1 = Math.abs;
        var analyze = function(data, key2) {
          if (key2 === void 0)
            key2 = null;
          var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE * -1,
            sum: 0,
            values: [],
            count: 0
          };
          if (type(data) === "object") {
            data = Object.values(data);
          }
          data.forEach(function(val) {
            if (key2 && type(val) === "object") {
              val = val[key2];
            }
            if (val !== void 0 && val !== null && !isNaN(val)) {
              r.values.push(val);
              r.sum += val;
              if (val < r.min) {
                r.min = val;
              }
              if (val > r.max) {
                r.max = val;
              }
              r.count += 1;
            }
          });
          r.domain = [r.min, r.max];
          r.limits = function(mode, num2) {
            return limits(r, mode, num2);
          };
          return r;
        };
        var limits = function(data, mode, num2) {
          if (mode === void 0)
            mode = "equal";
          if (num2 === void 0)
            num2 = 7;
          if (type(data) == "array") {
            data = analyze(data);
          }
          var min2 = data.min;
          var max2 = data.max;
          var values = data.values.sort(function(a, b) {
            return a - b;
          });
          if (num2 === 1) {
            return [min2, max2];
          }
          var limits2 = [];
          if (mode.substr(0, 1) === "c") {
            limits2.push(min2);
            limits2.push(max2);
          }
          if (mode.substr(0, 1) === "e") {
            limits2.push(min2);
            for (var i2 = 1; i2 < num2; i2++) {
              limits2.push(min2 + i2 / num2 * (max2 - min2));
            }
            limits2.push(max2);
          } else if (mode.substr(0, 1) === "l") {
            if (min2 <= 0) {
              throw new Error("Logarithmic scales are only possible for values > 0");
            }
            var min_log = Math.LOG10E * log2(min2);
            var max_log = Math.LOG10E * log2(max2);
            limits2.push(min2);
            for (var i$12 = 1; i$12 < num2; i$12++) {
              limits2.push(pow$1(10, min_log + i$12 / num2 * (max_log - min_log)));
            }
            limits2.push(max2);
          } else if (mode.substr(0, 1) === "q") {
            limits2.push(min2);
            for (var i$2 = 1; i$2 < num2; i$2++) {
              var p = (values.length - 1) * i$2 / num2;
              var pb = floor(p);
              if (pb === p) {
                limits2.push(values[pb]);
              } else {
                var pr = p - pb;
                limits2.push(values[pb] * (1 - pr) + values[pb + 1] * pr);
              }
            }
            limits2.push(max2);
          } else if (mode.substr(0, 1) === "k") {
            var cluster;
            var n = values.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num2);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;
            centroids = [];
            centroids.push(min2);
            for (var i$3 = 1; i$3 < num2; i$3++) {
              centroids.push(min2 + i$3 / num2 * (max2 - min2));
            }
            centroids.push(max2);
            while (repeat) {
              for (var j = 0; j < num2; j++) {
                clusterSizes[j] = 0;
              }
              for (var i$4 = 0; i$4 < n; i$4++) {
                var value = values[i$4];
                var mindist = Number.MAX_VALUE;
                var best = void 0;
                for (var j$1 = 0; j$1 < num2; j$1++) {
                  var dist = abs$1(centroids[j$1] - value);
                  if (dist < mindist) {
                    mindist = dist;
                    best = j$1;
                  }
                  clusterSizes[best]++;
                  assignments[i$4] = best;
                }
              }
              var newCentroids = new Array(num2);
              for (var j$2 = 0; j$2 < num2; j$2++) {
                newCentroids[j$2] = null;
              }
              for (var i$5 = 0; i$5 < n; i$5++) {
                cluster = assignments[i$5];
                if (newCentroids[cluster] === null) {
                  newCentroids[cluster] = values[i$5];
                } else {
                  newCentroids[cluster] += values[i$5];
                }
              }
              for (var j$3 = 0; j$3 < num2; j$3++) {
                newCentroids[j$3] *= 1 / clusterSizes[j$3];
              }
              repeat = false;
              for (var j$4 = 0; j$4 < num2; j$4++) {
                if (newCentroids[j$4] !== centroids[j$4]) {
                  repeat = true;
                  break;
                }
              }
              centroids = newCentroids;
              nb_iters++;
              if (nb_iters > 200) {
                repeat = false;
              }
            }
            var kClusters = {};
            for (var j$5 = 0; j$5 < num2; j$5++) {
              kClusters[j$5] = [];
            }
            for (var i$6 = 0; i$6 < n; i$6++) {
              cluster = assignments[i$6];
              kClusters[cluster].push(values[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6 = 0; j$6 < num2; j$6++) {
              tmpKMeansBreaks.push(kClusters[j$6][0]);
              tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {
              return a - b;
            });
            limits2.push(tmpKMeansBreaks[0]);
            for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {
              var v = tmpKMeansBreaks[i$7];
              if (!isNaN(v) && limits2.indexOf(v) === -1) {
                limits2.push(v);
              }
            }
          }
          return limits2;
        };
        var analyze_1 = { analyze, limits };
        var Color$3 = Color_1;
        var contrast = function(a, b) {
          a = new Color$3(a);
          b = new Color$3(b);
          var l1 = a.luminance();
          var l2 = b.luminance();
          return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
        };
        var Color$2 = Color_1;
        var sqrt2 = Math.sqrt;
        var pow2 = Math.pow;
        var min = Math.min;
        var max = Math.max;
        var atan22 = Math.atan2;
        var abs2 = Math.abs;
        var cos2 = Math.cos;
        var sin2 = Math.sin;
        var exp2 = Math.exp;
        var PI = Math.PI;
        var deltaE = function(a, b, Kl, Kc, Kh) {
          if (Kl === void 0)
            Kl = 1;
          if (Kc === void 0)
            Kc = 1;
          if (Kh === void 0)
            Kh = 1;
          var rad2deg = function(rad2) {
            return 360 * rad2 / (2 * PI);
          };
          var deg2rad = function(deg) {
            return 2 * PI * deg / 360;
          };
          a = new Color$2(a);
          b = new Color$2(b);
          var ref = Array.from(a.lab());
          var L1 = ref[0];
          var a1 = ref[1];
          var b1 = ref[2];
          var ref$1 = Array.from(b.lab());
          var L22 = ref$1[0];
          var a2 = ref$1[1];
          var b2 = ref$1[2];
          var avgL = (L1 + L22) / 2;
          var C1 = sqrt2(pow2(a1, 2) + pow2(b1, 2));
          var C2 = sqrt2(pow2(a2, 2) + pow2(b2, 2));
          var avgC = (C1 + C2) / 2;
          var G = 0.5 * (1 - sqrt2(pow2(avgC, 7) / (pow2(avgC, 7) + pow2(25, 7))));
          var a1p = a1 * (1 + G);
          var a2p = a2 * (1 + G);
          var C1p = sqrt2(pow2(a1p, 2) + pow2(b1, 2));
          var C2p = sqrt2(pow2(a2p, 2) + pow2(b2, 2));
          var avgCp = (C1p + C2p) / 2;
          var arctan1 = rad2deg(atan22(b1, a1p));
          var arctan2 = rad2deg(atan22(b2, a2p));
          var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
          var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
          var avgHp = abs2(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
          var T = 1 - 0.17 * cos2(deg2rad(avgHp - 30)) + 0.24 * cos2(deg2rad(2 * avgHp)) + 0.32 * cos2(deg2rad(3 * avgHp + 6)) - 0.2 * cos2(deg2rad(4 * avgHp - 63));
          var deltaHp = h2p - h1p;
          deltaHp = abs2(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
          deltaHp = 2 * sqrt2(C1p * C2p) * sin2(deg2rad(deltaHp) / 2);
          var deltaL = L22 - L1;
          var deltaCp = C2p - C1p;
          var sl = 1 + 0.015 * pow2(avgL - 50, 2) / sqrt2(20 + pow2(avgL - 50, 2));
          var sc = 1 + 0.045 * avgCp;
          var sh = 1 + 0.015 * avgCp * T;
          var deltaTheta = 30 * exp2(-pow2((avgHp - 275) / 25, 2));
          var Rc = 2 * sqrt2(pow2(avgCp, 7) / (pow2(avgCp, 7) + pow2(25, 7)));
          var Rt = -Rc * sin2(2 * deg2rad(deltaTheta));
          var result = sqrt2(pow2(deltaL / (Kl * sl), 2) + pow2(deltaCp / (Kc * sc), 2) + pow2(deltaHp / (Kh * sh), 2) + Rt * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh)));
          return max(0, min(100, result));
        };
        var Color$1 = Color_1;
        var distance2 = function(a, b, mode) {
          if (mode === void 0)
            mode = "lab";
          a = new Color$1(a);
          b = new Color$1(b);
          var l1 = a.get(mode);
          var l2 = b.get(mode);
          var sum_sq = 0;
          for (var i2 in l1) {
            var d = (l1[i2] || 0) - (l2[i2] || 0);
            sum_sq += d * d;
          }
          return Math.sqrt(sum_sq);
        };
        var Color = Color_1;
        var valid = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          try {
            new (Function.prototype.bind.apply(Color, [null].concat(args)))();
            return true;
          } catch (e) {
            return false;
          }
        };
        var chroma$1 = chroma_1;
        var scale = scale$2;
        var scales = {
          cool: function cool() {
            return scale([chroma$1.hsl(180, 1, 0.9), chroma$1.hsl(250, 0.7, 0.4)]);
          },
          hot: function hot() {
            return scale(["#000", "#f00", "#ff0", "#fff"]).mode("rgb");
          }
        };
        var colorbrewer = {
          // sequential
          OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
          PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
          BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
          Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
          BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
          YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
          YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
          Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
          RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
          Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
          YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
          Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
          GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
          Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
          YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
          PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
          Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
          PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
          Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
          // diverging
          Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
          RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
          RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
          PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
          PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
          RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
          BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
          RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
          PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
          // qualitative
          Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
          Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
          Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
          Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
          Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
          Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
          Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
          Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
        };
        for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
          var key = list[i];
          colorbrewer[key.toLowerCase()] = colorbrewer[key];
        }
        var colorbrewer_1 = colorbrewer;
        var chroma2 = chroma_1;
        chroma2.average = average;
        chroma2.bezier = bezier_1;
        chroma2.blend = blend_1;
        chroma2.cubehelix = cubehelix;
        chroma2.mix = chroma2.interpolate = mix$1;
        chroma2.random = random_1;
        chroma2.scale = scale$2;
        chroma2.analyze = analyze_1.analyze;
        chroma2.contrast = contrast;
        chroma2.deltaE = deltaE;
        chroma2.distance = distance2;
        chroma2.limits = analyze_1.limits;
        chroma2.valid = valid;
        chroma2.scales = scales;
        chroma2.colors = w3cx11_1;
        chroma2.brewer = colorbrewer_1;
        var chroma_js = chroma2;
        return chroma_js;
      });
    }
  });

  // tracker.ts
  var L2 = __toESM(require_leaflet_src());

  // ../../../../../../../node_modules/@turf/helpers/dist/es/index.js
  var earthRadius = 63710088e-1;
  var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: earthRadius / 111325,
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
  };
  var unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1e3,
    kilometres: 1 / 1e3,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1e3,
    millimetres: 1e3,
    nauticalmiles: 1 / 1852,
    radians: 1 / earthRadius,
    yards: 1.0936133
  };
  function feature(geom, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
      feat.id = options.id;
    }
    if (options.bbox) {
      feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
  }
  function point(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (!coordinates) {
      throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
      throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
      throw new Error("coordinates must contain numbers");
    }
    var geom = {
      type: "Point",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function polygon(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
      var ring = coordinates_1[_i];
      if (ring.length < 4) {
        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      }
      for (var j = 0; j < ring[ring.length - 1].length; j++) {
        if (ring[ring.length - 1][j] !== ring[0][j]) {
          throw new Error("First and last Position are not equivalent.");
        }
      }
    }
    var geom = {
      type: "Polygon",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function lineString(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
      type: "LineString",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function featureCollection(features, options) {
    if (options === void 0) {
      options = {};
    }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
      fc.id = options.id;
    }
    if (options.bbox) {
      fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
  }
  function multiLineString(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = {
      type: "MultiLineString",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function multiPoint(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = {
      type: "MultiPoint",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function multiPolygon(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = {
      type: "MultiPolygon",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function radiansToLength(radians2, units) {
    if (units === void 0) {
      units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
      throw new Error(units + " units is invalid");
    }
    return radians2 * factor;
  }
  function lengthToRadians(distance2, units) {
    if (units === void 0) {
      units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
      throw new Error(units + " units is invalid");
    }
    return distance2 / factor;
  }
  function radiansToDegrees(radians2) {
    var degrees2 = radians2 % (2 * Math.PI);
    return degrees2 * 180 / Math.PI;
  }
  function degreesToRadians(degrees2) {
    var radians2 = degrees2 % 360;
    return radians2 * Math.PI / 180;
  }
  function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
  }
  function isObject(input) {
    return !!input && input.constructor === Object;
  }

  // ../../../../../../../node_modules/@turf/meta/dist/es/index.js
  function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null)
      return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null)
          continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j = 0; j < coords.length; j++) {
              if (callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint")
                multiFeatureIndex++;
            }
            if (geomType === "LineString")
              multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length - wrapShrink; k++) {
                if (callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString")
                multiFeatureIndex++;
              if (geomType === "Polygon")
                geometryIndex++;
            }
            if (geomType === "Polygon")
              multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j = 0; j < coords.length; j++) {
              geometryIndex = 0;
              for (k = 0; k < coords[j].length; k++) {
                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                  if (callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j = 0; j < geometry.geometries.length; j++)
              if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }
  function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(
      geojson,
      function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === void 0)
          previousValue = currentCoord;
        else
          previousValue = callback(
            previousValue,
            currentCoord,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          );
      },
      excludeWrapCoord
    );
    return previousValue;
  }
  function featureEach(geojson, callback) {
    if (geojson.type === "Feature") {
      callback(geojson, 0);
    } else if (geojson.type === "FeatureCollection") {
      for (var i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i], i) === false)
          break;
      }
    }
  }
  function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function(currentFeature, featureIndex) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentFeature;
      else
        previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
  }
  function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (i = 0; i < stop; i++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
      featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
      featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
      featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (g = 0; g < stopG; g++) {
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
        if (geometry === null) {
          if (callback(
            null,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          continue;
        }
        switch (geometry.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (callback(
              geometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
            break;
          }
          case "GeometryCollection": {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(
                geometry.geometries[j],
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
            }
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      featureIndex++;
    }
  }
  function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(
      geojson,
      function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === void 0)
          previousValue = currentGeometry;
        else
          previousValue = callback(
            previousValue,
            currentGeometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          );
      }
    );
    return previousValue;
  }
  function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox3, id) {
      var type = geometry === null ? null : geometry.type;
      switch (type) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          if (callback(
            feature(geometry, properties, { bbox: bbox3, id }),
            featureIndex,
            0
          ) === false)
            return false;
          return;
      }
      var geomType;
      switch (type) {
        case "MultiPoint":
          geomType = "Point";
          break;
        case "MultiLineString":
          geomType = "LineString";
          break;
        case "MultiPolygon":
          geomType = "Polygon";
          break;
      }
      for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
        var coordinate = geometry.coordinates[multiFeatureIndex];
        var geom = {
          type: geomType,
          coordinates: coordinate
        };
        if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
          return false;
      }
    });
  }

  // ../../../../../../../node_modules/@turf/bbox/dist/es/index.js
  function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, function(coord) {
      if (result[0] > coord[0]) {
        result[0] = coord[0];
      }
      if (result[1] > coord[1]) {
        result[1] = coord[1];
      }
      if (result[2] < coord[0]) {
        result[2] = coord[0];
      }
      if (result[3] < coord[1]) {
        result[3] = coord[1];
      }
    });
    return result;
  }
  bbox["default"] = bbox;
  var es_default = bbox;

  // ../../../../../../../node_modules/@turf/invariant/dist/es/index.js
  function getCoord(coord) {
    if (!coord) {
      throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
      if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
        return coord.geometry.coordinates;
      }
      if (coord.type === "Point") {
        return coord.coordinates;
      }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
      return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  function getCoords(coords) {
    if (Array.isArray(coords)) {
      return coords;
    }
    if (coords.type === "Feature") {
      if (coords.geometry !== null) {
        return coords.geometry.coordinates;
      }
    } else {
      if (coords.coordinates) {
        return coords.coordinates;
      }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
  }
  function featureOf(feature2, type, name) {
    if (!feature2) {
      throw new Error("No feature passed");
    }
    if (!name) {
      throw new Error(".featureOf() requires a name");
    }
    if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
      throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature2.geometry || feature2.geometry.type !== type) {
      throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
    }
  }
  function getGeom(geojson) {
    if (geojson.type === "Feature") {
      return geojson.geometry;
    }
    return geojson;
  }
  function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
      return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
      return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
      return geojson.geometry.type;
    }
    return geojson.type;
  }

  // ../../../../../../../node_modules/@turf/isolines/dist/es/index.js
  var import_object_assign = __toESM(require_object_assign(), 1);

  // ../../../../../../../node_modules/@turf/convex/dist/es/index.js
  var import_concaveman = __toESM(require_concaveman(), 1);

  // ../../../../../../../node_modules/@turf/boolean-point-in-polygon/dist/es/index.js
  function booleanPointInPolygon(point2, polygon2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!point2) {
      throw new Error("point is required");
    }
    if (!polygon2) {
      throw new Error("polygon is required");
    }
    var pt = getCoord(point2);
    var geom = getGeom(polygon2);
    var type = geom.type;
    var bbox3 = polygon2.bbox;
    var polys = geom.coordinates;
    if (bbox3 && inBBox(pt, bbox3) === false) {
      return false;
    }
    if (type === "Polygon") {
      polys = [polys];
    }
    var insidePoly = false;
    for (var i = 0; i < polys.length && !insidePoly; i++) {
      if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
        var inHole = false;
        var k = 1;
        while (k < polys[i].length && !inHole) {
          if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
            inHole = true;
          }
          k++;
        }
        if (!inHole) {
          insidePoly = true;
        }
      }
    }
    return insidePoly;
  }
  function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
      ring = ring.slice(0, ring.length - 1);
    }
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      var xi = ring[i][0];
      var yi = ring[i][1];
      var xj = ring[j][0];
      var yj = ring[j][1];
      var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
      if (onBoundary) {
        return !ignoreBoundary;
      }
      var intersect2 = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
      if (intersect2) {
        isInside = !isInside;
      }
    }
    return isInside;
  }
  function inBBox(pt, bbox3) {
    return bbox3[0] <= pt[0] && bbox3[1] <= pt[1] && bbox3[2] >= pt[0] && bbox3[3] >= pt[1];
  }

  // ../../../../../../../node_modules/@turf/distance/dist/es/index.js
  function distance(from, to, options) {
    if (options === void 0) {
      options = {};
    }
    var coordinates1 = getCoord(from);
    var coordinates2 = getCoord(to);
    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
    var lat1 = degreesToRadians(coordinates1[1]);
    var lat2 = degreesToRadians(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
  }
  var es_default2 = distance;

  // ../../../../../../../node_modules/@turf/tin/dist/es/index.js
  var Triangle = (
    /** @class */
    function() {
      function Triangle2(a, b, c) {
        this.a = a;
        this.b = b;
        this.c = c;
        var A = b.x - a.x;
        var B2 = b.y - a.y;
        var C = c.x - a.x;
        var D = c.y - a.y;
        var E = A * (a.x + b.x) + B2 * (a.y + b.y);
        var F = C * (a.x + c.x) + D * (a.y + c.y);
        var G = 2 * (A * (c.y - b.y) - B2 * (c.x - b.x));
        var dx;
        var dy;
        this.x = (D * E - B2 * F) / G;
        this.y = (A * F - C * E) / G;
        dx = this.x - a.x;
        dy = this.y - a.y;
        this.r = dx * dx + dy * dy;
      }
      return Triangle2;
    }()
  );

  // ../../../../../../../node_modules/@turf/clone/dist/es/index.js
  function clone(geojson) {
    if (!geojson) {
      throw new Error("geojson is required");
    }
    switch (geojson.type) {
      case "Feature":
        return cloneFeature(geojson);
      case "FeatureCollection":
        return cloneFeatureCollection(geojson);
      case "Point":
      case "LineString":
      case "Polygon":
      case "MultiPoint":
      case "MultiLineString":
      case "MultiPolygon":
      case "GeometryCollection":
        return cloneGeometry(geojson);
      default:
        throw new Error("unknown GeoJSON type");
    }
  }
  function cloneFeature(geojson) {
    var cloned = { type: "Feature" };
    Object.keys(geojson).forEach(function(key) {
      switch (key) {
        case "type":
        case "properties":
        case "geometry":
          return;
        default:
          cloned[key] = geojson[key];
      }
    });
    cloned.properties = cloneProperties(geojson.properties);
    cloned.geometry = cloneGeometry(geojson.geometry);
    return cloned;
  }
  function cloneProperties(properties) {
    var cloned = {};
    if (!properties) {
      return cloned;
    }
    Object.keys(properties).forEach(function(key) {
      var value = properties[key];
      if (typeof value === "object") {
        if (value === null) {
          cloned[key] = null;
        } else if (Array.isArray(value)) {
          cloned[key] = value.map(function(item) {
            return item;
          });
        } else {
          cloned[key] = cloneProperties(value);
        }
      } else {
        cloned[key] = value;
      }
    });
    return cloned;
  }
  function cloneFeatureCollection(geojson) {
    var cloned = { type: "FeatureCollection" };
    Object.keys(geojson).forEach(function(key) {
      switch (key) {
        case "type":
        case "features":
          return;
        default:
          cloned[key] = geojson[key];
      }
    });
    cloned.features = geojson.features.map(function(feature2) {
      return cloneFeature(feature2);
    });
    return cloned;
  }
  function cloneGeometry(geometry) {
    var geom = { type: geometry.type };
    if (geometry.bbox) {
      geom.bbox = geometry.bbox;
    }
    if (geometry.type === "GeometryCollection") {
      geom.geometries = geometry.geometries.map(function(g) {
        return cloneGeometry(g);
      });
      return geom;
    }
    geom.coordinates = deepSlice(geometry.coordinates);
    return geom;
  }
  function deepSlice(coords) {
    var cloned = coords;
    if (typeof cloned[0] !== "object") {
      return cloned.slice();
    }
    return cloned.map(function(coord) {
      return deepSlice(coord);
    });
  }
  var es_default3 = clone;

  // ../../../../../../../node_modules/topojson-server/src/hash/point-hash.js
  var buffer = new ArrayBuffer(16);
  var floats = new Float64Array(buffer);
  var uints = new Uint32Array(buffer);

  // ../../../../../../../node_modules/@turf/collect/dist/es/index.js
  var import_rbush = __toESM(require_rbush(), 1);

  // ../../../../../../../node_modules/@turf/flip/dist/es/index.js
  function flip(geojson, options) {
    options = options || {};
    if (!isObject(options))
      throw new Error("options is invalid");
    var mutate = options.mutate;
    if (!geojson)
      throw new Error("geojson is required");
    if (mutate === false || mutate === void 0)
      geojson = es_default3(geojson);
    coordEach(geojson, function(coord) {
      var x2 = coord[0];
      var y2 = coord[1];
      coord[0] = y2;
      coord[1] = x2;
    });
    return geojson;
  }
  var es_default4 = flip;

  // ../../../../../../../node_modules/@turf/bezier-spline/dist/es/lib/spline.js
  var Spline = (
    /** @class */
    function() {
      function Spline2(options) {
        this.points = options.points || [];
        this.duration = options.duration || 1e4;
        this.sharpness = options.sharpness || 0.85;
        this.centers = [];
        this.controls = [];
        this.stepLength = options.stepLength || 60;
        this.length = this.points.length;
        this.delay = 0;
        for (var i = 0; i < this.length; i++) {
          this.points[i].z = this.points[i].z || 0;
        }
        for (var i = 0; i < this.length - 1; i++) {
          var p1 = this.points[i];
          var p2 = this.points[i + 1];
          this.centers.push({
            x: (p1.x + p2.x) / 2,
            y: (p1.y + p2.y) / 2,
            z: (p1.z + p2.z) / 2
          });
        }
        this.controls.push([this.points[0], this.points[0]]);
        for (var i = 0; i < this.centers.length - 1; i++) {
          var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
          var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
          var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
          this.controls.push([
            {
              x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
              y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
              z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
            },
            {
              x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
              y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
              z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
            }
          ]);
        }
        this.controls.push([
          this.points[this.length - 1],
          this.points[this.length - 1]
        ]);
        this.steps = this.cacheSteps(this.stepLength);
        return this;
      }
      Spline2.prototype.cacheSteps = function(mindist) {
        var steps = [];
        var laststep = this.pos(0);
        steps.push(0);
        for (var t = 0; t < this.duration; t += 10) {
          var step = this.pos(t);
          var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
          if (dist > mindist) {
            steps.push(t);
            laststep = step;
          }
        }
        return steps;
      };
      Spline2.prototype.vector = function(t) {
        var p1 = this.pos(t + 10);
        var p2 = this.pos(t - 10);
        return {
          angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
          speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
        };
      };
      Spline2.prototype.pos = function(time) {
        var t = time - this.delay;
        if (t < 0) {
          t = 0;
        }
        if (t > this.duration) {
          t = this.duration - 1;
        }
        var t2 = t / this.duration;
        if (t2 >= 1) {
          return this.points[this.length - 1];
        }
        var n = Math.floor((this.points.length - 1) * t2);
        var t1 = (this.length - 1) * t2 - n;
        return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
      };
      return Spline2;
    }()
  );
  function bezier(t, p1, c1, c2, p2) {
    var b = B(t);
    var pos = {
      x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
      y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
      z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
    };
    return pos;
  }
  function B(t) {
    var t2 = t * t;
    var t3 = t2 * t;
    return [
      t3,
      3 * t2 * (1 - t),
      3 * t * (1 - t) * (1 - t),
      (1 - t) * (1 - t) * (1 - t)
    ];
  }

  // ../../../../../../../node_modules/@turf/bbox-polygon/dist/es/index.js
  function bboxPolygon(bbox3, options) {
    if (options === void 0) {
      options = {};
    }
    var west = Number(bbox3[0]);
    var south = Number(bbox3[1]);
    var east = Number(bbox3[2]);
    var north = Number(bbox3[3]);
    if (bbox3.length === 6) {
      throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
    }
    var lowLeft = [west, south];
    var topLeft = [west, north];
    var topRight = [east, north];
    var lowRight = [east, south];
    return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox3, id: options.id });
  }

  // ../../../../../../../node_modules/@turf/envelope/dist/es/index.js
  function envelope(geojson) {
    return bboxPolygon(es_default(geojson));
  }
  var es_default6 = envelope;

  // ../../../../../../../node_modules/@turf/destination/dist/es/index.js
  function destination(origin, distance2, bearing2, options) {
    if (options === void 0) {
      options = {};
    }
    var coordinates1 = getCoord(origin);
    var longitude1 = degreesToRadians(coordinates1[0]);
    var latitude1 = degreesToRadians(coordinates1[1]);
    var bearingRad = degreesToRadians(bearing2);
    var radians2 = lengthToRadians(distance2, options.units);
    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians2) + Math.cos(latitude1) * Math.sin(radians2) * Math.cos(bearingRad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians2) * Math.cos(latitude1), Math.cos(radians2) - Math.sin(latitude1) * Math.sin(latitude2));
    var lng = radiansToDegrees(longitude2);
    var lat = radiansToDegrees(latitude2);
    return point([lng, lat], options.properties);
  }

  // ../../../../../../../node_modules/@turf/circle/dist/es/index.js
  function circle(center2, radius, options) {
    if (options === void 0) {
      options = {};
    }
    var steps = options.steps || 64;
    var properties = options.properties ? options.properties : !Array.isArray(center2) && center2.type === "Feature" && center2.properties ? center2.properties : {};
    var coordinates = [];
    for (var i = 0; i < steps; i++) {
      coordinates.push(destination(center2, radius, i * -360 / steps, options).geometry.coordinates);
    }
    coordinates.push(coordinates[0]);
    return polygon([coordinates], properties);
  }
  var es_default7 = circle;

  // ../../../../../../../node_modules/@turf/center/dist/es/index.js
  function center(geojson, options) {
    if (options === void 0) {
      options = {};
    }
    var ext = es_default(geojson);
    var x2 = (ext[0] + ext[2]) / 2;
    var y2 = (ext[1] + ext[3]) / 2;
    return point([x2, y2], options.properties, options);
  }
  var es_default8 = center;

  // ../../../../../../../node_modules/@turf/tesselate/dist/es/index.js
  var import_earcut = __toESM(require_earcut(), 1);

  // ../../../../../../../node_modules/@turf/line-segment/dist/es/index.js
  function lineSegment(geojson) {
    if (!geojson) {
      throw new Error("geojson is required");
    }
    var results = [];
    flattenEach(geojson, function(feature2) {
      lineSegmentFeature(feature2, results);
    });
    return featureCollection(results);
  }
  function lineSegmentFeature(geojson, results) {
    var coords = [];
    var geometry = geojson.geometry;
    if (geometry !== null) {
      switch (geometry.type) {
        case "Polygon":
          coords = getCoords(geometry);
          break;
        case "LineString":
          coords = [getCoords(geometry)];
      }
      coords.forEach(function(coord) {
        var segments = createSegments(coord, geojson.properties);
        segments.forEach(function(segment) {
          segment.id = results.length;
          results.push(segment);
        });
      });
    }
  }
  function createSegments(coords, properties) {
    var segments = [];
    coords.reduce(function(previousCoords, currentCoords) {
      var segment = lineString([previousCoords, currentCoords], properties);
      segment.bbox = bbox2(previousCoords, currentCoords);
      segments.push(segment);
      return currentCoords;
    });
    return segments;
  }
  function bbox2(coords1, coords2) {
    var x12 = coords1[0];
    var y1 = coords1[1];
    var x2 = coords2[0];
    var y2 = coords2[1];
    var west = x12 < x2 ? x12 : x2;
    var south = y1 < y2 ? y1 : y2;
    var east = x12 > x2 ? x12 : x2;
    var north = y1 > y2 ? y1 : y2;
    return [west, south, east, north];
  }
  var es_default10 = lineSegment;

  // ../../../../../../../node_modules/@turf/line-intersect/dist/es/index.js
  var import_geojson_rbush = __toESM(require_geojson_rbush(), 1);
  function lineIntersect(line1, line2) {
    var unique = {};
    var results = [];
    if (line1.type === "LineString") {
      line1 = feature(line1);
    }
    if (line2.type === "LineString") {
      line2 = feature(line2);
    }
    if (line1.type === "Feature" && line2.type === "Feature" && line1.geometry !== null && line2.geometry !== null && line1.geometry.type === "LineString" && line2.geometry.type === "LineString" && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {
      var intersect2 = intersects(line1, line2);
      if (intersect2) {
        results.push(intersect2);
      }
      return featureCollection(results);
    }
    var tree = (0, import_geojson_rbush.default)();
    tree.load(es_default10(line2));
    featureEach(es_default10(line1), function(segment) {
      featureEach(tree.search(segment), function(match) {
        var intersect3 = intersects(segment, match);
        if (intersect3) {
          var key = getCoords(intersect3).join(",");
          if (!unique[key]) {
            unique[key] = true;
            results.push(intersect3);
          }
        }
      });
    });
    return featureCollection(results);
  }
  function intersects(line1, line2) {
    var coords1 = getCoords(line1);
    var coords2 = getCoords(line2);
    if (coords1.length !== 2) {
      throw new Error("<intersects> line1 must only contain 2 coordinates");
    }
    if (coords2.length !== 2) {
      throw new Error("<intersects> line2 must only contain 2 coordinates");
    }
    var x12 = coords1[0][0];
    var y1 = coords1[0][1];
    var x2 = coords1[1][0];
    var y2 = coords1[1][1];
    var x3 = coords2[0][0];
    var y3 = coords2[0][1];
    var x4 = coords2[1][0];
    var y4 = coords2[1][1];
    var denom = (y4 - y3) * (x2 - x12) - (x4 - x3) * (y2 - y1);
    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x12 - x3);
    var numeB = (x2 - x12) * (y1 - y3) - (y2 - y1) * (x12 - x3);
    if (denom === 0) {
      if (numeA === 0 && numeB === 0) {
        return null;
      }
      return null;
    }
    var uA = numeA / denom;
    var uB = numeB / denom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
      var x5 = x12 + uA * (x2 - x12);
      var y5 = y1 + uA * (y2 - y1);
      return point([x5, y5]);
    }
    return null;
  }
  var es_default11 = lineIntersect;

  // ../../../../../../../node_modules/@turf/nearest-point-to-line/dist/es/index.js
  var import_object_assign2 = __toESM(require_object_assign(), 1);

  // ../../../../../../../node_modules/@turf/area/dist/es/index.js
  var RADIUS = 6378137;
  function area(geojson) {
    return geomReduce(geojson, function(value, geom) {
      return value + calculateArea(geom);
    }, 0);
  }
  function calculateArea(geom) {
    var total = 0;
    var i;
    switch (geom.type) {
      case "Polygon":
        return polygonArea(geom.coordinates);
      case "MultiPolygon":
        for (i = 0; i < geom.coordinates.length; i++) {
          total += polygonArea(geom.coordinates[i]);
        }
        return total;
      case "Point":
      case "MultiPoint":
      case "LineString":
      case "MultiLineString":
        return 0;
    }
    return 0;
  }
  function polygonArea(coords) {
    var total = 0;
    if (coords && coords.length > 0) {
      total += Math.abs(ringArea(coords[0]));
      for (var i = 1; i < coords.length; i++) {
        total -= Math.abs(ringArea(coords[i]));
      }
    }
    return total;
  }
  function ringArea(coords) {
    var p1;
    var p2;
    var p3;
    var lowerIndex;
    var middleIndex;
    var upperIndex;
    var i;
    var total = 0;
    var coordsLength = coords.length;
    if (coordsLength > 2) {
      for (i = 0; i < coordsLength; i++) {
        if (i === coordsLength - 2) {
          lowerIndex = coordsLength - 2;
          middleIndex = coordsLength - 1;
          upperIndex = 0;
        } else if (i === coordsLength - 1) {
          lowerIndex = coordsLength - 1;
          middleIndex = 0;
          upperIndex = 1;
        } else {
          lowerIndex = i;
          middleIndex = i + 1;
          upperIndex = i + 2;
        }
        p1 = coords[lowerIndex];
        p2 = coords[middleIndex];
        p3 = coords[upperIndex];
        total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
      }
      total = total * RADIUS * RADIUS / 2;
    }
    return total;
  }
  function rad(num) {
    return num * Math.PI / 180;
  }

  // ../../../../../../../node_modules/@turf/boolean-point-on-line/dist/es/index.js
  function booleanPointOnLine(pt, line, options) {
    if (options === void 0) {
      options = {};
    }
    var ptCoords = getCoord(pt);
    var lineCoords = getCoords(line);
    for (var i = 0; i < lineCoords.length - 1; i++) {
      var ignoreBoundary = false;
      if (options.ignoreEndVertices) {
        if (i === 0) {
          ignoreBoundary = "start";
        }
        if (i === lineCoords.length - 2) {
          ignoreBoundary = "end";
        }
        if (i === 0 && i + 1 === lineCoords.length - 1) {
          ignoreBoundary = "both";
        }
      }
      if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === "undefined" ? null : options.epsilon)) {
        return true;
      }
    }
    return false;
  }
  function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon4) {
    var x2 = pt[0];
    var y2 = pt[1];
    var x12 = lineSegmentStart[0];
    var y1 = lineSegmentStart[1];
    var x22 = lineSegmentEnd[0];
    var y22 = lineSegmentEnd[1];
    var dxc = pt[0] - x12;
    var dyc = pt[1] - y1;
    var dxl = x22 - x12;
    var dyl = y22 - y1;
    var cross = dxc * dyl - dyc * dxl;
    if (epsilon4 !== null) {
      if (Math.abs(cross) > epsilon4) {
        return false;
      }
    } else if (cross !== 0) {
      return false;
    }
    if (!excludeBoundary) {
      if (Math.abs(dxl) >= Math.abs(dyl)) {
        return dxl > 0 ? x12 <= x2 && x2 <= x22 : x22 <= x2 && x2 <= x12;
      }
      return dyl > 0 ? y1 <= y2 && y2 <= y22 : y22 <= y2 && y2 <= y1;
    } else if (excludeBoundary === "start") {
      if (Math.abs(dxl) >= Math.abs(dyl)) {
        return dxl > 0 ? x12 < x2 && x2 <= x22 : x22 <= x2 && x2 < x12;
      }
      return dyl > 0 ? y1 < y2 && y2 <= y22 : y22 <= y2 && y2 < y1;
    } else if (excludeBoundary === "end") {
      if (Math.abs(dxl) >= Math.abs(dyl)) {
        return dxl > 0 ? x12 <= x2 && x2 < x22 : x22 < x2 && x2 <= x12;
      }
      return dyl > 0 ? y1 <= y2 && y2 < y22 : y22 < y2 && y2 <= y1;
    } else if (excludeBoundary === "both") {
      if (Math.abs(dxl) >= Math.abs(dyl)) {
        return dxl > 0 ? x12 < x2 && x2 < x22 : x22 < x2 && x2 < x12;
      }
      return dyl > 0 ? y1 < y2 && y2 < y22 : y22 < y2 && y2 < y1;
    }
    return false;
  }
  var es_default17 = booleanPointOnLine;

  // ../../../../../../../node_modules/@turf/boolean-within/dist/es/index.js
  function booleanWithin(feature1, feature2) {
    var geom1 = getGeom(feature1);
    var geom2 = getGeom(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch (type1) {
      case "Point":
        switch (type2) {
          case "MultiPoint":
            return isPointInMultiPoint(geom1, geom2);
          case "LineString":
            return es_default17(geom1, geom2, { ignoreEndVertices: true });
          case "Polygon":
          case "MultiPolygon":
            return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      case "MultiPoint":
        switch (type2) {
          case "MultiPoint":
            return isMultiPointInMultiPoint(geom1, geom2);
          case "LineString":
            return isMultiPointOnLine(geom1, geom2);
          case "Polygon":
          case "MultiPolygon":
            return isMultiPointInPoly(geom1, geom2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      case "LineString":
        switch (type2) {
          case "LineString":
            return isLineOnLine(geom1, geom2);
          case "Polygon":
          case "MultiPolygon":
            return isLineInPoly(geom1, geom2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      case "Polygon":
        switch (type2) {
          case "Polygon":
          case "MultiPolygon":
            return isPolyInPoly(geom1, geom2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      default:
        throw new Error("feature1 " + type1 + " geometry not supported");
    }
  }
  function isPointInMultiPoint(point2, multiPoint2) {
    var i;
    var output = false;
    for (i = 0; i < multiPoint2.coordinates.length; i++) {
      if (compareCoords(multiPoint2.coordinates[i], point2.coordinates)) {
        output = true;
        break;
      }
    }
    return output;
  }
  function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for (var i = 0; i < multiPoint1.coordinates.length; i++) {
      var anyMatch = false;
      for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {
        if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
          anyMatch = true;
        }
      }
      if (!anyMatch) {
        return false;
      }
    }
    return true;
  }
  function isMultiPointOnLine(multiPoint2, lineString2) {
    var foundInsidePoint = false;
    for (var i = 0; i < multiPoint2.coordinates.length; i++) {
      if (!es_default17(multiPoint2.coordinates[i], lineString2)) {
        return false;
      }
      if (!foundInsidePoint) {
        foundInsidePoint = es_default17(multiPoint2.coordinates[i], lineString2, { ignoreEndVertices: true });
      }
    }
    return foundInsidePoint;
  }
  function isMultiPointInPoly(multiPoint2, polygon2) {
    var output = true;
    var oneInside = false;
    var isInside = false;
    for (var i = 0; i < multiPoint2.coordinates.length; i++) {
      isInside = booleanPointInPolygon(multiPoint2.coordinates[1], polygon2);
      if (!isInside) {
        output = false;
        break;
      }
      if (!oneInside) {
        isInside = booleanPointInPolygon(multiPoint2.coordinates[1], polygon2, {
          ignoreBoundary: true
        });
      }
    }
    return output && isInside;
  }
  function isLineOnLine(lineString1, lineString2) {
    for (var i = 0; i < lineString1.coordinates.length; i++) {
      if (!es_default17(lineString1.coordinates[i], lineString2)) {
        return false;
      }
    }
    return true;
  }
  function isLineInPoly(linestring, polygon2) {
    var polyBbox = es_default(polygon2);
    var lineBbox = es_default(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
      return false;
    }
    var foundInsidePoint = false;
    for (var i = 0; i < linestring.coordinates.length - 1; i++) {
      if (!booleanPointInPolygon(linestring.coordinates[i], polygon2)) {
        return false;
      }
      if (!foundInsidePoint) {
        foundInsidePoint = booleanPointInPolygon(linestring.coordinates[i], polygon2, { ignoreBoundary: true });
      }
      if (!foundInsidePoint) {
        var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
        foundInsidePoint = booleanPointInPolygon(midpoint, polygon2, {
          ignoreBoundary: true
        });
      }
    }
    return foundInsidePoint;
  }
  function isPolyInPoly(geometry1, geometry2) {
    var poly1Bbox = es_default(geometry1);
    var poly2Bbox = es_default(geometry2);
    if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {
      return false;
    }
    for (var i = 0; i < geometry1.coordinates[0].length; i++) {
      if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {
        return false;
      }
    }
    return true;
  }
  function doBBoxOverlap(bbox1, bbox22) {
    if (bbox1[0] > bbox22[0])
      return false;
    if (bbox1[2] < bbox22[2])
      return false;
    if (bbox1[1] > bbox22[1])
      return false;
    if (bbox1[3] < bbox22[3])
      return false;
    return true;
  }
  function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
  }
  function getMidpoint(pair1, pair2) {
    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
  }
  var es_default18 = booleanWithin;

  // ../../../../../../../node_modules/@turf/unkink-polygon/dist/es/index.js
  var import_rbush2 = __toESM(require_rbush(), 1);

  // ../../../../../../../node_modules/@turf/great-circle/dist/es/index.js
  var D2R = Math.PI / 180;
  var R2D = 180 / Math.PI;
  var Coord = function(lon, lat) {
    this.lon = lon;
    this.lat = lat;
    this.x = D2R * lon;
    this.y = D2R * lat;
  };
  Coord.prototype.view = function() {
    return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
  };
  Coord.prototype.antipode = function() {
    var anti_lat = -1 * this.lat;
    var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
    return new Coord(anti_lon, anti_lat);
  };
  var LineString = function() {
    this.coords = [];
    this.length = 0;
  };
  LineString.prototype.move_to = function(coord) {
    this.length++;
    this.coords.push(coord);
  };
  var Arc = function(properties) {
    this.properties = properties || {};
    this.geometries = [];
  };
  Arc.prototype.json = function() {
    if (this.geometries.length <= 0) {
      return {
        geometry: { type: "LineString", coordinates: null },
        type: "Feature",
        properties: this.properties
      };
    } else if (this.geometries.length === 1) {
      return {
        geometry: { type: "LineString", coordinates: this.geometries[0].coords },
        type: "Feature",
        properties: this.properties
      };
    } else {
      var multiline = [];
      for (var i = 0; i < this.geometries.length; i++) {
        multiline.push(this.geometries[i].coords);
      }
      return {
        geometry: { type: "MultiLineString", coordinates: multiline },
        type: "Feature",
        properties: this.properties
      };
    }
  };
  Arc.prototype.wkt = function() {
    var wkt_string = "";
    var wkt = "LINESTRING(";
    var collect = function(c) {
      wkt += c[0] + " " + c[1] + ",";
    };
    for (var i = 0; i < this.geometries.length; i++) {
      if (this.geometries[i].coords.length === 0) {
        return "LINESTRING(empty)";
      } else {
        var coords = this.geometries[i].coords;
        coords.forEach(collect);
        wkt_string += wkt.substring(0, wkt.length - 1) + ")";
      }
    }
    return wkt_string;
  };
  var GreatCircle = function(start, end, properties) {
    if (!start || start.x === void 0 || start.y === void 0) {
      throw new Error(
        "GreatCircle constructor expects two args: start and end objects with x and y properties"
      );
    }
    if (!end || end.x === void 0 || end.y === void 0) {
      throw new Error(
        "GreatCircle constructor expects two args: start and end objects with x and y properties"
      );
    }
    this.start = new Coord(start.x, start.y);
    this.end = new Coord(end.x, end.y);
    this.properties = properties || {};
    var w = this.start.x - this.end.x;
    var h = this.start.y - this.end.y;
    var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
    this.g = 2 * Math.asin(Math.sqrt(z));
    if (this.g === Math.PI) {
      throw new Error(
        "it appears " + start.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
      );
    } else if (isNaN(this.g)) {
      throw new Error(
        "could not calculate great circle between " + start + " and " + end
      );
    }
  };
  GreatCircle.prototype.interpolate = function(f) {
    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
    var B2 = Math.sin(f * this.g) / Math.sin(this.g);
    var x2 = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B2 * Math.cos(this.end.y) * Math.cos(this.end.x);
    var y2 = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B2 * Math.cos(this.end.y) * Math.sin(this.end.x);
    var z = A * Math.sin(this.start.y) + B2 * Math.sin(this.end.y);
    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)));
    var lon = R2D * Math.atan2(y2, x2);
    return [lon, lat];
  };
  GreatCircle.prototype.Arc = function(npoints, options) {
    var first_pass = [];
    if (!npoints || npoints <= 2) {
      first_pass.push([this.start.lon, this.start.lat]);
      first_pass.push([this.end.lon, this.end.lat]);
    } else {
      var delta = 1 / (npoints - 1);
      for (var i = 0; i < npoints; ++i) {
        var step = delta * i;
        var pair2 = this.interpolate(step);
        first_pass.push(pair2);
      }
    }
    var bHasBigDiff = false;
    var dfMaxSmallDiffLong = 0;
    var dfDateLineOffset = options && options.offset ? options.offset : 10;
    var dfLeftBorderX = 180 - dfDateLineOffset;
    var dfRightBorderX = -180 + dfDateLineOffset;
    var dfDiffSpace = 360 - dfDateLineOffset;
    for (var j = 1; j < first_pass.length; ++j) {
      var dfPrevX = first_pass[j - 1][0];
      var dfX = first_pass[j][0];
      var dfDiffLong = Math.abs(dfX - dfPrevX);
      if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
        bHasBigDiff = true;
      } else if (dfDiffLong > dfMaxSmallDiffLong) {
        dfMaxSmallDiffLong = dfDiffLong;
      }
    }
    var poMulti = [];
    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
      var poNewLS = [];
      poMulti.push(poNewLS);
      for (var k = 0; k < first_pass.length; ++k) {
        var dfX0 = parseFloat(first_pass[k][0]);
        if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
          var dfX1 = parseFloat(first_pass[k - 1][0]);
          var dfY1 = parseFloat(first_pass[k - 1][1]);
          var dfX2 = parseFloat(first_pass[k][0]);
          var dfY2 = parseFloat(first_pass[k][1]);
          if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
            poNewLS.push([-180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
            poNewLS.push([180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          }
          if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
            var tmpX = dfX1;
            dfX1 = dfX2;
            dfX2 = tmpX;
            var tmpY = dfY1;
            dfY1 = dfY2;
            dfY2 = tmpY;
          }
          if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
            dfX2 += 360;
          }
          if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
            var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
            var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
              dfY
            ]);
            poNewLS = [];
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
              dfY
            ]);
            poMulti.push(poNewLS);
          } else {
            poNewLS = [];
            poMulti.push(poNewLS);
          }
          poNewLS.push([dfX0, first_pass[k][1]]);
        } else {
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
        }
      }
    } else {
      var poNewLS0 = [];
      poMulti.push(poNewLS0);
      for (var l = 0; l < first_pass.length; ++l) {
        poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
      }
    }
    var arc = new Arc(this.properties);
    for (var m = 0; m < poMulti.length; ++m) {
      var line = new LineString();
      arc.geometries.push(line);
      var points = poMulti[m];
      for (var j0 = 0; j0 < points.length; ++j0) {
        line.move_to(points[j0]);
      }
    }
    return arc;
  };

  // ../../../../../../../node_modules/@turf/line-split/dist/es/index.js
  var import_geojson_rbush2 = __toESM(require_geojson_rbush(), 1);

  // ../../../../../../../node_modules/@turf/polygon-to-line/dist/es/index.js
  function es_default22(poly, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = getGeom(poly);
    if (!options.properties && poly.type === "Feature") {
      options.properties = poly.properties;
    }
    switch (geom.type) {
      case "Polygon":
        return polygonToLine(geom, options);
      case "MultiPolygon":
        return multiPolygonToLine(geom, options);
      default:
        throw new Error("invalid poly");
    }
  }
  function polygonToLine(poly, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = getGeom(poly);
    var coords = geom.coordinates;
    var properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
    return coordsToLine(coords, properties);
  }
  function multiPolygonToLine(multiPoly, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = getGeom(multiPoly);
    var coords = geom.coordinates;
    var properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
    var lines = [];
    coords.forEach(function(coord) {
      lines.push(coordsToLine(coord, properties));
    });
    return featureCollection(lines);
  }
  function coordsToLine(coords, properties) {
    if (coords.length > 1) {
      return multiLineString(coords, properties);
    }
    return lineString(coords[0], properties);
  }

  // ../../../../../../../node_modules/@turf/line-overlap/dist/es/index.js
  var import_geojson_rbush3 = __toESM(require_geojson_rbush(), 1);
  var import_deep_equal = __toESM(require_deep_equal(), 1);

  // ../../../../../../../node_modules/@turf/isobands/dist/es/index.js
  var import_object_assign3 = __toESM(require_object_assign(), 1);
  var isoBandNextXTL = [];
  var isoBandNextYTL = [];
  var isoBandNextOTL = [];
  var isoBandNextXTR = [];
  var isoBandNextYTR = [];
  var isoBandNextOTR = [];
  var isoBandNextXRT = [];
  var isoBandNextYRT = [];
  var isoBandNextORT = [];
  var isoBandNextXRB = [];
  var isoBandNextYRB = [];
  var isoBandNextORB = [];
  var isoBandNextXBL = [];
  var isoBandNextYBL = [];
  var isoBandNextOBL = [];
  var isoBandNextXBR = [];
  var isoBandNextYBR = [];
  var isoBandNextOBR = [];
  var isoBandNextXLT = [];
  var isoBandNextYLT = [];
  var isoBandNextOLT = [];
  var isoBandNextXLB = [];
  var isoBandNextYLB = [];
  var isoBandNextOLB = [];
  isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
  isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
  isoBandNextORT[85] = isoBandNextORB[85] = 1;
  isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
  isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
  isoBandNextOLT[85] = isoBandNextOLB[85] = 1;
  isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
  isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
  isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
  isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
  isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
  isoBandNextOTR[85] = isoBandNextOBR[85] = 1;
  isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
  isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
  isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
  isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
  isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
  isoBandNextOBL[1] = isoBandNextOBL[169] = 0;
  isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
  isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
  isoBandNextORB[4] = isoBandNextORB[166] = 1;
  isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
  isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
  isoBandNextOBR[4] = isoBandNextOBR[166] = 0;
  isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
  isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
  isoBandNextORT[16] = isoBandNextORT[154] = 1;
  isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
  isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
  isoBandNextOTR[16] = isoBandNextOTR[154] = 1;
  isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
  isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
  isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
  isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
  isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
  isoBandNextOTL[64] = isoBandNextOTL[106] = 1;
  isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
  isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
  isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
  isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
  isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
  isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
  isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
  isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
  isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
  isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
  isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
  isoBandNextOBR[2] = isoBandNextOBR[168] = 1;
  isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
  isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
  isoBandNextORT[8] = isoBandNextORT[162] = 0;
  isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
  isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
  isoBandNextORB[8] = isoBandNextORB[162] = 1;
  isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
  isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
  isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
  isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
  isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
  isoBandNextOBR[8] = isoBandNextOBR[162] = 0;
  isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
  isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
  isoBandNextORT[32] = isoBandNextORT[138] = 1;
  isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
  isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
  isoBandNextORB[32] = isoBandNextORB[138] = 0;
  isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
  isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
  isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
  isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
  isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
  isoBandNextOTR[32] = isoBandNextOTR[138] = 1;
  isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
  isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
  isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
  isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
  isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
  isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
  isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
  isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
  isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
  isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
  isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
  isoBandNextOTR[128] = isoBandNextOTR[42] = 0;
  isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
  isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
  isoBandNextORB[5] = isoBandNextORB[165] = 0;
  isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
  isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
  isoBandNextOLB[5] = isoBandNextOLB[165] = 0;
  isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
  isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
  isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
  isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
  isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
  isoBandNextOTR[20] = isoBandNextOTR[150] = 1;
  isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
  isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
  isoBandNextORT[80] = isoBandNextORT[90] = 1;
  isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
  isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
  isoBandNextOLT[80] = isoBandNextOLT[90] = 1;
  isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
  isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
  isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
  isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
  isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
  isoBandNextOTL[65] = isoBandNextOTL[105] = 0;
  isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
  isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
  isoBandNextORT[160] = isoBandNextORT[10] = 1;
  isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
  isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
  isoBandNextORB[160] = isoBandNextORB[10] = 0;
  isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
  isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
  isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
  isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
  isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
  isoBandNextOLT[160] = isoBandNextOLT[10] = 1;
  isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
  isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
  isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
  isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
  isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
  isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
  isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
  isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
  isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
  isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
  isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
  isoBandNextOTR[130] = isoBandNextOTR[40] = 1;
  isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
  isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
  isoBandNextORB[37] = isoBandNextORB[133] = 1;
  isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
  isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
  isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
  isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
  isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
  isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
  isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
  isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
  isoBandNextOTR[37] = isoBandNextOTR[133] = 0;
  isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
  isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
  isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
  isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
  isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
  isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
  isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
  isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
  isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
  isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
  isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
  isoBandNextOTR[148] = isoBandNextOTR[22] = 1;
  isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
  isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
  isoBandNextORT[82] = isoBandNextORT[88] = 1;
  isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
  isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
  isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
  isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
  isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
  isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
  isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
  isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
  isoBandNextOLT[82] = isoBandNextOLT[88] = 0;
  isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
  isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
  isoBandNextORT[73] = isoBandNextORT[97] = 0;
  isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
  isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
  isoBandNextORB[73] = isoBandNextORB[97] = 0;
  isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
  isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
  isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
  isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
  isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
  isoBandNextOTL[73] = isoBandNextOTL[97] = 1;
  isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
  isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
  isoBandNextORT[145] = isoBandNextORT[25] = 0;
  isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
  isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
  isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
  isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
  isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
  isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
  isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
  isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
  isoBandNextOTR[145] = isoBandNextOTR[25] = 0;
  isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
  isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
  isoBandNextORB[70] = isoBandNextORB[100] = 0;
  isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
  isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
  isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
  isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
  isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
  isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
  isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
  isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
  isoBandNextOTL[70] = isoBandNextOTL[100] = 0;
  isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
  isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
  isoBandNextORB[101] = isoBandNextORB[69] = 0;
  isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
  isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
  isoBandNextOTL[101] = isoBandNextOTL[69] = 0;
  isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
  isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
  isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
  isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
  isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
  isoBandNextOTR[149] = isoBandNextOTR[21] = 0;
  isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
  isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
  isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
  isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
  isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
  isoBandNextOLT[86] = isoBandNextOLT[84] = 1;
  isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
  isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
  isoBandNextORT[89] = isoBandNextORT[81] = 0;
  isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
  isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
  isoBandNextOBL[89] = isoBandNextOBL[81] = 1;
  isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
  isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
  isoBandNextORT[96] = isoBandNextORT[74] = 0;
  isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
  isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
  isoBandNextORB[96] = isoBandNextORB[74] = 1;
  isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
  isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
  isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
  isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
  isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
  isoBandNextOTL[96] = isoBandNextOTL[74] = 1;
  isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
  isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
  isoBandNextORT[24] = isoBandNextORT[146] = 1;
  isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
  isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
  isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
  isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
  isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
  isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
  isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
  isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
  isoBandNextOTR[24] = isoBandNextOTR[146] = 0;
  isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
  isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
  isoBandNextORB[6] = isoBandNextORB[164] = 1;
  isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
  isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
  isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
  isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
  isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
  isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
  isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
  isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
  isoBandNextOLT[6] = isoBandNextOLT[164] = 0;
  isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
  isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
  isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
  isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
  isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
  isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
  isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
  isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
  isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
  isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
  isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
  isoBandNextOTR[129] = isoBandNextOTR[41] = 0;
  isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
  isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
  isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
  isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
  isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
  isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
  isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
  isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
  isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
  isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
  isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
  isoBandNextOTL[66] = isoBandNextOTL[104] = 1;
  isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
  isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
  isoBandNextORT[144] = isoBandNextORT[26] = 0;
  isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
  isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
  isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
  isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
  isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
  isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
  isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
  isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
  isoBandNextOTR[144] = isoBandNextOTR[26] = 1;
  isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
  isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
  isoBandNextORB[36] = isoBandNextORB[134] = 1;
  isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
  isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
  isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
  isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
  isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
  isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
  isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
  isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
  isoBandNextOTR[36] = isoBandNextOTR[134] = 0;
  isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
  isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
  isoBandNextORT[9] = isoBandNextORT[161] = 0;
  isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
  isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
  isoBandNextORB[9] = isoBandNextORB[161] = 0;
  isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
  isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
  isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
  isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
  isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
  isoBandNextOLB[9] = isoBandNextOLB[161] = 1;
  isoBandNextXRT[136] = 0;
  isoBandNextYRT[136] = 1;
  isoBandNextORT[136] = 1;
  isoBandNextXRB[136] = 0;
  isoBandNextYRB[136] = 1;
  isoBandNextORB[136] = 0;
  isoBandNextXBR[136] = -1;
  isoBandNextYBR[136] = 0;
  isoBandNextOBR[136] = 1;
  isoBandNextXBL[136] = -1;
  isoBandNextYBL[136] = 0;
  isoBandNextOBL[136] = 0;
  isoBandNextXLB[136] = 0;
  isoBandNextYLB[136] = -1;
  isoBandNextOLB[136] = 0;
  isoBandNextXLT[136] = 0;
  isoBandNextYLT[136] = -1;
  isoBandNextOLT[136] = 1;
  isoBandNextXTL[136] = 1;
  isoBandNextYTL[136] = 0;
  isoBandNextOTL[136] = 0;
  isoBandNextXTR[136] = 1;
  isoBandNextYTR[136] = 0;
  isoBandNextOTR[136] = 1;
  isoBandNextXRT[34] = 0;
  isoBandNextYRT[34] = -1;
  isoBandNextORT[34] = 0;
  isoBandNextXRB[34] = 0;
  isoBandNextYRB[34] = -1;
  isoBandNextORB[34] = 1;
  isoBandNextXBR[34] = 1;
  isoBandNextYBR[34] = 0;
  isoBandNextOBR[34] = 0;
  isoBandNextXBL[34] = 1;
  isoBandNextYBL[34] = 0;
  isoBandNextOBL[34] = 1;
  isoBandNextXLB[34] = 0;
  isoBandNextYLB[34] = 1;
  isoBandNextOLB[34] = 1;
  isoBandNextXLT[34] = 0;
  isoBandNextYLT[34] = 1;
  isoBandNextOLT[34] = 0;
  isoBandNextXTL[34] = -1;
  isoBandNextYTL[34] = 0;
  isoBandNextOTL[34] = 1;
  isoBandNextXTR[34] = -1;
  isoBandNextYTR[34] = 0;
  isoBandNextOTR[34] = 0;
  isoBandNextXRT[35] = 0;
  isoBandNextYRT[35] = 1;
  isoBandNextORT[35] = 1;
  isoBandNextXRB[35] = 0;
  isoBandNextYRB[35] = -1;
  isoBandNextORB[35] = 1;
  isoBandNextXBR[35] = 1;
  isoBandNextYBR[35] = 0;
  isoBandNextOBR[35] = 0;
  isoBandNextXBL[35] = -1;
  isoBandNextYBL[35] = 0;
  isoBandNextOBL[35] = 0;
  isoBandNextXLB[35] = 0;
  isoBandNextYLB[35] = -1;
  isoBandNextOLB[35] = 0;
  isoBandNextXLT[35] = 0;
  isoBandNextYLT[35] = 1;
  isoBandNextOLT[35] = 0;
  isoBandNextXTL[35] = -1;
  isoBandNextYTL[35] = 0;
  isoBandNextOTL[35] = 1;
  isoBandNextXTR[35] = 1;
  isoBandNextYTR[35] = 0;
  isoBandNextOTR[35] = 1;
  isoBandNextXRT[153] = 0;
  isoBandNextYRT[153] = 1;
  isoBandNextORT[153] = 1;
  isoBandNextXBL[153] = -1;
  isoBandNextYBL[153] = 0;
  isoBandNextOBL[153] = 0;
  isoBandNextXLB[153] = 0;
  isoBandNextYLB[153] = -1;
  isoBandNextOLB[153] = 0;
  isoBandNextXTR[153] = 1;
  isoBandNextYTR[153] = 0;
  isoBandNextOTR[153] = 1;
  isoBandNextXRB[102] = 0;
  isoBandNextYRB[102] = -1;
  isoBandNextORB[102] = 1;
  isoBandNextXBR[102] = 1;
  isoBandNextYBR[102] = 0;
  isoBandNextOBR[102] = 0;
  isoBandNextXLT[102] = 0;
  isoBandNextYLT[102] = 1;
  isoBandNextOLT[102] = 0;
  isoBandNextXTL[102] = -1;
  isoBandNextYTL[102] = 0;
  isoBandNextOTL[102] = 1;
  isoBandNextXRT[155] = 0;
  isoBandNextYRT[155] = -1;
  isoBandNextORT[155] = 0;
  isoBandNextXBL[155] = 1;
  isoBandNextYBL[155] = 0;
  isoBandNextOBL[155] = 1;
  isoBandNextXLB[155] = 0;
  isoBandNextYLB[155] = 1;
  isoBandNextOLB[155] = 1;
  isoBandNextXTR[155] = -1;
  isoBandNextYTR[155] = 0;
  isoBandNextOTR[155] = 0;
  isoBandNextXRB[103] = 0;
  isoBandNextYRB[103] = 1;
  isoBandNextORB[103] = 0;
  isoBandNextXBR[103] = -1;
  isoBandNextYBR[103] = 0;
  isoBandNextOBR[103] = 1;
  isoBandNextXLT[103] = 0;
  isoBandNextYLT[103] = -1;
  isoBandNextOLT[103] = 1;
  isoBandNextXTL[103] = 1;
  isoBandNextYTL[103] = 0;
  isoBandNextOTL[103] = 0;
  isoBandNextXRT[152] = 0;
  isoBandNextYRT[152] = 1;
  isoBandNextORT[152] = 1;
  isoBandNextXBR[152] = -1;
  isoBandNextYBR[152] = 0;
  isoBandNextOBR[152] = 1;
  isoBandNextXBL[152] = -1;
  isoBandNextYBL[152] = 0;
  isoBandNextOBL[152] = 0;
  isoBandNextXLB[152] = 0;
  isoBandNextYLB[152] = -1;
  isoBandNextOLB[152] = 0;
  isoBandNextXLT[152] = 0;
  isoBandNextYLT[152] = -1;
  isoBandNextOLT[152] = 1;
  isoBandNextXTR[152] = 1;
  isoBandNextYTR[152] = 0;
  isoBandNextOTR[152] = 1;
  isoBandNextXRT[156] = 0;
  isoBandNextYRT[156] = -1;
  isoBandNextORT[156] = 1;
  isoBandNextXBR[156] = 1;
  isoBandNextYBR[156] = 0;
  isoBandNextOBR[156] = 1;
  isoBandNextXBL[156] = -1;
  isoBandNextYBL[156] = 0;
  isoBandNextOBL[156] = 0;
  isoBandNextXLB[156] = 0;
  isoBandNextYLB[156] = -1;
  isoBandNextOLB[156] = 0;
  isoBandNextXLT[156] = 0;
  isoBandNextYLT[156] = 1;
  isoBandNextOLT[156] = 1;
  isoBandNextXTR[156] = -1;
  isoBandNextYTR[156] = 0;
  isoBandNextOTR[156] = 1;
  isoBandNextXRT[137] = 0;
  isoBandNextYRT[137] = 1;
  isoBandNextORT[137] = 1;
  isoBandNextXRB[137] = 0;
  isoBandNextYRB[137] = 1;
  isoBandNextORB[137] = 0;
  isoBandNextXBL[137] = -1;
  isoBandNextYBL[137] = 0;
  isoBandNextOBL[137] = 0;
  isoBandNextXLB[137] = 0;
  isoBandNextYLB[137] = -1;
  isoBandNextOLB[137] = 0;
  isoBandNextXTL[137] = 1;
  isoBandNextYTL[137] = 0;
  isoBandNextOTL[137] = 0;
  isoBandNextXTR[137] = 1;
  isoBandNextYTR[137] = 0;
  isoBandNextOTR[137] = 1;
  isoBandNextXRT[139] = 0;
  isoBandNextYRT[139] = 1;
  isoBandNextORT[139] = 1;
  isoBandNextXRB[139] = 0;
  isoBandNextYRB[139] = -1;
  isoBandNextORB[139] = 0;
  isoBandNextXBL[139] = 1;
  isoBandNextYBL[139] = 0;
  isoBandNextOBL[139] = 0;
  isoBandNextXLB[139] = 0;
  isoBandNextYLB[139] = 1;
  isoBandNextOLB[139] = 0;
  isoBandNextXTL[139] = -1;
  isoBandNextYTL[139] = 0;
  isoBandNextOTL[139] = 0;
  isoBandNextXTR[139] = 1;
  isoBandNextYTR[139] = 0;
  isoBandNextOTR[139] = 1;
  isoBandNextXRT[98] = 0;
  isoBandNextYRT[98] = -1;
  isoBandNextORT[98] = 0;
  isoBandNextXRB[98] = 0;
  isoBandNextYRB[98] = -1;
  isoBandNextORB[98] = 1;
  isoBandNextXBR[98] = 1;
  isoBandNextYBR[98] = 0;
  isoBandNextOBR[98] = 0;
  isoBandNextXBL[98] = 1;
  isoBandNextYBL[98] = 0;
  isoBandNextOBL[98] = 1;
  isoBandNextXLT[98] = 0;
  isoBandNextYLT[98] = 1;
  isoBandNextOLT[98] = 0;
  isoBandNextXTL[98] = -1;
  isoBandNextYTL[98] = 0;
  isoBandNextOTL[98] = 1;
  isoBandNextXRT[99] = 0;
  isoBandNextYRT[99] = 1;
  isoBandNextORT[99] = 0;
  isoBandNextXRB[99] = 0;
  isoBandNextYRB[99] = -1;
  isoBandNextORB[99] = 1;
  isoBandNextXBR[99] = 1;
  isoBandNextYBR[99] = 0;
  isoBandNextOBR[99] = 0;
  isoBandNextXBL[99] = -1;
  isoBandNextYBL[99] = 0;
  isoBandNextOBL[99] = 1;
  isoBandNextXLT[99] = 0;
  isoBandNextYLT[99] = -1;
  isoBandNextOLT[99] = 0;
  isoBandNextXTL[99] = 1;
  isoBandNextYTL[99] = 0;
  isoBandNextOTL[99] = 1;
  isoBandNextXRB[38] = 0;
  isoBandNextYRB[38] = -1;
  isoBandNextORB[38] = 1;
  isoBandNextXBR[38] = 1;
  isoBandNextYBR[38] = 0;
  isoBandNextOBR[38] = 0;
  isoBandNextXLB[38] = 0;
  isoBandNextYLB[38] = 1;
  isoBandNextOLB[38] = 1;
  isoBandNextXLT[38] = 0;
  isoBandNextYLT[38] = 1;
  isoBandNextOLT[38] = 0;
  isoBandNextXTL[38] = -1;
  isoBandNextYTL[38] = 0;
  isoBandNextOTL[38] = 1;
  isoBandNextXTR[38] = -1;
  isoBandNextYTR[38] = 0;
  isoBandNextOTR[38] = 0;
  isoBandNextXRB[39] = 0;
  isoBandNextYRB[39] = 1;
  isoBandNextORB[39] = 1;
  isoBandNextXBR[39] = -1;
  isoBandNextYBR[39] = 0;
  isoBandNextOBR[39] = 0;
  isoBandNextXLB[39] = 0;
  isoBandNextYLB[39] = -1;
  isoBandNextOLB[39] = 1;
  isoBandNextXLT[39] = 0;
  isoBandNextYLT[39] = 1;
  isoBandNextOLT[39] = 0;
  isoBandNextXTL[39] = -1;
  isoBandNextYTL[39] = 0;
  isoBandNextOTL[39] = 1;
  isoBandNextXTR[39] = 1;
  isoBandNextYTR[39] = 0;
  isoBandNextOTR[39] = 0;
  var p00 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p01 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0]
    ];
  };
  var p02 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, cell.righttop]
    ];
  };
  var p03 = function(cell) {
    return [
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p04 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p05 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [1, cell.righttop],
      [1, cell.rightbottom]
    ];
  };
  var p06 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p07 = function(cell) {
    return [
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p08 = function(cell) {
    return [
      [0, 0],
      [0, cell.leftbottom],
      [1, cell.rightbottom],
      [1, 0]
    ];
  };
  var p09 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [cell.topright, 1],
      [1, 1]
    ];
  };
  var p10 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p11 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p12 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p13 = function(cell) {
    return [
      [cell.topleft, 1],
      [cell.topright, 1],
      [cell.bottomright, 0],
      [cell.bottomleft, 0]
    ];
  };
  var p14 = function() {
    return [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0]
    ];
  };
  var p15 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p16 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p17 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [1, 1]
    ];
  };
  var p18 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1]
    ];
  };
  var p19 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p20 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [cell.topright, 1]
    ];
  };
  var p21 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p22 = function(cell) {
    return [
      [cell.topright, 1],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1]
    ];
  };
  var p23 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p24 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p25 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p26 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p27 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p28 = function(cell) {
    return [
      [1, 1],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p29 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p30 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p31 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p32 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p33 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p34 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p35 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p36 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p37 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p38 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p39 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var isoBandEdgeRT = [];
  var isoBandEdgeRB = [];
  var isoBandEdgeBR = [];
  var isoBandEdgeBL = [];
  var isoBandEdgeLB = [];
  var isoBandEdgeLT = [];
  var isoBandEdgeTL = [];
  var isoBandEdgeTR = [];
  isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
  isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
  isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
  isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
  isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
  isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
  isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
  isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;
  isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
  isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
  isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
  isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
  isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
  isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
  isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
  isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
  isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
  isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
  isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
  isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
  isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
  isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
  isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
  isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;
  isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
  isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
  isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
  isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
  isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
  isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
  isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
  isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
  isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
  isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
  isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
  isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
  isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
  isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
  isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
  isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;
  isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
  isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
  isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
  isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
  isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
  isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
  isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
  isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
  isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
  isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
  isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
  isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
  isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
  isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
  isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
  isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
  isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
  isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
  isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
  isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
  isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
  isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
  isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
  isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
  isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
  isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
  isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
  isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
  isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
  isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
  isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
  isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
  isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
  isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
  isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
  isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
  isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
  isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
  isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
  isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;
  isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
  isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
  isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
  isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
  isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
  isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
  isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
  isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
  isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
  isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
  isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
  isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
  isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
  isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
  isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
  isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
  isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
  isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
  isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
  isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
  isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
  isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
  isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
  isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;
  isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
  isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
  isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
  isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
  isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
  isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
  isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
  isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
  isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
  isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
  isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
  isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;
  isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
  isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
  isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
  isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
  isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
  isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
  isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
  isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;
  isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
  isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
  isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
  isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
  isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
  isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
  isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
  isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
  isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
  isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
  isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
  isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
  isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
  isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
  isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
  isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
  isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
  isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
  isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
  isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
  isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
  isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
  isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
  isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;
  var polygon_table = [];
  polygon_table[1] = polygon_table[169] = p00;
  polygon_table[4] = polygon_table[166] = p01;
  polygon_table[16] = polygon_table[154] = p02;
  polygon_table[64] = polygon_table[106] = p03;
  polygon_table[168] = polygon_table[2] = p04;
  polygon_table[162] = polygon_table[8] = p05;
  polygon_table[138] = polygon_table[32] = p06;
  polygon_table[42] = polygon_table[128] = p07;
  polygon_table[5] = polygon_table[165] = p08;
  polygon_table[20] = polygon_table[150] = p09;
  polygon_table[80] = polygon_table[90] = p10;
  polygon_table[65] = polygon_table[105] = p11;
  polygon_table[160] = polygon_table[10] = p12;
  polygon_table[130] = polygon_table[40] = p13;
  polygon_table[85] = p14;
  polygon_table[101] = polygon_table[69] = p15;
  polygon_table[149] = polygon_table[21] = p16;
  polygon_table[86] = polygon_table[84] = p17;
  polygon_table[89] = polygon_table[81] = p18;
  polygon_table[96] = polygon_table[74] = p19;
  polygon_table[24] = polygon_table[146] = p20;
  polygon_table[6] = polygon_table[164] = p21;
  polygon_table[129] = polygon_table[41] = p22;
  polygon_table[66] = polygon_table[104] = p23;
  polygon_table[144] = polygon_table[26] = p24;
  polygon_table[36] = polygon_table[134] = p25;
  polygon_table[9] = polygon_table[161] = p26;
  polygon_table[37] = polygon_table[133] = p27;
  polygon_table[148] = polygon_table[22] = p28;
  polygon_table[82] = polygon_table[88] = p29;
  polygon_table[73] = polygon_table[97] = p30;
  polygon_table[145] = polygon_table[25] = p31;
  polygon_table[70] = polygon_table[100] = p32;
  polygon_table[34] = function(c) {
    return [p07(c), p05(c)];
  };
  polygon_table[35] = p33;
  polygon_table[136] = function(c) {
    return [p06(c), p04(c)];
  };
  polygon_table[153] = function(c) {
    return [p02(c), p00(c)];
  };
  polygon_table[102] = function(c) {
    return [p01(c), p03(c)];
  };
  polygon_table[155] = p34;
  polygon_table[103] = p35;
  polygon_table[152] = function(c) {
    return [p02(c), p04(c)];
  };
  polygon_table[156] = p36;
  polygon_table[137] = function(c) {
    return [p06(c), p00(c)];
  };
  polygon_table[139] = p37;
  polygon_table[98] = function(c) {
    return [p05(c), p03(c)];
  };
  polygon_table[99] = p38;
  polygon_table[38] = function(c) {
    return [p01(c), p07(c)];
  };
  polygon_table[39] = p39;

  // ../../../../../../../node_modules/@turf/polygonize/dist/es/lib/util.js
  function mathSign(x2) {
    return (x2 > 0) - (x2 < 0) || +x2;
  }
  function orientationIndex(p1, p2, q) {
    var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
    return mathSign(dx1 * dy2 - dx2 * dy1);
  }
  function envelopeIsEqual(env1, env2) {
    var envX1 = env1.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY1 = env1.geometry.coordinates[0].map(function(c) {
      return c[1];
    }), envX2 = env2.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY2 = env2.geometry.coordinates[0].map(function(c) {
      return c[1];
    });
    return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
  }
  function envelopeContains(self2, env) {
    return env.geometry.coordinates[0].every(function(c) {
      return booleanPointInPolygon(point(c), self2);
    });
  }
  function coordinatesEqual(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
  }

  // ../../../../../../../node_modules/@turf/polygonize/dist/es/lib/Node.js
  var Node = (
    /** @class */
    function() {
      function Node2(coordinates) {
        this.id = Node2.buildId(coordinates);
        this.coordinates = coordinates;
        this.innerEdges = [];
        this.outerEdges = [];
        this.outerEdgesSorted = false;
      }
      Node2.buildId = function(coordinates) {
        return coordinates.join(",");
      };
      Node2.prototype.removeInnerEdge = function(edge) {
        this.innerEdges = this.innerEdges.filter(function(e) {
          return e.from.id !== edge.from.id;
        });
      };
      Node2.prototype.removeOuterEdge = function(edge) {
        this.outerEdges = this.outerEdges.filter(function(e) {
          return e.to.id !== edge.to.id;
        });
      };
      Node2.prototype.addOuterEdge = function(edge) {
        this.outerEdges.push(edge);
        this.outerEdgesSorted = false;
      };
      Node2.prototype.sortOuterEdges = function() {
        var _this = this;
        if (!this.outerEdgesSorted) {
          this.outerEdges.sort(function(a, b) {
            var aNode = a.to, bNode = b.to;
            if (aNode.coordinates[0] - _this.coordinates[0] >= 0 && bNode.coordinates[0] - _this.coordinates[0] < 0)
              return 1;
            if (aNode.coordinates[0] - _this.coordinates[0] < 0 && bNode.coordinates[0] - _this.coordinates[0] >= 0)
              return -1;
            if (aNode.coordinates[0] - _this.coordinates[0] === 0 && bNode.coordinates[0] - _this.coordinates[0] === 0) {
              if (aNode.coordinates[1] - _this.coordinates[1] >= 0 || bNode.coordinates[1] - _this.coordinates[1] >= 0)
                return aNode.coordinates[1] - bNode.coordinates[1];
              return bNode.coordinates[1] - aNode.coordinates[1];
            }
            var det = orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
            if (det < 0)
              return 1;
            if (det > 0)
              return -1;
            var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
            return d1 - d2;
          });
          this.outerEdgesSorted = true;
        }
      };
      Node2.prototype.getOuterEdges = function() {
        this.sortOuterEdges();
        return this.outerEdges;
      };
      Node2.prototype.getOuterEdge = function(i) {
        this.sortOuterEdges();
        return this.outerEdges[i];
      };
      Node2.prototype.addInnerEdge = function(edge) {
        this.innerEdges.push(edge);
      };
      return Node2;
    }()
  );
  var Node_default = Node;

  // ../../../../../../../node_modules/@turf/polygonize/dist/es/lib/Edge.js
  var Edge = (
    /** @class */
    function() {
      function Edge2(from, to) {
        this.from = from;
        this.to = to;
        this.next = void 0;
        this.label = void 0;
        this.symetric = void 0;
        this.ring = void 0;
        this.from.addOuterEdge(this);
        this.to.addInnerEdge(this);
      }
      Edge2.prototype.getSymetric = function() {
        if (!this.symetric) {
          this.symetric = new Edge2(this.to, this.from);
          this.symetric.symetric = this;
        }
        return this.symetric;
      };
      Edge2.prototype.deleteEdge = function() {
        this.from.removeOuterEdge(this);
        this.to.removeInnerEdge(this);
      };
      Edge2.prototype.isEqual = function(edge) {
        return this.from.id === edge.from.id && this.to.id === edge.to.id;
      };
      Edge2.prototype.toString = function() {
        return "Edge { " + this.from.id + " -> " + this.to.id + " }";
      };
      Edge2.prototype.toLineString = function() {
        return lineString([this.from.coordinates, this.to.coordinates]);
      };
      Edge2.prototype.compareTo = function(edge) {
        return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
      };
      return Edge2;
    }()
  );
  var Edge_default = Edge;

  // ../../../../../../../node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js
  var EdgeRing = (
    /** @class */
    function() {
      function EdgeRing2() {
        this.edges = [];
        this.polygon = void 0;
        this.envelope = void 0;
      }
      EdgeRing2.prototype.push = function(edge) {
        this.edges.push(edge);
        this.polygon = this.envelope = void 0;
      };
      EdgeRing2.prototype.get = function(i) {
        return this.edges[i];
      };
      Object.defineProperty(EdgeRing2.prototype, "length", {
        /**
         * Getter of length property.
         *
         * @memberof EdgeRing
         * @returns {number} - Length of the edge ring.
         */
        get: function() {
          return this.edges.length;
        },
        enumerable: true,
        configurable: true
      });
      EdgeRing2.prototype.forEach = function(f) {
        this.edges.forEach(f);
      };
      EdgeRing2.prototype.map = function(f) {
        return this.edges.map(f);
      };
      EdgeRing2.prototype.some = function(f) {
        return this.edges.some(f);
      };
      EdgeRing2.prototype.isValid = function() {
        return true;
      };
      EdgeRing2.prototype.isHole = function() {
        var _this = this;
        var hiIndex = this.edges.reduce(function(high, edge, i) {
          if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
            high = i;
          return high;
        }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
        if (disc === 0)
          return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
        return disc > 0;
      };
      EdgeRing2.prototype.toMultiPoint = function() {
        return multiPoint(this.edges.map(function(edge) {
          return edge.from.coordinates;
        }));
      };
      EdgeRing2.prototype.toPolygon = function() {
        if (this.polygon)
          return this.polygon;
        var coordinates = this.edges.map(function(edge) {
          return edge.from.coordinates;
        });
        coordinates.push(this.edges[0].from.coordinates);
        return this.polygon = polygon([coordinates]);
      };
      EdgeRing2.prototype.getEnvelope = function() {
        if (this.envelope)
          return this.envelope;
        return this.envelope = es_default6(this.toPolygon());
      };
      EdgeRing2.findEdgeRingContaining = function(testEdgeRing, shellList) {
        var testEnvelope = testEdgeRing.getEnvelope();
        var minEnvelope, minShell;
        shellList.forEach(function(shell) {
          var tryEnvelope = shell.getEnvelope();
          if (minShell)
            minEnvelope = minShell.getEnvelope();
          if (envelopeIsEqual(tryEnvelope, testEnvelope))
            return;
          if (envelopeContains(tryEnvelope, testEnvelope)) {
            var testEdgeRingCoordinates = testEdgeRing.map(function(edge) {
              return edge.from.coordinates;
            });
            var testPoint = void 0;
            var _loop_1 = function(pt2) {
              if (!shell.some(function(edge) {
                return coordinatesEqual(pt2, edge.from.coordinates);
              })) {
                testPoint = pt2;
              }
            };
            for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
              var pt = testEdgeRingCoordinates_1[_i];
              _loop_1(pt);
            }
            if (testPoint && shell.inside(point(testPoint))) {
              if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
                minShell = shell;
            }
          }
        });
        return minShell;
      };
      EdgeRing2.prototype.inside = function(pt) {
        return booleanPointInPolygon(pt, this.toPolygon());
      };
      return EdgeRing2;
    }()
  );
  var EdgeRing_default = EdgeRing;

  // ../../../../../../../node_modules/@turf/polygonize/dist/es/lib/Graph.js
  function validateGeoJson(geoJson) {
    if (!geoJson)
      throw new Error("No geojson passed");
    if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature")
      throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
  }
  var Graph = (
    /** @class */
    function() {
      function Graph3() {
        this.edges = [];
        this.nodes = {};
      }
      Graph3.fromGeoJson = function(geoJson) {
        validateGeoJson(geoJson);
        var graph = new Graph3();
        flattenEach(geoJson, function(feature2) {
          featureOf(feature2, "LineString", "Graph::fromGeoJson");
          coordReduce(feature2, function(prev, cur) {
            if (prev) {
              var start = graph.getNode(prev), end = graph.getNode(cur);
              graph.addEdge(start, end);
            }
            return cur;
          });
        });
        return graph;
      };
      Graph3.prototype.getNode = function(coordinates) {
        var id = Node_default.buildId(coordinates);
        var node = this.nodes[id];
        if (!node)
          node = this.nodes[id] = new Node_default(coordinates);
        return node;
      };
      Graph3.prototype.addEdge = function(from, to) {
        var edge = new Edge_default(from, to), symetricEdge = edge.getSymetric();
        this.edges.push(edge);
        this.edges.push(symetricEdge);
      };
      Graph3.prototype.deleteDangles = function() {
        var _this = this;
        Object.keys(this.nodes).map(function(id) {
          return _this.nodes[id];
        }).forEach(function(node) {
          return _this._removeIfDangle(node);
        });
      };
      Graph3.prototype._removeIfDangle = function(node) {
        var _this = this;
        if (node.innerEdges.length <= 1) {
          var outerNodes = node.getOuterEdges().map(function(e) {
            return e.to;
          });
          this.removeNode(node);
          outerNodes.forEach(function(n) {
            return _this._removeIfDangle(n);
          });
        }
      };
      Graph3.prototype.deleteCutEdges = function() {
        var _this = this;
        this._computeNextCWEdges();
        this._findLabeledEdgeRings();
        this.edges.forEach(function(edge) {
          if (edge.label === edge.symetric.label) {
            _this.removeEdge(edge.symetric);
            _this.removeEdge(edge);
          }
        });
      };
      Graph3.prototype._computeNextCWEdges = function(node) {
        var _this = this;
        if (typeof node === "undefined") {
          Object.keys(this.nodes).forEach(function(id) {
            return _this._computeNextCWEdges(_this.nodes[id]);
          });
        } else {
          node.getOuterEdges().forEach(function(edge, i) {
            node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
          });
        }
      };
      Graph3.prototype._computeNextCCWEdges = function(node, label) {
        var edges2 = node.getOuterEdges();
        var firstOutDE, prevInDE;
        for (var i = edges2.length - 1; i >= 0; --i) {
          var de = edges2[i], sym = de.symetric, outDE = void 0, inDE = void 0;
          if (de.label === label)
            outDE = de;
          if (sym.label === label)
            inDE = sym;
          if (!outDE || !inDE)
            continue;
          if (inDE)
            prevInDE = inDE;
          if (outDE) {
            if (prevInDE) {
              prevInDE.next = outDE;
              prevInDE = void 0;
            }
            if (!firstOutDE)
              firstOutDE = outDE;
          }
        }
        if (prevInDE)
          prevInDE.next = firstOutDE;
      };
      Graph3.prototype._findLabeledEdgeRings = function() {
        var edgeRingStarts = [];
        var label = 0;
        this.edges.forEach(function(edge) {
          if (edge.label >= 0)
            return;
          edgeRingStarts.push(edge);
          var e = edge;
          do {
            e.label = label;
            e = e.next;
          } while (!edge.isEqual(e));
          label++;
        });
        return edgeRingStarts;
      };
      Graph3.prototype.getEdgeRings = function() {
        var _this = this;
        this._computeNextCWEdges();
        this.edges.forEach(function(edge) {
          edge.label = void 0;
        });
        this._findLabeledEdgeRings().forEach(function(edge) {
          _this._findIntersectionNodes(edge).forEach(function(node) {
            _this._computeNextCCWEdges(node, edge.label);
          });
        });
        var edgeRingList = [];
        this.edges.forEach(function(edge) {
          if (edge.ring)
            return;
          edgeRingList.push(_this._findEdgeRing(edge));
        });
        return edgeRingList;
      };
      Graph3.prototype._findIntersectionNodes = function(startEdge) {
        var intersectionNodes = [];
        var edge = startEdge;
        var _loop_1 = function() {
          var degree = 0;
          edge.from.getOuterEdges().forEach(function(e) {
            if (e.label === startEdge.label)
              ++degree;
          });
          if (degree > 1)
            intersectionNodes.push(edge.from);
          edge = edge.next;
        };
        do {
          _loop_1();
        } while (!startEdge.isEqual(edge));
        return intersectionNodes;
      };
      Graph3.prototype._findEdgeRing = function(startEdge) {
        var edge = startEdge;
        var edgeRing = new EdgeRing_default();
        do {
          edgeRing.push(edge);
          edge.ring = edgeRing;
          edge = edge.next;
        } while (!startEdge.isEqual(edge));
        return edgeRing;
      };
      Graph3.prototype.removeNode = function(node) {
        var _this = this;
        node.getOuterEdges().forEach(function(edge) {
          return _this.removeEdge(edge);
        });
        node.innerEdges.forEach(function(edge) {
          return _this.removeEdge(edge);
        });
        delete this.nodes[node.id];
      };
      Graph3.prototype.removeEdge = function(edge) {
        this.edges = this.edges.filter(function(e) {
          return !e.isEqual(edge);
        });
        edge.deleteEdge();
      };
      return Graph3;
    }()
  );

  // ../../../../../../../node_modules/@turf/boolean-disjoint/dist/es/index.js
  function booleanDisjoint(feature1, feature2) {
    var bool = true;
    flattenEach(feature1, function(flatten1) {
      flattenEach(feature2, function(flatten2) {
        if (bool === false) {
          return false;
        }
        bool = disjoint(flatten1.geometry, flatten2.geometry);
      });
    });
    return bool;
  }
  function disjoint(geom1, geom2) {
    switch (geom1.type) {
      case "Point":
        switch (geom2.type) {
          case "Point":
            return !compareCoords2(geom1.coordinates, geom2.coordinates);
          case "LineString":
            return !isPointOnLine(geom2, geom1);
          case "Polygon":
            return !booleanPointInPolygon(geom1, geom2);
        }
        break;
      case "LineString":
        switch (geom2.type) {
          case "Point":
            return !isPointOnLine(geom1, geom2);
          case "LineString":
            return !isLineOnLine2(geom1, geom2);
          case "Polygon":
            return !isLineInPoly2(geom2, geom1);
        }
        break;
      case "Polygon":
        switch (geom2.type) {
          case "Point":
            return !booleanPointInPolygon(geom2, geom1);
          case "LineString":
            return !isLineInPoly2(geom1, geom2);
          case "Polygon":
            return !isPolyInPoly2(geom2, geom1);
        }
    }
    return false;
  }
  function isPointOnLine(lineString2, pt) {
    for (var i = 0; i < lineString2.coordinates.length - 1; i++) {
      if (isPointOnLineSegment2(lineString2.coordinates[i], lineString2.coordinates[i + 1], pt.coordinates)) {
        return true;
      }
    }
    return false;
  }
  function isLineOnLine2(lineString1, lineString2) {
    var doLinesIntersect = es_default11(lineString1, lineString2);
    if (doLinesIntersect.features.length > 0) {
      return true;
    }
    return false;
  }
  function isLineInPoly2(polygon2, lineString2) {
    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
      var coord = _a[_i];
      if (booleanPointInPolygon(coord, polygon2)) {
        return true;
      }
    }
    var doLinesIntersect = es_default11(lineString2, es_default22(polygon2));
    if (doLinesIntersect.features.length > 0) {
      return true;
    }
    return false;
  }
  function isPolyInPoly2(feature1, feature2) {
    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {
      var coord1 = _a[_i];
      if (booleanPointInPolygon(coord1, feature2)) {
        return true;
      }
    }
    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {
      var coord2 = _c[_b];
      if (booleanPointInPolygon(coord2, feature1)) {
        return true;
      }
    }
    var doLinesIntersect = es_default11(es_default22(feature1), es_default22(feature2));
    if (doLinesIntersect.features.length > 0) {
      return true;
    }
    return false;
  }
  function isPointOnLineSegment2(lineSegmentStart, lineSegmentEnd, pt) {
    var dxc = pt[0] - lineSegmentStart[0];
    var dyc = pt[1] - lineSegmentStart[1];
    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
      return false;
    }
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      if (dxl > 0) {
        return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
      } else {
        return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
      }
    } else if (dyl > 0) {
      return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
    } else {
      return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
    }
  }
  function compareCoords2(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
  }
  var es_default25 = booleanDisjoint;

  // ../../../../../../../node_modules/@turf/boolean-contains/dist/es/index.js
  function booleanContains(feature1, feature2) {
    var geom1 = getGeom(feature1);
    var geom2 = getGeom(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    var coords1 = geom1.coordinates;
    var coords2 = geom2.coordinates;
    switch (type1) {
      case "Point":
        switch (type2) {
          case "Point":
            return compareCoords3(coords1, coords2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      case "MultiPoint":
        switch (type2) {
          case "Point":
            return isPointInMultiPoint2(geom1, geom2);
          case "MultiPoint":
            return isMultiPointInMultiPoint2(geom1, geom2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      case "LineString":
        switch (type2) {
          case "Point":
            return es_default17(geom2, geom1, { ignoreEndVertices: true });
          case "LineString":
            return isLineOnLine3(geom1, geom2);
          case "MultiPoint":
            return isMultiPointOnLine2(geom1, geom2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      case "Polygon":
        switch (type2) {
          case "Point":
            return booleanPointInPolygon(geom2, geom1, { ignoreBoundary: true });
          case "LineString":
            return isLineInPoly3(geom1, geom2);
          case "Polygon":
            return isPolyInPoly3(geom1, geom2);
          case "MultiPoint":
            return isMultiPointInPoly2(geom1, geom2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      default:
        throw new Error("feature1 " + type1 + " geometry not supported");
    }
  }
  function isPointInMultiPoint2(multiPoint2, pt) {
    var i;
    var output = false;
    for (i = 0; i < multiPoint2.coordinates.length; i++) {
      if (compareCoords3(multiPoint2.coordinates[i], pt.coordinates)) {
        output = true;
        break;
      }
    }
    return output;
  }
  function isMultiPointInMultiPoint2(multiPoint1, multiPoint2) {
    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
      var coord2 = _a[_i];
      var matchFound = false;
      for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {
        var coord1 = _c[_b];
        if (compareCoords3(coord2, coord1)) {
          matchFound = true;
          break;
        }
      }
      if (!matchFound) {
        return false;
      }
    }
    return true;
  }
  function isMultiPointOnLine2(lineString2, multiPoint2) {
    var haveFoundInteriorPoint = false;
    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
      var coord = _a[_i];
      if (es_default17(coord, lineString2, { ignoreEndVertices: true })) {
        haveFoundInteriorPoint = true;
      }
      if (!es_default17(coord, lineString2)) {
        return false;
      }
    }
    if (haveFoundInteriorPoint) {
      return true;
    }
    return false;
  }
  function isMultiPointInPoly2(polygon2, multiPoint2) {
    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
      var coord = _a[_i];
      if (!booleanPointInPolygon(coord, polygon2, { ignoreBoundary: true })) {
        return false;
      }
    }
    return true;
  }
  function isLineOnLine3(lineString1, lineString2) {
    var haveFoundInteriorPoint = false;
    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
      var coords = _a[_i];
      if (es_default17({ type: "Point", coordinates: coords }, lineString1, {
        ignoreEndVertices: true
      })) {
        haveFoundInteriorPoint = true;
      }
      if (!es_default17({ type: "Point", coordinates: coords }, lineString1, {
        ignoreEndVertices: false
      })) {
        return false;
      }
    }
    return haveFoundInteriorPoint;
  }
  function isLineInPoly3(polygon2, linestring) {
    var output = false;
    var i = 0;
    var polyBbox = es_default(polygon2);
    var lineBbox = es_default(linestring);
    if (!doBBoxOverlap2(polyBbox, lineBbox)) {
      return false;
    }
    for (i; i < linestring.coordinates.length - 1; i++) {
      var midPoint = getMidpoint2(linestring.coordinates[i], linestring.coordinates[i + 1]);
      if (booleanPointInPolygon({ type: "Point", coordinates: midPoint }, polygon2, {
        ignoreBoundary: true
      })) {
        output = true;
        break;
      }
    }
    return output;
  }
  function isPolyInPoly3(feature1, feature2) {
    if (feature1.type === "Feature" && feature1.geometry === null) {
      return false;
    }
    if (feature2.type === "Feature" && feature2.geometry === null) {
      return false;
    }
    var poly1Bbox = es_default(feature1);
    var poly2Bbox = es_default(feature2);
    if (!doBBoxOverlap2(poly1Bbox, poly2Bbox)) {
      return false;
    }
    var coords = getGeom(feature2).coordinates;
    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {
      var ring = coords_1[_i];
      for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {
        var coord = ring_1[_a];
        if (!booleanPointInPolygon(coord, feature1)) {
          return false;
        }
      }
    }
    return true;
  }
  function doBBoxOverlap2(bbox1, bbox22) {
    if (bbox1[0] > bbox22[0]) {
      return false;
    }
    if (bbox1[2] < bbox22[2]) {
      return false;
    }
    if (bbox1[1] > bbox22[1]) {
      return false;
    }
    if (bbox1[3] < bbox22[3]) {
      return false;
    }
    return true;
  }
  function compareCoords3(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
  }
  function getMidpoint2(pair1, pair2) {
    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
  }

  // ../../../../../../../node_modules/@turf/boolean-overlap/dist/es/index.js
  var import_geojson_equality = __toESM(require_geojson_equality(), 1);

  // ../../../../../../../node_modules/@turf/boolean-equal/dist/es/index.js
  var import_geojson_equality2 = __toESM(require_geojson_equality(), 1);

  // ../../../../../../../node_modules/@turf/boolean-intersects/dist/es/index.js
  function booleanIntersects(feature1, feature2) {
    var bool = false;
    flattenEach(feature1, function(flatten1) {
      flattenEach(feature2, function(flatten2) {
        if (bool === true) {
          return true;
        }
        bool = !es_default25(flatten1.geometry, flatten2.geometry);
      });
    });
    return bool;
  }

  // ../../../../../../../node_modules/@turf/clusters-dbscan/dist/es/index.js
  var import_density_clustering = __toESM(require_lib(), 1);

  // ../../../../../../../node_modules/@turf/clusters-kmeans/dist/es/index.js
  var import_skmeans = __toESM(require_main(), 1);

  // ../../../../../../../node_modules/@turf/shortest-path/dist/es/index.js
  function pathTo(node) {
    var curr = node, path = [];
    while (curr.parent) {
      path.unshift(curr);
      curr = curr.parent;
    }
    return path;
  }
  function getHeap() {
    return new BinaryHeap(function(node) {
      return node.f;
    });
  }
  var astar = {
    /**
     * Perform an A* Search on a graph given a start and end node.
     *
     * @private
     * @memberof astar
     * @param {Graph} graph Graph
     * @param {GridNode} start Start
     * @param {GridNode} end End
     * @param {Object} [options] Options
     * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
     * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
     * @returns {Object} Search
     */
    search: function(graph, start, end, options) {
      graph.cleanDirty();
      options = options || {};
      var heuristic = options.heuristic || astar.heuristics.manhattan, closest = options.closest || false;
      var openHeap = getHeap(), closestNode = start;
      start.h = heuristic(start, end);
      openHeap.push(start);
      while (openHeap.size() > 0) {
        var currentNode = openHeap.pop();
        if (currentNode === end) {
          return pathTo(currentNode);
        }
        currentNode.closed = true;
        var neighbors = graph.neighbors(currentNode);
        for (var i = 0, il = neighbors.length; i < il; ++i) {
          var neighbor = neighbors[i];
          if (neighbor.closed || neighbor.isWall()) {
            continue;
          }
          var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
          if (!beenVisited || gScore < neighbor.g) {
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h = neighbor.h || heuristic(neighbor, end);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            graph.markDirty(neighbor);
            if (closest) {
              if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                closestNode = neighbor;
              }
            }
            if (!beenVisited) {
              openHeap.push(neighbor);
            } else {
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }
      if (closest) {
        return pathTo(closestNode);
      }
      return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
      manhattan: function(pos0, pos1) {
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return d1 + d2;
      },
      diagonal: function(pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
      }
    },
    cleanNode: function(node) {
      node.f = 0;
      node.g = 0;
      node.h = 0;
      node.visited = false;
      node.closed = false;
      node.parent = null;
    }
  };
  function Graph2(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x2 = 0; x2 < gridIn.length; x2++) {
      this.grid[x2] = [];
      for (var y2 = 0, row = gridIn[x2]; y2 < row.length; y2++) {
        var node = new GridNode(x2, y2, row[y2]);
        this.grid[x2][y2] = node;
        this.nodes.push(node);
      }
    }
    this.init();
  }
  Graph2.prototype.init = function() {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
      astar.cleanNode(this.nodes[i]);
    }
  };
  Graph2.prototype.cleanDirty = function() {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
      astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
  };
  Graph2.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
  };
  Graph2.prototype.neighbors = function(node) {
    var ret = [], x2 = node.x, y2 = node.y, grid = this.grid;
    if (grid[x2 - 1] && grid[x2 - 1][y2]) {
      ret.push(grid[x2 - 1][y2]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2]) {
      ret.push(grid[x2 + 1][y2]);
    }
    if (grid[x2] && grid[x2][y2 - 1]) {
      ret.push(grid[x2][y2 - 1]);
    }
    if (grid[x2] && grid[x2][y2 + 1]) {
      ret.push(grid[x2][y2 + 1]);
    }
    if (this.diagonal) {
      if (grid[x2 - 1] && grid[x2 - 1][y2 - 1]) {
        ret.push(grid[x2 - 1][y2 - 1]);
      }
      if (grid[x2 + 1] && grid[x2 + 1][y2 - 1]) {
        ret.push(grid[x2 + 1][y2 - 1]);
      }
      if (grid[x2 - 1] && grid[x2 - 1][y2 + 1]) {
        ret.push(grid[x2 - 1][y2 + 1]);
      }
      if (grid[x2 + 1] && grid[x2 + 1][y2 + 1]) {
        ret.push(grid[x2 + 1][y2 + 1]);
      }
    }
    return ret;
  };
  Graph2.prototype.toString = function() {
    var graphString = [], nodes = this.grid, rowDebug, row, y2, l;
    for (var x2 = 0, len = nodes.length; x2 < len; x2++) {
      rowDebug = [];
      row = nodes[x2];
      for (y2 = 0, l = row.length; y2 < l; y2++) {
        rowDebug.push(row[y2].weight);
      }
      graphString.push(rowDebug.join(" "));
    }
    return graphString.join("\n");
  };
  function GridNode(x2, y2, weight) {
    this.x = x2;
    this.y = y2;
    this.weight = weight;
  }
  GridNode.prototype.toString = function() {
    return "[" + this.x + " " + this.y + "]";
  };
  GridNode.prototype.getCost = function(fromNeighbor) {
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
      return this.weight * 1.41421;
    }
    return this.weight;
  };
  GridNode.prototype.isWall = function() {
    return this.weight === 0;
  };
  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }
  BinaryHeap.prototype = {
    push: function(element) {
      this.content.push(element);
      this.sinkDown(this.content.length - 1);
    },
    pop: function() {
      var result = this.content[0];
      var end = this.content.pop();
      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }
      return result;
    },
    remove: function(node) {
      var i = this.content.indexOf(node);
      var end = this.content.pop();
      if (i !== this.content.length - 1) {
        this.content[i] = end;
        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
    },
    size: function() {
      return this.content.length;
    },
    rescoreElement: function(node) {
      this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
      var element = this.content[n];
      while (n > 0) {
        var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent;
          n = parentN;
        } else {
          break;
        }
      }
    },
    bubbleUp: function(n) {
      var length2 = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
      while (true) {
        var child2N = n + 1 << 1, child1N = child2N - 1;
        var swap = null, child1Score;
        if (child1N < length2) {
          var child1 = this.content[child1N];
          child1Score = this.scoreFunction(child1);
          if (child1Score < elemScore) {
            swap = child1N;
          }
        }
        if (child2N < length2) {
          var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
          if (child2Score < (swap === null ? elemScore : child1Score)) {
            swap = child2N;
          }
        }
        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        } else {
          break;
        }
      }
    }
  };

  // ../../../../../../../node_modules/d3-voronoi/src/RedBlackTree.js
  function RedBlackTree() {
    this._ = null;
  }
  function RedBlackNode(node) {
    node.U = // parent node
    node.C = // color - true for red, false for black
    node.L = // left node
    node.R = // right node
    node.P = // previous node
    node.N = null;
  }
  RedBlackTree.prototype = {
    constructor: RedBlackTree,
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N)
          after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L)
            after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = RedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              RedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              RedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N)
        node.N.P = node.P;
      if (node.P)
        node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left)
        next = right;
      else if (!right)
        next = left;
      else
        next = RedBlackFirst(right);
      if (parent) {
        if (parent.L === node)
          parent.L = next;
        else
          parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node)
        node.U = parent;
      if (red)
        return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._)
          break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              RedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            RedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              RedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            RedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node)
        node.C = false;
    }
  };
  function RedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R)
      p.R.U = p;
    q.L = p;
  }
  function RedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L)
      p.L.U = p;
    q.R = p;
  }
  function RedBlackFirst(node) {
    while (node.L)
      node = node.L;
    return node;
  }
  var RedBlackTree_default = RedBlackTree;

  // ../../../../../../../node_modules/d3-voronoi/src/Edge.js
  function createEdge(left, right, v0, v1) {
    var edge = [null, null], index = edges.push(edge) - 1;
    edge.left = left;
    edge.right = right;
    if (v0)
      setEdgeEnd(edge, left, right, v0);
    if (v1)
      setEdgeEnd(edge, right, left, v1);
    cells[left.index].halfedges.push(index);
    cells[right.index].halfedges.push(index);
    return edge;
  }
  function createBorderEdge(left, v0, v1) {
    var edge = [v0, v1];
    edge.left = left;
    return edge;
  }
  function setEdgeEnd(edge, left, right, vertex) {
    if (!edge[0] && !edge[1]) {
      edge[0] = vertex;
      edge.left = left;
      edge.right = right;
    } else if (edge.left === right) {
      edge[1] = vertex;
    } else {
      edge[0] = vertex;
    }
  }
  function clipEdge(edge, x02, y0, x12, y1) {
    var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x02 - ax;
    if (!dx && r > 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dx > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dx > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    r = y0 - ay;
    if (!dy && r > 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dy > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = y1 - ay;
    if (!dy && r < 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dy > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    if (!(t0 > 0) && !(t1 < 1))
      return true;
    if (t0 > 0)
      edge[0] = [ax + t0 * dx, ay + t0 * dy];
    if (t1 < 1)
      edge[1] = [ax + t1 * dx, ay + t1 * dy];
    return true;
  }
  function connectEdge(edge, x02, y0, x12, y1) {
    var v1 = edge[1];
    if (v1)
      return true;
    var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x02 || fx >= x12)
        return;
      if (lx > rx) {
        if (!v0)
          v0 = [fx, y0];
        else if (v0[1] >= y1)
          return;
        v1 = [fx, y1];
      } else {
        if (!v0)
          v0 = [fx, y1];
        else if (v0[1] < y0)
          return;
        v1 = [fx, y0];
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!v0)
            v0 = [(y0 - fb) / fm, y0];
          else if (v0[1] >= y1)
            return;
          v1 = [(y1 - fb) / fm, y1];
        } else {
          if (!v0)
            v0 = [(y1 - fb) / fm, y1];
          else if (v0[1] < y0)
            return;
          v1 = [(y0 - fb) / fm, y0];
        }
      } else {
        if (ly < ry) {
          if (!v0)
            v0 = [x02, fm * x02 + fb];
          else if (v0[0] >= x12)
            return;
          v1 = [x12, fm * x12 + fb];
        } else {
          if (!v0)
            v0 = [x12, fm * x12 + fb];
          else if (v0[0] < x02)
            return;
          v1 = [x02, fm * x02 + fb];
        }
      }
    }
    edge[0] = v0;
    edge[1] = v1;
    return true;
  }
  function clipEdges(x02, y0, x12, y1) {
    var i = edges.length, edge;
    while (i--) {
      if (!connectEdge(edge = edges[i], x02, y0, x12, y1) || !clipEdge(edge, x02, y0, x12, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
        delete edges[i];
      }
    }
  }

  // ../../../../../../../node_modules/d3-voronoi/src/Cell.js
  function createCell(site) {
    return cells[site.index] = {
      site,
      halfedges: []
    };
  }
  function cellHalfedgeAngle(cell, edge) {
    var site = cell.site, va = edge.left, vb = edge.right;
    if (site === vb)
      vb = va, va = site;
    if (vb)
      return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
    if (site === va)
      va = edge[1], vb = edge[0];
    else
      va = edge[0], vb = edge[1];
    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
  }
  function cellHalfedgeStart(cell, edge) {
    return edge[+(edge.left !== cell.site)];
  }
  function cellHalfedgeEnd(cell, edge) {
    return edge[+(edge.left === cell.site)];
  }
  function sortCellHalfedges() {
    for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
      if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
        var index = new Array(m), array2 = new Array(m);
        for (j = 0; j < m; ++j)
          index[j] = j, array2[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
        index.sort(function(i2, j2) {
          return array2[j2] - array2[i2];
        });
        for (j = 0; j < m; ++j)
          array2[j] = halfedges[index[j]];
        for (j = 0; j < m; ++j)
          halfedges[j] = array2[j];
      }
    }
  }
  function clipCells(x02, y0, x12, y1) {
    var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        halfedges = cell.halfedges;
        iHalfedge = halfedges.length;
        while (iHalfedge--) {
          if (!edges[halfedges[iHalfedge]]) {
            halfedges.splice(iHalfedge, 1);
          }
        }
        iHalfedge = 0, nHalfedges = halfedges.length;
        while (iHalfedge < nHalfedges) {
          end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
          start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
          if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
            halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(
              site,
              end,
              Math.abs(endX - x02) < epsilon && y1 - endY > epsilon ? [x02, Math.abs(startX - x02) < epsilon ? startY : y1] : Math.abs(endY - y1) < epsilon && x12 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x12, y1] : Math.abs(endX - x12) < epsilon && endY - y0 > epsilon ? [x12, Math.abs(startX - x12) < epsilon ? startY : y0] : Math.abs(endY - y0) < epsilon && endX - x02 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x02, y0] : null
            )) - 1);
            ++nHalfedges;
          }
        }
        if (nHalfedges)
          cover = false;
      }
    }
    if (cover) {
      var dx, dy, d2, dc = Infinity;
      for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          site = cell.site;
          dx = site[0] - x02;
          dy = site[1] - y0;
          d2 = dx * dx + dy * dy;
          if (d2 < dc)
            dc = d2, cover = cell;
        }
      }
      if (cover) {
        var v00 = [x02, y0], v01 = [x02, y1], v11 = [x12, y1], v10 = [x12, y0];
        cover.halfedges.push(
          edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
          edges.push(createBorderEdge(site, v01, v11)) - 1,
          edges.push(createBorderEdge(site, v11, v10)) - 1,
          edges.push(createBorderEdge(site, v10, v00)) - 1
        );
      }
    }
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        if (!cell.halfedges.length) {
          delete cells[iCell];
        }
      }
    }
  }

  // ../../../../../../../node_modules/d3-voronoi/src/Circle.js
  var circlePool = [];
  var firstCircle;
  function Circle() {
    RedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function attachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc)
      return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite)
      return;
    var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -epsilon2)
      return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
    var circle4 = circlePool.pop() || new Circle();
    circle4.arc = arc;
    circle4.site = cSite;
    circle4.x = x2 + bx;
    circle4.y = (circle4.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
    arc.circle = circle4;
    var before = null, node = circles._;
    while (node) {
      if (circle4.y < node.y || circle4.y === node.y && circle4.x <= node.x) {
        if (node.L)
          node = node.L;
        else {
          before = node.P;
          break;
        }
      } else {
        if (node.R)
          node = node.R;
        else {
          before = node;
          break;
        }
      }
    }
    circles.insert(before, circle4);
    if (!before)
      firstCircle = circle4;
  }
  function detachCircle(arc) {
    var circle4 = arc.circle;
    if (circle4) {
      if (!circle4.P)
        firstCircle = circle4.N;
      circles.remove(circle4);
      circlePool.push(circle4);
      RedBlackNode(circle4);
      arc.circle = null;
    }
  }

  // ../../../../../../../node_modules/d3-voronoi/src/Beach.js
  var beachPool = [];
  function Beach() {
    RedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function createBeach(site) {
    var beach = beachPool.pop() || new Beach();
    beach.site = site;
    return beach;
  }
  function detachBeach(beach) {
    detachCircle(beach);
    beaches.remove(beach);
    beachPool.push(beach);
    RedBlackNode(beach);
  }
  function removeBeach(beach) {
    var circle4 = beach.circle, x2 = circle4.x, y2 = circle4.cy, vertex = [x2, y2], previous = beach.P, next = beach.N, disappearing = [beach];
    detachBeach(beach);
    var lArc = previous;
    while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      detachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    detachCircle(lArc);
    var rArc = next;
    while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
      next = rArc.N;
      disappearing.push(rArc);
      detachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    detachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function addBeach(site) {
    var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
    while (node) {
      dxl = leftBreakPoint(node, directrix) - x2;
      if (dxl > epsilon)
        node = node.L;
      else {
        dxr = x2 - rightBreakPoint(node, directrix);
        if (dxr > epsilon) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -epsilon) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -epsilon) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    createCell(site);
    var newArc = createBeach(site);
    beaches.insert(lArc, newArc);
    if (!lArc && !rArc)
      return;
    if (lArc === rArc) {
      detachCircle(lArc);
      rArc = createBeach(lArc.site);
      beaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
      attachCircle(lArc);
      attachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = createEdge(lArc.site, newArc.site);
      return;
    }
    detachCircle(lArc);
    detachCircle(rArc);
    var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
    setEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = createEdge(lSite, site, null, vertex);
    rArc.edge = createEdge(site, rSite, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function leftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
    if (!pby2)
      return rfocx;
    var lArc = arc.P;
    if (!lArc)
      return -Infinity;
    site = lArc.site;
    var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
    if (!plby2)
      return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2)
      return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function rightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc)
      return leftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site[1] === directrix ? site[0] : Infinity;
  }

  // ../../../../../../../node_modules/d3-voronoi/src/Diagram.js
  var epsilon = 1e-6;
  var epsilon2 = 1e-12;
  var beaches;
  var cells;
  var circles;
  var edges;
  function triangleArea(a, b, c) {
    return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
  }
  function lexicographic(a, b) {
    return b[1] - a[1] || b[0] - a[0];
  }
  function Diagram(sites, extent) {
    var site = sites.sort(lexicographic).pop(), x2, y2, circle4;
    edges = [];
    cells = new Array(sites.length);
    beaches = new RedBlackTree_default();
    circles = new RedBlackTree_default();
    while (true) {
      circle4 = firstCircle;
      if (site && (!circle4 || site[1] < circle4.y || site[1] === circle4.y && site[0] < circle4.x)) {
        if (site[0] !== x2 || site[1] !== y2) {
          addBeach(site);
          x2 = site[0], y2 = site[1];
        }
        site = sites.pop();
      } else if (circle4) {
        removeBeach(circle4.arc);
      } else {
        break;
      }
    }
    sortCellHalfedges();
    if (extent) {
      var x02 = +extent[0][0], y0 = +extent[0][1], x12 = +extent[1][0], y1 = +extent[1][1];
      clipEdges(x02, y0, x12, y1);
      clipCells(x02, y0, x12, y1);
    }
    this.edges = edges;
    this.cells = cells;
    beaches = circles = edges = cells = null;
  }
  Diagram.prototype = {
    constructor: Diagram,
    polygons: function() {
      var edges2 = this.edges;
      return this.cells.map(function(cell) {
        var polygon2 = cell.halfedges.map(function(i) {
          return cellHalfedgeStart(cell, edges2[i]);
        });
        polygon2.data = cell.site.data;
        return polygon2;
      });
    },
    triangles: function() {
      var triangles = [], edges2 = this.edges;
      this.cells.forEach(function(cell, i) {
        if (!(m = (halfedges = cell.halfedges).length))
          return;
        var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
        while (++j < m) {
          s0 = s1;
          e1 = edges2[halfedges[j]];
          s1 = e1.left === site ? e1.right : e1.left;
          if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
            triangles.push([site.data, s0.data, s1.data]);
          }
        }
      });
      return triangles;
    },
    links: function() {
      return this.edges.filter(function(edge) {
        return edge.right;
      }).map(function(edge) {
        return {
          source: edge.left.data,
          target: edge.right.data
        };
      });
    },
    find: function(x2, y2, radius) {
      var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
      while (!(cell = that.cells[i1]))
        if (++i1 >= n)
          return null;
      var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
      do {
        cell = that.cells[i0 = i1], i1 = null;
        cell.halfedges.forEach(function(e) {
          var edge = that.edges[e], v = edge.left;
          if ((v === cell.site || !v) && !(v = edge.right))
            return;
          var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
          if (v2 < d2)
            d2 = v2, i1 = v.index;
        });
      } while (i1 !== null);
      that._found = i0;
      return radius == null || d2 <= radius * radius ? cell.site : null;
    }
  };

  // ../../../../../../../node_modules/@turf/clusters/dist/es/index.js
  function getCluster(geojson, filter) {
    if (!geojson)
      throw new Error("geojson is required");
    if (geojson.type !== "FeatureCollection")
      throw new Error("geojson must be a FeatureCollection");
    if (filter === void 0 || filter === null)
      throw new Error("filter is required");
    var features = [];
    featureEach(geojson, function(feature2) {
      if (applyFilter(feature2.properties, filter))
        features.push(feature2);
    });
    return featureCollection(features);
  }
  function applyFilter(properties, filter) {
    if (properties === void 0)
      return false;
    var filterType = typeof filter;
    if (filterType === "number" || filterType === "string")
      return Object.prototype.hasOwnProperty.call(properties, filter);
    else if (Array.isArray(filter)) {
      for (var i = 0; i < filter.length; i++) {
        if (!applyFilter(properties, filter[i]))
          return false;
      }
      return true;
    } else {
      return propertiesContainsFilter(properties, filter);
    }
  }
  function propertiesContainsFilter(properties, filter) {
    var keys = Object.keys(filter);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (properties[key] !== filter[key])
        return false;
    }
    return true;
  }

  // ../../../../../../../node_modules/@turf/difference/dist/es/index.js
  var import_polygon_clipping = __toESM(require_polygon_clipping_umd(), 1);

  // ../../../../../../../node_modules/@turf/buffer/dist/es/index.js
  var import_turf_jsts = __toESM(require_jsts_min(), 1);

  // ../../../../../../../node_modules/d3-geo/src/adder.js
  function adder_default() {
    return new Adder();
  }
  function Adder() {
    this.reset();
  }
  Adder.prototype = {
    constructor: Adder,
    reset: function() {
      this.s = // rounded value
      this.t = 0;
    },
    add: function(y2) {
      add(temp, y2, this.t);
      add(this, temp.s, this.s);
      if (this.s)
        this.t += temp.t;
      else
        this.s = temp.t;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var temp = new Adder();
  function add(adder, a, b) {
    var x2 = adder.s = a + b, bv = x2 - a, av = x2 - bv;
    adder.t = a - av + (b - bv);
  }

  // ../../../../../../../node_modules/d3-geo/src/math.js
  var epsilon3 = 1e-6;
  var pi = Math.PI;
  var halfPi = pi / 2;
  var quarterPi = pi / 4;
  var tau = pi * 2;
  var degrees = 180 / pi;
  var radians = pi / 180;
  var abs = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var exp = Math.exp;
  var log = Math.log;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  var tan = Math.tan;
  function acos(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
  }
  function asin(x2) {
    return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
  }

  // ../../../../../../../node_modules/d3-geo/src/noop.js
  function noop() {
  }

  // ../../../../../../../node_modules/d3-geo/src/area.js
  var areaRingSum = adder_default();
  var areaSum = adder_default();

  // ../../../../../../../node_modules/d3-geo/src/cartesian.js
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
  }
  function cartesianCross(a, b) {
    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  }
  function cartesianNormalizeInPlace(d) {
    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  // ../../../../../../../node_modules/d3-geo/src/bounds.js
  var deltaSum = adder_default();

  // ../../../../../../../node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi) {
    return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  }
  rotationIdentity.invert = rotationIdentity;

  // ../../../../../../../node_modules/d3-geo/src/clip/buffer.js
  function buffer_default() {
    var lines = [], line;
    return {
      point: function(x2, y2) {
        line.push([x2, y2]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop,
      rejoin: function() {
        if (lines.length > 1)
          lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  // ../../../../../../../node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a, b) {
    return abs(a[0] - b[0]) < epsilon3 && abs(a[1] - b[1]) < epsilon3;
  }

  // ../../../../../../../node_modules/d3-geo/src/clip/polygon.js
  function Intersection(point2, points, other, entry) {
    this.x = point2;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function polygon_default(segments, compareIntersection2, startInside, interpolate, stream) {
    var subject = [], clip = [], i, n;
    segments.forEach(function(segment) {
      if ((n2 = segment.length - 1) <= 0)
        return;
      var n2, p0 = segment[0], p1 = segment[n2], x2;
      if (pointEqual_default(p0, p1)) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      subject.push(x2 = new Intersection(p0, segment, null, true));
      clip.push(x2.o = new Intersection(p0, null, x2, false));
      subject.push(x2 = new Intersection(p1, segment, null, false));
      clip.push(x2.o = new Intersection(p1, null, x2, true));
    });
    if (!subject.length)
      return;
    clip.sort(compareIntersection2);
    link(subject);
    link(clip);
    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }
    var start = subject[0], points, point2;
    while (1) {
      var current = start, isSubject = true;
      while (current.v)
        if ((current = current.n) === start)
          return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link(array2) {
    if (!(n = array2.length))
      return;
    var n, i = 0, a = array2[0], b;
    while (++i < n) {
      a.n = b = array2[i];
      b.p = a;
      a = b;
    }
    a.n = b = array2[0];
    b.p = a;
  }

  // ../../../../../../../node_modules/d3-array/src/ascending.js
  function ascending_default(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // ../../../../../../../node_modules/d3-array/src/bisector.js
  function bisector_default(compare) {
    if (compare.length === 1)
      compare = ascendingComparator(compare);
    return {
      left: function(a, x2, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x2) < 0)
            lo = mid + 1;
          else
            hi = mid;
        }
        return lo;
      },
      right: function(a, x2, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x2) > 0)
            hi = mid;
          else
            lo = mid + 1;
        }
        return lo;
      }
    };
  }
  function ascendingComparator(f) {
    return function(d, x2) {
      return ascending_default(f(d), x2);
    };
  }

  // ../../../../../../../node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector_default(ascending_default);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  // ../../../../../../../node_modules/d3-array/src/array.js
  var array = Array.prototype;
  var slice = array.slice;
  var map = array.map;

  // ../../../../../../../node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);

  // ../../../../../../../node_modules/d3-array/src/merge.js
  function merge_default2(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array2;
    while (++i < n)
      j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array2 = arrays[n];
      m = array2.length;
      while (--m >= 0) {
        merged[--j] = array2[m];
      }
    }
    return merged;
  }

  // ../../../../../../../node_modules/d3-geo/src/clip/extent.js
  var clipMax = 1e9;
  var clipMin = -clipMax;

  // ../../../../../../../node_modules/d3-geo/src/polygonContains.js
  var sum = adder_default();
  function polygonContains_default(polygon2, point2) {
    var lambda = point2[0], phi = point2[1], normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
    sum.reset();
    for (var i = 0, n = polygon2.length; i < n; ++i) {
      if (!(m = (ring = polygon2[i]).length))
        continue;
      var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;
        sum.add(atan2(k * sign2 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
        angle += antimeridian ? delta + sign2 * tau : delta;
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle < -epsilon3 || angle < epsilon3 && sum < -epsilon3) ^ winding & 1;
  }

  // ../../../../../../../node_modules/d3-geo/src/length.js
  var lengthSum = adder_default();

  // ../../../../../../../node_modules/d3-geo/src/path/area.js
  var areaSum2 = adder_default();
  var areaRingSum2 = adder_default();

  // ../../../../../../../node_modules/d3-geo/src/path/bounds.js
  var x0 = Infinity;
  var x1 = -x0;

  // ../../../../../../../node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
      return this._radius = _, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._context.closePath();
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x2, y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x2, y2);
          break;
        }
        default: {
          this._context.moveTo(x2 + this._radius, y2);
          this._context.arc(x2, y2, this._radius, 0, tau);
          break;
        }
      }
    },
    result: noop
  };

  // ../../../../../../../node_modules/d3-geo/src/path/measure.js
  var lengthSum2 = adder_default();

  // ../../../../../../../node_modules/d3-geo/src/path/string.js
  function PathString() {
    this._string = [];
  }
  PathString.prototype = {
    _radius: 4.5,
    _circle: circle2(4.5),
    pointRadius: function(_) {
      if ((_ = +_) !== this._radius)
        this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._string.push("Z");
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x2, ",", y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x2, ",", y2);
          break;
        }
        default: {
          if (this._circle == null)
            this._circle = circle2(this._radius);
          this._string.push("M", x2, ",", y2, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };
  function circle2(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }

  // ../../../../../../../node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate, start) {
    return function(rotate, sink) {
      var line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon2, segments, ring;
      var clip = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon2 = [];
        },
        polygonEnd: function() {
          clip.point = point2;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge_default2(segments);
          var startInside = polygonContains_default(polygon2, rotatedStart);
          if (segments.length) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            polygon_default(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted)
            sink.polygonEnd(), polygonStarted = false;
          segments = polygon2 = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point2(lambda, phi) {
        var point3 = rotate(lambda, phi);
        if (pointVisible(lambda = point3[0], phi = point3[1]))
          sink.point(lambda, phi);
      }
      function pointLine(lambda, phi) {
        var point3 = rotate(lambda, phi);
        line.point(point3[0], point3[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point2;
        line.lineEnd();
      }
      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        var point3 = rotate(lambda, phi);
        ringSink.point(point3[0], point3[1]);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
        ring.pop();
        polygon2.push(ring);
        ring = null;
        if (!n)
          return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m = segment.length - 1) > 0) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m; ++i)
              sink.point((point3 = segment[i])[0], point3[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2)
          ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon3 : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon3 : halfPi - b[1]);
  }

  // ../../../../../../../node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi, -halfPi]
  );
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);
        if (abs(delta - pi) < epsilon3) {
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi) {
          if (abs(lambda0 - sign0) < epsilon3)
            lambda0 -= sign0 * epsilon3;
          if (abs(lambda1 - sign1) < epsilon3)
            lambda1 -= sign1 * epsilon3;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
    return abs(sinLambda0Lambda1) > epsilon3 ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
  }
  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi;
      stream.point(-pi, phi);
      stream.point(0, phi);
      stream.point(pi, phi);
      stream.point(pi, 0);
      stream.point(pi, -phi);
      stream.point(0, -phi);
      stream.point(-pi, -phi);
      stream.point(-pi, 0);
      stream.point(-pi, phi);
    } else if (abs(from[0] - to[0]) > epsilon3) {
      var lambda = from[0] < to[0] ? pi : -pi;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // ../../../../../../../node_modules/d3-geo/src/transform.js
  function transformer(methods) {
    return function(stream) {
      var s = new TransformStream();
      for (var key in methods)
        s[key] = methods[key];
      s.stream = stream;
      return s;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x2, y2) {
      this.stream.point(x2, y2);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // ../../../../../../../node_modules/d3-geo/src/projection/resample.js
  var cosMinDistance = cos(30 * radians);

  // ../../../../../../../node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x2, y2) {
      this.stream.point(x2 * radians, y2 * radians);
    }
  });

  // ../../../../../../../node_modules/d3-geo/src/projection/azimuthal.js
  function azimuthalRaw(scale) {
    return function(x2, y2) {
      var cx = cos(x2), cy = cos(y2), k = scale(cx * cy);
      return [
        k * cy * sin(x2),
        k * sin(y2)
      ];
    };
  }
  function azimuthalInvert(angle) {
    return function(x2, y2) {
      var z = sqrt(x2 * x2 + y2 * y2), c = angle(z), sc = sin(c), cc = cos(c);
      return [
        atan2(x2 * sc, z * cc),
        asin(z && y2 * sc / z)
      ];
    };
  }

  // ../../../../../../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
    return 2 * asin(z / 2);
  });

  // ../../../../../../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js
  var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
    return (c = acos(c)) && c / sin(c);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
    return z;
  });

  // ../../../../../../../node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi) {
    return [lambda, log(tan((halfPi + phi) / 2))];
  }
  mercatorRaw.invert = function(x2, y2) {
    return [x2, 2 * atan(exp(y2)) - halfPi];
  };

  // ../../../../../../../node_modules/d3-geo/src/projection/equirectangular.js
  function equirectangularRaw(lambda, phi) {
    return [lambda, phi];
  }
  equirectangularRaw.invert = equirectangularRaw;

  // ../../../../../../../node_modules/d3-geo/src/projection/gnomonic.js
  function gnomonicRaw(x2, y2) {
    var cy = cos(y2), k = cos(x2) * cy;
    return [cy * sin(x2) / k, sin(y2) / k];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);

  // ../../../../../../../node_modules/d3-geo/src/projection/naturalEarth1.js
  function naturalEarth1Raw(lambda, phi) {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    return [
      lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
      phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
    ];
  }
  naturalEarth1Raw.invert = function(x2, y2) {
    var phi = y2, i = 25, delta;
    do {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y2) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
    } while (abs(delta) > epsilon3 && --i > 0);
    return [
      x2 / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
      phi
    ];
  };

  // ../../../../../../../node_modules/d3-geo/src/projection/orthographic.js
  function orthographicRaw(x2, y2) {
    return [cos(y2) * sin(x2), sin(y2)];
  }
  orthographicRaw.invert = azimuthalInvert(asin);

  // ../../../../../../../node_modules/d3-geo/src/projection/stereographic.js
  function stereographicRaw(x2, y2) {
    var cy = cos(y2), k = 1 + cos(x2) * cy;
    return [cy * sin(x2) / k, sin(y2) / k];
  }
  stereographicRaw.invert = azimuthalInvert(function(z) {
    return 2 * atan(z);
  });

  // ../../../../../../../node_modules/d3-geo/src/projection/transverseMercator.js
  function transverseMercatorRaw(lambda, phi) {
    return [log(tan((halfPi + phi) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x2, y2) {
    return [-y2, 2 * atan(exp(x2)) - halfPi];
  };

  // ../../../../../../../node_modules/@turf/union/dist/es/index.js
  var import_polygon_clipping2 = __toESM(require_polygon_clipping_umd(), 1);

  // ../../../../../../../node_modules/@turf/intersect/dist/es/index.js
  var import_polygon_clipping3 = __toESM(require_polygon_clipping_umd(), 1);
  function intersect(poly1, poly2, options) {
    if (options === void 0) {
      options = {};
    }
    var geom1 = getGeom(poly1);
    var geom2 = getGeom(poly2);
    var intersection = import_polygon_clipping3.default.intersection(geom1.coordinates, geom2.coordinates);
    if (intersection.length === 0)
      return null;
    if (intersection.length === 1)
      return polygon(intersection[0], options.properties);
    return multiPolygon(intersection, options.properties);
  }

  // ../../../../../../../node_modules/@turf/dissolve/dist/es/index.js
  var import_polygon_clipping4 = __toESM(require_polygon_clipping_umd(), 1);

  // ../../../../../../../node_modules/@turf/hex-grid/dist/es/index.js
  function hexGrid(bbox3, cellSide, options) {
    if (options === void 0) {
      options = {};
    }
    var clonedProperties = JSON.stringify(options.properties || {});
    var west = bbox3[0], south = bbox3[1], east = bbox3[2], north = bbox3[3];
    var centerY = (south + north) / 2;
    var centerX = (west + east) / 2;
    var xFraction = cellSide * 2 / es_default2([west, centerY], [east, centerY], options);
    var cellWidth = xFraction * (east - west);
    var yFraction = cellSide * 2 / es_default2([centerX, south], [centerX, north], options);
    var cellHeight = yFraction * (north - south);
    var radius = cellWidth / 2;
    var hex_width = radius * 2;
    var hex_height = Math.sqrt(3) / 2 * cellHeight;
    var box_width = east - west;
    var box_height = north - south;
    var x_interval = 3 / 4 * hex_width;
    var y_interval = hex_height;
    var x_span = (box_width - hex_width) / (hex_width - radius / 2);
    var x_count = Math.floor(x_span);
    var x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2 + x_interval / 2;
    var y_count = Math.floor((box_height - hex_height) / hex_height);
    var y_adjust = (box_height - y_count * hex_height) / 2;
    var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
    if (hasOffsetY) {
      y_adjust -= hex_height / 4;
    }
    var cosines = [];
    var sines = [];
    for (var i = 0; i < 6; i++) {
      var angle = 2 * Math.PI / 6 * i;
      cosines.push(Math.cos(angle));
      sines.push(Math.sin(angle));
    }
    var results = [];
    for (var x2 = 0; x2 <= x_count; x2++) {
      for (var y2 = 0; y2 <= y_count; y2++) {
        var isOdd = x2 % 2 === 1;
        if (y2 === 0 && isOdd)
          continue;
        if (y2 === 0 && hasOffsetY)
          continue;
        var center_x = x2 * x_interval + west - x_adjust;
        var center_y = y2 * y_interval + south + y_adjust;
        if (isOdd) {
          center_y -= hex_height / 2;
        }
        if (options.triangles === true) {
          hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function(triangle) {
            if (options.mask) {
              if (intersect(options.mask, triangle))
                results.push(triangle);
            } else {
              results.push(triangle);
            }
          });
        } else {
          var hex = hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);
          if (options.mask) {
            if (intersect(options.mask, hex))
              results.push(hex);
          } else {
            results.push(hex);
          }
        }
      }
    }
    return featureCollection(results);
  }
  function hexagon(center2, rx, ry, properties, cosines, sines) {
    var vertices = [];
    for (var i = 0; i < 6; i++) {
      var x2 = center2[0] + rx * cosines[i];
      var y2 = center2[1] + ry * sines[i];
      vertices.push([x2, y2]);
    }
    vertices.push(vertices[0].slice());
    return polygon([vertices], properties);
  }
  function hexTriangles(center2, rx, ry, properties, cosines, sines) {
    var triangles = [];
    for (var i = 0; i < 6; i++) {
      var vertices = [];
      vertices.push(center2);
      vertices.push([center2[0] + rx * cosines[i], center2[1] + ry * sines[i]]);
      vertices.push([
        center2[0] + rx * cosines[(i + 1) % 6],
        center2[1] + ry * sines[(i + 1) % 6]
      ]);
      vertices.push(center2);
      triangles.push(polygon([vertices], properties));
    }
    return triangles;
  }
  var es_default33 = hexGrid;

  // ../../../../../../../node_modules/@turf/mask/dist/es/index.js
  var import_polygon_clipping5 = __toESM(require_polygon_clipping_umd(), 1);

  // grids.ts
  var import_osmtogeojson = __toESM(require_osmtogeojson());

  // coeffs20230705.ts
  var STROKES_REMAINING_COEFFS = {
    "green": [0.8986078196513652, 0.29469765981888985, -0.032029867458429805, 0.0018551701773920994, -5886489790163256e-20, 1070962065384032e-21, -11166446779717697e-24, 6207738674465262e-26, -14267436581703006e-29],
    "fairway": [1.7584282877168174, 0.04250904605668524, -7423764507829129e-19, 6569707153764233e-21, -30977756632711525e-24, 8367957576883257e-26, -13050071116108684e-29, 10972673814800688e-32, -38663295195090656e-36],
    "rough": [1.8916873419240754, 0.04627672970406796, -8446903788844877e-19, 8018411520958444e-21, -41372650027143274e-24, 12324504918216484e-26, -21202021781645599e-29, 19583437507064683e-32, -7525901826011706e-35],
    "bunker": [2.220352744173441, 0.018980154368388916, -9437083112133279e-20, -36850669792042787e-23, 6611615157465972e-24, -30244113540371936e-27, 6619732255619124e-29, -713238060773297e-31, 30311272989590774e-36],
    "recovery": [3.307362086547302, 0.010609031555978476, -2560678610039765e-20, -8095622682925617e-22, 7504655372784836e-24, -2721007124468904e-26, 49428875618964227e-30, -44627338757642523e-33, 15865514824311754e-36],
    "tee": [-3.5788887026946, 0.18058363894139925, -0.001891979789983763, 9130820506854418e-21, -1745801357834769e-23, -11014332225511787e-27, 10006598437385122e-29, -14956128989260208e-32, 7418617737686934e-35],
    "penalty": [2.758428287716816, 0.042509046056685255, -7423764507829126e-19, 6569707153764227e-21, -30977756632711486e-24, 8367957576883243e-26, -13050071116108656e-29, 10972673814800659e-32, -3866329519509051e-35],
    "water_hazard": [2.758428287716816, 0.042509046056685255, -7423764507829126e-19, 6569707153764227e-21, -30977756632711486e-24, 8367957576883243e-26, -13050071116108656e-29, 10972673814800659e-32, -3866329519509051e-35],
    "lateral_water_hazard": [2.758428287716816, 0.042509046056685255, -7423764507829126e-19, 6569707153764227e-21, -30977756632711486e-24, 8367957576883243e-26, -13050071116108656e-29, 10972673814800659e-32, -3866329519509051e-35],
    "driving_range": [2.758428287716816, 0.042509046056685255, -7423764507829126e-19, 6569707153764227e-21, -30977756632711486e-24, 8367957576883243e-26, -13050071116108656e-29, 10972673814800659e-32, -3866329519509051e-35],
    "clubhouse": [2.758428287716816, 0.042509046056685255, -7423764507829126e-19, 6569707153764227e-21, -30977756632711486e-24, 8367957576883243e-26, -13050071116108656e-29, 10972673814800659e-32, -3866329519509051e-35],
    "out_of_bounds": [3.7584282877168107, 0.042509046056685505, -7423764507829175e-19, 6569707153764276e-21, -3097775663271175e-23, 8367957576883327e-26, -13050071116108808e-29, 10972673814800805e-32, -386632951950911e-34]
  };
  var HOLE_OUT_COEFFS = {
    "green": {
      "coeffs": [
        [1.000201369198856, -0.017643532744055317, 0.09303020226131234, -0.13693668008804696],
        [1.4244133445617677, -0.5917358227287367, 0.10764472109007754, -0.008596453203824841, 21470729177791603e-22, 5127337399940156e-20, -37894361127000674e-22, 11604473386399543e-23, -13396353394714865e-25],
        [0.05946821424580236, -0.002121942064388387]
      ],
      "domains": [
        [0, 0.88],
        [0.88, 22.78],
        [15.87, 22.78]
      ]
    }
  };

  // grids.ts
  var gridTypes = { STROKES_GAINED: "Strokes Gained", TARGET: "Best Aim" };
  var OVERPASS_URL = "https://overpass-api.de/api/interpreter";
  var NOMINATIM_URL = "https://nominatim.openstreetmap.org/search?q=";
  function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function setCache(key, json) {
    localStorage.setItem(
      key,
      JSON.stringify({ ...json })
    );
  }
  function readCache(key) {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  }
  function deleteCache(key) {
    localStorage.removeItem(key);
  }
  function cacheKey(courseParams) {
    return `courseData-${courseParams.name}-${courseParams.id}`;
  }
  function courseSearch(query) {
    return fetch(`${NOMINATIM_URL}${encodeURIComponent(query)}&format=json&namedetails=1`).then(function(response) {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    }).then((response) => {
      return response.filter((el) => el.type == "golf_course");
    }).catch(function(error) {
      console.error("Error:", error);
    });
  }
  function fetchOSMData(query, storageKey) {
    let opt = {
      method: "POST",
      mode: "cors",
      redirect: "follow",
      headers: {
        Accept: "*"
      },
      body: `data=${encodeURIComponent(query)}`
    };
    console.debug("Querying for data from OSM under key " + storageKey);
    return fetch(OVERPASS_URL, opt).then((response) => {
      if (!response.ok) {
        return Promise.reject(new Error("Request failed: HTTP " + response.status));
      }
      return response.json();
    }).then((data) => {
      console.debug("Succesfully downloaded OSM polys, starting processing");
      data = (0, import_osmtogeojson.default)(data);
      data = scrubOSMData(data);
      if (data.features.length > 0) {
        console.debug("Succesfully processed OSM polys, caching as " + storageKey);
        setCache(storageKey, data);
        return data;
      } else {
        return Promise.reject(new Error("No polygons returned"));
      }
    }).catch((error) => console.error(error));
  }
  function fetchGolfCourseData(courseParams, force) {
    if (!courseParams) {
      console.error("Cannot fetch from OSM with no course");
      throw new Error("Must provide a courseParams");
    } else if (!(courseParams["name"] || courseParams["id"])) {
      console.error("Cannot fetch from OSM with no course identifiers");
      throw new Error("Must provide either name or id");
    }
    let courseName = courseParams["name"];
    let courseId = courseParams["id"];
    let storageKey = cacheKey(courseParams);
    let cache = readCache(storageKey);
    if (!force && cache) {
      return Promise.resolve(cache);
    }
    let query = "";
    if (courseId) {
      let components = courseId.split("-");
      let type = components[1];
      let id = components[2];
      query = `[out:json];
        (${type}(${id});)-> .bound;
        (.bound;map_to_area;)->.golf_area;
        (way(area.golf_area)[golf];
        relation(area.golf_area)[golf];
        way(area.golf_area)[leisure=golf_course];
        relation(area.golf_area)[leisure=golf_course];
        .bound;
        );
        out geom;`;
      return fetchOSMData(query, storageKey);
    } else if (courseName) {
      query = `[out:json];
        area[name="${courseName}"][leisure=golf_course]->.golf_area;
        (way(area.golf_area)[golf];
        relation(area.golf_area)[golf];
        way[name="${courseName}"][leisure=golf_course];
        relation[name="${courseName}"][leisure=golf_course];
        );
        out geom;`;
    }
    return fetchOSMData(query, storageKey);
  }
  function getGolfCourseData(courseParams) {
    let storageKey = cacheKey(courseParams);
    let polys = readCache(storageKey);
    if (polys) {
      return polys;
    } else {
      console.warn("Course has no polys or not found");
      return Error("No data available");
    }
  }
  function getGolfHoleLine(courseParams, holeNumber) {
    let data = getGolfCourseData(courseParams);
    if (data instanceof Error) {
      return data;
    }
    return getCluster(data, { "golf": "hole", "ref": holeNumber }).features[0];
  }
  function getGolfHolePolys(courseParams, holeNumber) {
    let data = getGolfCourseData(courseParams);
    if (data instanceof Error) {
      return data;
    }
    let line = getGolfHoleLine(courseParams, holeNumber);
    if (line instanceof Error) {
      let msg = "Bad data set from OSM";
      console.error(msg);
      deleteCache(cacheKey(courseParams));
      throw new Error(msg);
    }
    if (!line) {
      let courseName = courseParams["name"];
      let msg = `No hole line found for course ${courseName} hole ${holeNumber}`;
      console.warn(msg);
      throw new Error(msg);
    }
    return featureIntersect(data, line);
  }
  function getGolfHoleGreen(courseParams, holeNumber) {
    let data = getGolfHolePolys(courseParams, holeNumber);
    if (data instanceof Error) {
      return data;
    }
    return getCluster(data, { "terrainType": "green" });
  }
  function getGolfHoleGreenCenter(courseParams, holeNumber) {
    const green = getGolfHoleGreen(courseParams, holeNumber);
    return es_default8(green).geometry.coordinates;
  }
  function scrubOSMData(geojson) {
    for (let feature2 of geojson.features) {
      let props = feature2.properties;
      if (props.golf) {
        props["terrainType"] = props.golf;
      }
      if (typeof props.par === "string") {
        props.par = Number(props.par);
      }
      if (typeof props.ref === "string") {
        props.ref = Number(props.ref);
      }
      if (typeof props.handicap === "string") {
        props.handicap = Number(props.handicap);
      }
    }
    presortTerrain(geojson);
    return geojson;
  }
  function presortTerrain(collection) {
    const terrainPriority = ["green", "tee", "bunker", "fairway", "hazard", "penalty"];
    collection.features.sort((a, b) => {
      let aPriority = terrainPriority.indexOf(a.properties.terrainType);
      let bPriority = terrainPriority.indexOf(b.properties.terrainType);
      if (aPriority === -1) {
        aPriority = terrainPriority.length;
      }
      if (bPriority === -1) {
        bPriority = terrainPriority.length;
      }
      return aPriority - bPriority;
    });
    return collection;
  }
  function findBoundaries(collection) {
    return getCluster(collection, { "leisure": "golf_course" });
  }
  function turfbbToleafbb(turfbb) {
    let bb = [...turfbb];
    bb.reverse();
    return [bb.slice(0, 2), bb.slice(2)];
  }
  function getGolfCourseBbox(courseParams) {
    let course = getGolfCourseData(courseParams);
    if (course instanceof Error) {
      return;
    } else {
      return turfbbToleafbb(es_default(course));
    }
  }
  function getGolfHoleBbox(courseParams, holeNumber) {
    let line = getGolfHoleLine(courseParams, holeNumber);
    if (line instanceof Error) {
      return;
    } else if (line) {
      return turfbbToleafbb(es_default(line));
    }
  }
  function findTerrainType(point2, collection, bounds) {
    if (!bounds) {
      bounds = findBoundaries(collection);
    }
    if (bounds.features.every((bound) => !booleanPointInPolygon(point2, bound))) {
      return "out_of_bounds";
    }
    for (let feature2 of collection.features) {
      let featureType = getType(feature2);
      if (featureType === "Polygon" && booleanPointInPolygon(point2, feature2)) {
        if (feature2.properties.terrainType) {
          return feature2.properties.terrainType;
        }
      }
    }
    return "rough";
  }
  function hexGridCreate(feature2, options) {
    let maximum_cells = 2e3;
    if (options && options.maximum_cells) {
      maximum_cells = options.maximum_cells;
    }
    const bbox3 = es_default(feature2);
    const _x = Math.sqrt(area(feature2) / (maximum_cells * (3 * Math.sqrt(3) / 2))) / 1e3;
    const minX = 0.16 / 1e3;
    const maxX = 10 / 1e3;
    const x2 = Math.min(Math.max(minX, _x), maxX);
    let grid_options = { units: "kilometers", mask: feature2 };
    return es_default33(bbox3, x2, grid_options);
  }
  function probability(stddev, x2, mean = 0) {
    const coefficient = 1 / (stddev * Math.sqrt(2 * Math.PI));
    const exponent = -((x2 - mean) ** 2) / (2 * stddev ** 2);
    return coefficient * Math.exp(exponent);
  }
  function probabilityGrid(grid, aimPoint, dispersionNumber) {
    let total = 0;
    grid.features.forEach((feature2) => {
      const distance2 = es_default2(es_default8(feature2), aimPoint, { units: "kilometers" }) * 1e3;
      let p = probability(dispersionNumber, distance2);
      feature2.properties.probability = p;
      feature2.properties.distanceToAim = distance2;
      total += p;
    });
    grid.features.forEach((feature2) => {
      feature2.properties.probability = feature2.properties.probability / total;
    });
  }
  function holeOutRate(distanceToHole, terrainType) {
    if (!(terrainType in HOLE_OUT_COEFFS)) {
      console.warn("No polynomial for terrainType" + terrainType);
      return 0;
    }
    const polys = HOLE_OUT_COEFFS[terrainType];
    let domainIndex;
    for (let i = 0; i < polys.domains.length; i++) {
      if (distanceToHole >= polys.domains[i][0] && distanceToHole <= polys.domains[i][1]) {
        domainIndex = i;
        break;
      }
    }
    if (domainIndex === void 0) {
      console.error("Distance to hole is outside the supported range.");
      return 0;
    }
    let coeffs = polys.coeffs[domainIndex];
    let rate = coeffs.reduce((acc, coeff, index) => acc + coeff * Math.pow(distanceToHole, index), 0);
    rate = Math.max(0, Math.min(1, rate));
    return rate;
  }
  function addHoleOut(hexGrid2, distanceToHole, terrainType, holePoint) {
    console.debug(`Accomodating hole outs from ${distanceToHole}m on ${terrainType}`);
    const hor = holeOutRate(distanceToHole, terrainType);
    if (hor == 0) {
      console.debug("0% chance, skip");
      return hexGrid2;
    }
    console.debug(`${(100 * hor).toFixed(1)}% from ${distanceToHole}m on ${terrainType}`);
    hexGrid2.features.forEach((feature2) => feature2.properties.probability *= 1 - hor);
    const holeFeature = es_default7(holePoint, 2e-4, { units: "kilometers" });
    holeFeature.properties = {
      "distanceToHole": 0,
      "terrainType": "hole",
      "probability": hor,
      "strokesRemaining": 0
    };
    hexGrid2.features.push(holeFeature);
    return hexGrid2;
  }
  function strokesRemaining(distanceToHole, terrainType) {
    if (!(terrainType in STROKES_REMAINING_COEFFS)) {
      console.error("No polynomial for terrainType" + terrainType);
      return;
    }
    let totalStrokes = STROKES_REMAINING_COEFFS[terrainType].reduce((acc, coeff, index) => acc + coeff * Math.pow(distanceToHole, index), 0);
    let clippedStrokes = Math.min(Math.max(totalStrokes, -7), 7);
    return clippedStrokes;
  }
  function strokesRemainingFrom(feature2, holeCoordinate, courseParams) {
    let golfCourseData = getGolfCourseData(courseParams);
    if (golfCourseData instanceof Error) {
      return;
    }
    const center2 = es_default8(feature2);
    const distanceToHole = es_default2(center2, holeCoordinate, { units: "kilometers" }) * 1e3;
    const terrainType = findTerrainType(center2, golfCourseData);
    return strokesRemaining(distanceToHole, terrainType);
  }
  function strokesGained(grid, holeCoordinate, strokesRemainingStart, golfCourseData) {
    let bounds = findBoundaries(golfCourseData);
    grid.features.forEach((feature2) => {
      let props = feature2.properties;
      if (props.strokesRemaining === void 0) {
        const center2 = es_default8(feature2);
        props.distanceToHole = es_default2(center2, holeCoordinate, { units: "kilometers" }) * 1e3;
        props.terrainType = findTerrainType(center2, golfCourseData, bounds);
        props.strokesRemaining = strokesRemaining(props.distanceToHole, props.terrainType);
      }
      props.strokesGained = strokesRemainingStart - props.strokesRemaining - 1;
    });
  }
  function weightStrokesGained(grid) {
    featureEach(grid, (feature2) => {
      let props = feature2.properties;
      props.weightedStrokesGained = props.strokesGained * props.probability;
    });
  }
  function sgGrid(startCoordinate, aimCoordinate, holeCoordinate, dispersionNumber, courseParams) {
    const golfCourseData = getGolfCourseData(courseParams);
    if (golfCourseData instanceof Error) {
      return golfCourseData;
    }
    const startPoint = es_default4(point(startCoordinate));
    const aimPoint = es_default4(point(aimCoordinate));
    const holePoint = es_default4(point(holeCoordinate));
    if (dispersionNumber < 0) {
      const distanceToAim = es_default2(startPoint, aimPoint, { units: "kilometers" }) * 1e3;
      dispersionNumber = -dispersionNumber * distanceToAim;
      dispersionNumber = Math.max(0.5, dispersionNumber);
    }
    const aimWindow = es_default7(aimPoint, 3 * dispersionNumber / 1e3, { units: "kilometers" });
    const terrainTypeStart = findTerrainType(startPoint, golfCourseData);
    const distanceToHole = es_default2(startPoint, holePoint, { units: "kilometers" }) * 1e3;
    const strokesRemainingStart = strokesRemaining(distanceToHole, terrainTypeStart);
    let hexGrid2 = hexGridCreate(aimWindow);
    probabilityGrid(hexGrid2, aimPoint, dispersionNumber);
    addHoleOut(hexGrid2, distanceToHole, terrainTypeStart, holePoint);
    strokesGained(hexGrid2, holePoint, strokesRemainingStart, golfCourseData);
    weightStrokesGained(hexGrid2);
    const weightedStrokesGained = hexGrid2.features.reduce((sum2, feature2) => sum2 + feature2.properties.weightedStrokesGained, 0);
    console.log("Total Weighted Strokes Gained:", weightedStrokesGained);
    const properties = {
      type: gridTypes.STROKES_GAINED,
      strokesRemainingStart,
      distanceToHole,
      weightedStrokesGained
    };
    hexGrid2.properties = properties;
    return hexGrid2;
  }
  function targetGrid(startCoordinate, aimCoordinate, holeCoordinate, dispersionNumber, courseParams) {
    const golfCourseData = getGolfCourseData(courseParams);
    if (golfCourseData instanceof Error) {
      return golfCourseData;
    }
    const startPoint = es_default4(point(startCoordinate));
    const aimPoint = es_default4(point(aimCoordinate));
    const holePoint = es_default4(point(holeCoordinate));
    if (dispersionNumber < 0) {
      const distanceToAim = es_default2(startPoint, aimPoint, { units: "kilometers" }) * 1e3;
      dispersionNumber = -dispersionNumber * distanceToAim;
      dispersionNumber = Math.max(0.5, dispersionNumber);
    }
    const terrainTypeStart = findTerrainType(startPoint, golfCourseData);
    const distanceToHole = es_default2(startPoint, holePoint, { units: "kilometers" }) * 1e3;
    const strokesRemainingStart = strokesRemaining(distanceToHole, terrainTypeStart);
    const outcomeWindow = es_default7(aimPoint, 2 * 3 * dispersionNumber / 1e3, { units: "kilometers" });
    let outcomeGrid = hexGridCreate(outcomeWindow, { "maximum_cells": 8e3 });
    strokesGained(outcomeGrid, holePoint, strokesRemainingStart, golfCourseData);
    const aimWindow = es_default7(aimPoint, dispersionNumber / 1e3, { units: "kilometers" });
    const aimGrid = es_default3(featureWithin(outcomeGrid, aimWindow));
    aimGrid.features.forEach((feature2) => feature2.properties = {});
    console.log(`Iterating through aim grid of ${aimGrid.features.length} cells`);
    let ix = 0;
    for (let cell of aimGrid.features) {
      const subAimPoint = es_default8(cell);
      const subWindow = es_default7(subAimPoint, 3 * dispersionNumber / 1e3, { units: "kilometers" });
      const subGrid = featureWithin(outcomeGrid, subWindow);
      probabilityGrid(subGrid, subAimPoint, dispersionNumber);
      addHoleOut(subGrid, distanceToHole, terrainTypeStart, holePoint);
      weightStrokesGained(subGrid);
      const weightedStrokesGained = subGrid.features.reduce((sum2, feature2) => sum2 + feature2.properties.weightedStrokesGained, 0);
      cell.properties.weightedStrokesGained = weightedStrokesGained;
      console.log(`Processed cell ${ix}, wsg = ${weightedStrokesGained}`);
      ix++;
    }
    const aimCells = aimGrid.features.filter((feature2) => booleanContains(feature2, aimPoint));
    const baseSg = aimCells.reduce((acc, cell) => acc + cell.properties.weightedStrokesGained, 0) / aimCells.length;
    featureEach(aimGrid, (feature2) => {
      let props = feature2.properties;
      props.relativeStrokesGained = props.weightedStrokesGained - baseSg;
    });
    const properties = {
      type: gridTypes.TARGET,
      strokesRemainingStart,
      distanceToHole,
      weightedStrokesGained: baseSg
    };
    aimGrid.properties = properties;
    return aimGrid;
  }
  function featureFilter(collection, filter) {
    const _featureFilterReduce = (acc, feature2) => {
      if (filter(feature2))
        acc.push(feature2);
      return acc;
    };
    return featureCollection(
      featureReduce(collection, _featureFilterReduce, [])
    );
  }
  function featureIntersect(collection, intersects2) {
    return featureFilter(collection, (feature2) => booleanIntersects(intersects2, feature2));
  }
  function featureWithin(collection, container) {
    return featureFilter(collection, (feature2) => es_default18(feature2, container));
  }
  function erf(x2, mean, standardDeviation) {
    const z = (x2 - mean) / (standardDeviation * Math.sqrt(2));
    const t = 1 / (1 + 0.3275911 * Math.abs(z));
    const a1 = 0.254829592;
    const a2 = -0.284496736;
    const a3 = 1.421413741;
    const a4 = -1.453152027;
    const a5 = 1.061405429;
    return 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-z * z);
  }

  // tracker.ts
  var import_chroma_js = __toESM(require_chroma());
  var mapView;
  var round = defaultRound();
  var currentHole = round.holes.at(-1);
  var currentStrokeIndex = currentHole.strokes.length;
  var layers = {};
  var actionStack = [];
  var currentPosition;
  var currentPositionEnabled;
  var holeSelector;
  var activeStroke;
  function strokeCreate(position, options = {}) {
    undoCreate("strokeCreate");
    const stroke = {
      index: currentStrokeIndex,
      hole: currentHole.number,
      start: {
        x: position.coords.longitude,
        y: position.coords.latitude,
        crs: "EPSG:4326"
      },
      ...options
    };
    if (currentHole.pin) {
      stroke.aim = { ...currentHole.pin };
    }
    currentHole.strokes.push(stroke);
    currentStrokeIndex++;
    strokeMarkerCreate(stroke);
    rerender();
  }
  function strokeDelete(holeNumber, strokeIndex) {
    console.debug(`Deleting stroke ${strokeIndex} from hole ${holeNumber}`);
    let hole = round.holes.find((h) => h.number === holeNumber);
    if (hole) {
      undoCreate("strokeDelete");
      hole.strokes.splice(strokeIndex, 1);
      hole.strokes.forEach((stroke, index) => stroke.index = index);
      currentStrokeIndex = hole.strokes.length;
      holeViewDelete();
      holeViewCreate(hole);
      rerender();
    }
  }
  function strokeMove(holeNumber, strokeIndex, offset) {
    console.debug(`Moving stroke ${strokeIndex} from hole ${holeNumber} by ${offset}`);
    undoCreate("strokeMove");
    const hole = round.holes[holeNumber - 1];
    const mover = hole.strokes[strokeIndex];
    if (offset < 0) {
      offset = Math.max(offset, -strokeIndex);
    } else {
      offset = Math.min(offset, hole.strokes.length - strokeIndex - 1);
    }
    hole.strokes.splice(strokeIndex, 1);
    hole.strokes.splice(strokeIndex + offset, 0, mover);
    hole.strokes.forEach((stroke, index) => stroke.index = index);
    rerender();
  }
  function strokeDistance(stroke) {
    let distance2 = 0;
    const hole = round.holes[stroke.hole - 1];
    const following = hole.strokes[stroke.index + 1];
    if (following) {
      distance2 = getDistance(stroke.start, following.start);
    } else if (hole.pin) {
      distance2 = getDistance(stroke.start, hole.pin);
    }
    return distance2;
  }
  function strokeMarkerCreate(stroke, options) {
    console.debug(`Creating stroke markers for stroke ${stroke.index}`);
    const coordinate = stroke.start;
    const icon2 = L2.icon({
      iconUrl: "static/img/circle-ypad.png",
      // replace with the path to your flag icon
      iconSize: [30, 45],
      // size of the icon
      iconAnchor: [15, 30]
    });
    let opt = { draggable: true, opacity: 0.8, icon: icon2, strokeIndex: stroke.index };
    if (options !== void 0) {
      opt = {
        ...opt,
        ...options
      };
    }
    let id = strokeMarkerID(stroke);
    let marker2 = markerCreate(id, coordinate, opt);
    marker2.bindTooltip(
      function() {
        return strokeTooltipText(stroke);
      },
      { permanent: true, direction: "top", offset: [0, -10] }
    );
    marker2.on("click", strokeMarkerActivateCallback(marker2));
  }
  function strokeMarkerUpdate() {
    for (const hole of round.holes) {
      for (const stroke of hole.strokes) {
        let marker2 = layerRead(strokeMarkerID(stroke));
        if (!marker2) {
          continue;
        }
        let tooltip = marker2.getTooltip();
        if (tooltip) {
          tooltip.update();
        }
      }
    }
  }
  function strokeMarkerActivateCallback(marker2) {
    return () => strokeMarkerActivate(marker2);
  }
  function strokeMarkerActivate(marker2) {
    if (activeStroke) {
      strokeMarkerDeactivate();
    }
    marker2.getElement().classList.add("active-marker");
    activeStroke = currentHole.strokes[marker2.options.strokeIndex];
    if (activeStroke.aim) {
      strokeMarkerAimCreate();
    } else {
      strokeMarkerAimCreateButton.classList.remove("inactive");
    }
    mapView.addEventListener("click", strokeMarkerDeactivate);
  }
  function strokeMarkerDeactivate(e) {
    if (e && e.originalEvent.target.classList.contains("leaflet-pane")) {
      return;
    }
    if (activeStroke) {
      let activeStrokeMarker = layerRead(strokeMarkerID(activeStroke));
      activeStrokeMarker.getElement().classList.remove("active-marker");
      activeStroke = null;
      strokeMarkerAimDelete();
      mapView.removeEventListener("click", strokeMarkerDeactivate);
    }
  }
  function strokeMarkerAimCreate(e) {
    mapView.off("click", strokeMarkerAimCreate);
    if (!activeStroke) {
      console.error("Cannot add aim, no active stroke");
      return;
    }
    if (e) {
      activeStroke.aim = {
        x: e.latlng.lng,
        y: e.latlng.lat,
        crs: "EPSG:4326"
      };
    }
    let marker2 = markerCreate("active_aim", activeStroke.aim);
    marker2.bindTooltip(strokeMarkerAimTooltip, { permanent: true, direction: "top", offset: [-15, 0] });
    let ring = L2.circle(marker2.getLatLng(), { radius: activeStroke.dispersion, color: "#fff", opacity: 0.5, weight: 2 });
    layerCreate("active_aim_ring", ring);
    gridCreate();
    activeStrokeStatsCreate();
  }
  function strokeMarkerAimTooltip() {
    const aimDistance = getDistance(activeStroke.start, activeStroke.aim).toFixed(1);
    const pinDistance = getDistance(activeStroke.aim, currentHole.pin).toFixed(1);
    let text = `${aimDistance}m to aim<br> ${pinDistance}m to pin`;
    const sggrid = layerRead("active_grid");
    if (sggrid && sggrid.options.grid) {
      const wsg = sggrid.options.grid.properties.weightedStrokesGained.toFixed(3);
      text += `<br> SG Aim ${wsg}`;
    }
    return text;
  }
  function strokeMarkerAimUpdate() {
    try {
      const marker2 = layerRead("active_aim");
      marker2.getTooltip().update();
      layerRead("active_aim_ring").setLatLng(marker2.getLatLng());
    } catch (e) {
      return;
    }
  }
  function strokeMarkerAimDelete() {
    strokeMarkerAimCreateButton.classList.add("inactive");
    layerDelete("active_aim");
    layerDelete("active_aim_ring");
    gridDelete();
    activeStrokeStatsDelete();
  }
  function strokeMarkerID(stroke) {
    return `stroke_marker_${stroke.index}_hole_${stroke.hole}`;
  }
  function strokeTooltipText(stroke) {
    const club = stroke.club;
    const distance2 = strokeDistance(stroke).toFixed(1);
    return `${club} (${distance2}m)`;
  }
  function gridCreate(type) {
    if (type == gridTypes.STROKES_GAINED) {
      sgGridCreate();
    } else if (type == gridTypes.TARGET) {
      targetGridCreate();
    } else {
      sgGridCreate();
    }
  }
  function gridDelete() {
    aimStatsDelete();
    layerDelete("active_grid");
  }
  function gridUpdate(type) {
    if (!type) {
      let layer = layerRead("active_grid");
      if (layer) {
        type = layer.options.grid.properties.type;
      }
    }
    gridDelete();
    if (activeStroke && currentHole.pin) {
      return Promise.resolve(gridCreate(type));
    } else {
      return Promise.reject(new Error("No grid to update"));
    }
  }
  function sgGridCreate() {
    if (!activeStroke) {
      console.error("No active stroke, cannot create sg grid");
      return;
    } else if (!currentHole.pin) {
      console.error("Pin not set, cannot create sg grid");
      return;
    } else if (layerRead("active_grid")) {
      console.warn("Grid already exists, recreating");
      layerDelete("active_grid");
    }
    const grid = sgGrid(
      [activeStroke.start.y, activeStroke.start.x],
      [activeStroke.aim.y, activeStroke.aim.x],
      [currentHole.pin.y, currentHole.pin.x],
      activeStroke.dispersion,
      roundCourseParams(round)
    );
    if (grid instanceof Error) {
      return;
    }
    const colorscale = import_chroma_js.default.scale("RdYlGn").domain([-0.25, 0.15]);
    const alphamid = 1 / grid.features.length;
    const clip = (num, min, max) => Math.min(Math.max(num, min), max);
    const options = {
      style: function(feature2) {
        return {
          stroke: false,
          fillColor: colorscale(feature2.properties.strokesGained).hex(),
          fillOpacity: clip(feature2.properties.probability / alphamid * 0.2, 0.1, 0.7)
        };
      },
      grid
    };
    const gridLayer = L2.geoJSON(grid, options).bindPopup(function(layer) {
      const props = layer.feature.properties;
      const sg = props.strokesGained;
      const prob = props.probability * 100;
      const er = erf(props.distanceToAim, 0, activeStroke.dispersion);
      const ptile = (1 - er) * 100;
      return `SG: ${sg.toFixed(3)}
            | ${props.terrainType}
            | Prob: ${prob.toFixed(2)}%
            | ${ptile.toFixed(1)}%ile`;
    });
    layerCreate("active_grid", gridLayer);
    aimStatsCreate();
  }
  function targetGridCreate() {
    if (!activeStroke) {
      console.error("No active stroke, cannot create sg grid");
      return;
    } else if (!currentHole.pin) {
      console.error("Pin not set, cannot create sg grid");
      return;
    } else if (layerRead("active_grid")) {
      console.warn("Grid already exists, recreating");
      layerDelete("active_grid");
    }
    const grid = targetGrid(
      [activeStroke.start.y, activeStroke.start.x],
      [activeStroke.aim.y, activeStroke.aim.x],
      [currentHole.pin.y, currentHole.pin.x],
      activeStroke.dispersion,
      roundCourseParams(round)
    );
    if (grid instanceof Error) {
      return;
    }
    const colorscale = import_chroma_js.default.scale("RdYlGn").domain([-0.25, 0.25]);
    const options = {
      style: function(feature2) {
        return {
          stroke: false,
          fillColor: colorscale(feature2.properties.relativeStrokesGained).hex(),
          fillOpacity: 0.5
        };
      },
      grid
    };
    const gridLayer = L2.geoJSON(grid, options).bindPopup(function(layer) {
      const props = layer.feature.properties;
      const wsg = props.weightedStrokesGained;
      const rwsg = props.relativeStrokesGained;
      return `SG: ${wsg.toFixed(3)}
            | vs Aim: ${rwsg.toFixed(3)}`;
    });
    layerCreate("active_grid", gridLayer);
    aimStatsCreate();
  }
  function strokelineCreate(hole) {
    console.debug("Creating stroke line for hole " + hole.number);
    let points = strokelinePoints(hole);
    if (points.length == 0) {
      return;
    }
    let strokeline = L2.polyline(points, {
      color: "white",
      weight: 2,
      interactive: false
    });
    let id = strokelineID(hole);
    layerCreate(id, strokeline);
    return strokeline;
  }
  function strokelineUpdate() {
    let layers2 = layerReadAll();
    let selected = {};
    for (let id in layers2) {
      if (id.includes("strokeline")) {
        selected[id] = layers2[id];
      }
    }
    for (let hole of round.holes) {
      let id = strokelineID(hole);
      if (Object.keys(selected).includes(id)) {
        selected[id].setLatLngs(strokelinePoints(hole));
      }
    }
  }
  function strokelinePoints(hole) {
    let points = [];
    hole.strokes.sort((a, b) => a.index - b.index).forEach((stroke) => {
      points.push(L2.latLng(stroke.start.y, stroke.start.x));
    });
    if (hole.pin) {
      points.push(L2.latLng(hole.pin.y, hole.pin.x));
    }
    return points;
  }
  function strokelineID(hole) {
    return `strokeline_hole_${hole.number}`;
  }
  function holeSelect(holeNum) {
    if (round.holes[holeNum - 1]) {
      currentHole = round.holes[holeNum - 1];
      currentStrokeIndex = currentHole.strokes.length;
    } else {
      console.error(`Attempted to select hole ${holeNum} but does not exist!`);
    }
    holeViewDelete();
    holeViewCreate(currentHole);
    rerender();
    mapRecenter("currentHole");
  }
  function holePinID(hole) {
    return `pin_hole_${hole.number}`;
  }
  function pinMarkerCreate(hole) {
    console.debug("Creating pin marker for hole " + hole.number);
    const coordinate = hole.pin;
    const holeNum = hole.number;
    const flagIcon = L2.icon({
      iconUrl: "static/img/flag.png",
      // replace with the path to your flag icon
      iconSize: [60, 60],
      // size of the icon
      iconAnchor: [30, 60]
    });
    const options = {
      draggable: true,
      icon: flagIcon,
      title: String(holeNum)
    };
    const id = holePinID(hole);
    markerCreate(id, coordinate, options);
  }
  function holeLineCreate(hole) {
    let line = getGolfHoleLine(roundCourseParams(round), hole.number);
    if (line instanceof Error) {
      return;
    }
    let layer = L2.geoJSON(line, {
      style: () => {
        return {
          stroke: true,
          color: "#fff",
          weight: 2,
          opacity: 0.5
        };
      },
      interactive: false
    });
    layerCreate(holeLineId(hole), layer);
  }
  function holeLineId(hole) {
    return `hole_${hole.number}_line`;
  }
  function roundCreate(courseParams) {
    undoCreate("roundCreate");
    let el = document.getElementById("courseName");
    if (!(el instanceof HTMLInputElement)) {
      return;
    }
    let inputVal = el.value;
    if (!courseParams && !inputVal) {
      console.error("Cannot create a round without any inputs");
      return;
    } else if (!courseParams) {
      let el2 = document.getElementById("courseName");
      if (!(el2 instanceof HTMLInputElement)) {
        return;
      }
      let inputVal2 = el2.value;
      courseParams = { courseName: inputVal2 };
    }
    let courseName = courseParams["name"];
    let courseId = courseParams["id"];
    localStorage.removeItem("golfData");
    round = { ...defaultRound(), course: courseName, courseId };
    currentHole = round.holes.at(0);
    currentStrokeIndex = 0;
    layerDeleteAll();
    fetchGolfCourseData(courseParams).then(roundUpdateWithData);
  }
  function roundUpdateWithData(courseData) {
    let lines = courseData.features.filter((feature2) => feature2.properties.golf && feature2.properties.golf == "hole");
    for (let line of lines) {
      const number = parseInt(line.properties.ref);
      const cog = getGolfHoleGreenCenter(roundCourseParams(round), number);
      const pin = {
        x: cog[0],
        y: cog[1],
        crs: "EPSG:4326"
      };
      let hole = { ...defaultCurrentHole(), number, pin };
      if (line.properties.par) {
        hole["par"] = parseInt(line.properties.par);
      }
      if (line.properties.handicap) {
        hole["handicap"] = parseInt(line.properties.handicap);
      }
      round.holes[hole.number - 1] = { ...hole, ...round.holes[hole.number - 1] };
    }
    holeSelectViewUpdate();
    rerender();
    for (let hole of round.holes) {
      holeViewCreate(hole);
    }
    mapRecenter("course");
  }
  function defaultCurrentHole() {
    return {
      number: 1,
      strokes: []
    };
  }
  function defaultRound() {
    return {
      date: (/* @__PURE__ */ new Date()).toISOString(),
      course: "Rancho Park Golf Course",
      holes: [defaultCurrentHole()]
    };
  }
  function roundCourseParams(round2) {
    return { "name": round2.course, "id": round2.courseId };
  }
  function clubStrokeCreate(position, club) {
    let options = {
      club: club.name,
      dispersion: club.dispersion
    };
    strokeCreate(position, options);
  }
  function clubReadAll() {
    return [
      { id: 1, name: "D", dispersion: 39 },
      { id: 2, name: "3w", dispersion: 35 },
      { id: 3, name: "3h", dispersion: 28 },
      { id: 4, name: "4i", dispersion: 23 },
      { id: 5, name: "5i", dispersion: 21.5 },
      { id: 6, name: "6i", dispersion: 17 },
      { id: 7, name: "7i", dispersion: 16 },
      { id: 8, name: "8i", dispersion: 13.5 },
      { id: 9, name: "9i", dispersion: 11.5 },
      { id: 10, name: "Pw", dispersion: 10 },
      { id: 11, name: "Aw", dispersion: 7.5 },
      { id: 12, name: "Sw", dispersion: 6 },
      { id: 13, name: "Lw", dispersion: 5 },
      { id: 14, name: "P", dispersion: -0.15 },
      { id: 15, name: "Penalty", dispersion: 1, class: "danger" },
      { id: 16, name: "Skip", dispersion: 1, class: "secondary" }
    ];
  }
  function saveData() {
    localStorage.setItem(
      "golfData",
      JSON.stringify({ ...round })
    );
  }
  function loadData() {
    const loadedData = JSON.parse(localStorage.getItem("golfData"));
    if (loadedData) {
      round = loadedData;
      console.log("Rehydrating round from localStorage");
      round.holes.forEach(function(hole) {
        holeViewCreate(hole);
      });
      const lastHole = round.holes.reduce((acc, hole) => {
        if (hole.strokes.length > 0) {
          return hole.number;
        } else {
          return acc;
        }
      }, 1);
      currentHole = round.holes[lastHole - 1];
      currentStrokeIndex = currentHole.strokes.length;
    }
    rerender();
  }
  function markerCreate(name, coordinate, options) {
    options = { draggable: true, ...options };
    const marker2 = L2.marker([coordinate.y, coordinate.x], options);
    marker2.on("drag", handleMarkerDrag(marker2, coordinate));
    marker2.on("dragend", () => rerender("dragend"));
    layerCreate(name, marker2);
    strokelineUpdate();
    return marker2;
  }
  function handleMarkerDrag(marker2, coordinate) {
    return function mdrag(event) {
      const position = marker2.getLatLng();
      coordinate.x = position.lng;
      coordinate.y = position.lat;
      rerender();
    };
  }
  function handleUndoActionClick() {
    undoRun();
  }
  function undoCreate(action) {
    actionStack.push({
      action,
      round: structuredClone(round),
      currentHoleNum: currentHole.number,
      currentStrokeIndex
    });
    console.debug(`Created a new undo point for action#${action}`);
  }
  function undoRun() {
    if (actionStack.length > 0) {
      const previousAction = actionStack.pop();
      round = previousAction.round;
      currentHole = round.holes[previousAction.currentHoleNum - 1];
      currentStrokeIndex = previousAction.currentStrokeIndex;
      holeSelect(previousAction.currentHoleNum);
      saveData();
    } else {
      document.getElementById("error").innerText = "No action to undo.";
      console.error("No action to undo.");
    }
  }
  function layerCreate(id, object2) {
    if (layers[id]) {
      console.error(`Layer Error: ID ${id} already exists!`);
      return;
    }
    layers[id] = object2;
    mapView.addLayer(object2);
  }
  function layerRead(id) {
    return layers[id];
  }
  function layerDelete(id) {
    if (layers[id]) {
      mapView.removeLayer(layers[id]);
      delete layers[id];
    }
  }
  function layerDeleteAll() {
    for (const id in layers) {
      mapView.removeLayer(layers[id]);
      delete layers[id];
    }
  }
  function layerReadAll() {
    return layers;
  }
  function getDistance(coord1, coord2) {
    const lat1 = coord1.y;
    const lon1 = coord1.x;
    const lat2 = coord2.y;
    const lon2 = coord2.x;
    const R = 6371e3;
    const phi1 = lat1 * Math.PI / 180;
    const phi2 = lat2 * Math.PI / 180;
    const deltaPhi = (lat2 - lat1) * Math.PI / 180;
    const deltaLambda = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance2 = R * c;
    return distance2;
  }
  function getLocation(force) {
    if (!currentPositionEnabled) {
      currentPositionUpdate();
      force = true;
    }
    return new Promise((resolve, reject) => {
      const position = currentPositionRead();
      if (position && !force) {
        resolve(position);
      } else if (!navigator.geolocation) {
        let e = new NoGeolocationError("Geolocation is not supported by this browser.", 2);
        reject(e);
      } else {
        navigator.geolocation.getCurrentPosition(resolve, reject);
      }
    });
  }
  function getLocationIf(condition) {
    return getLocation().then((position) => {
      if (condition(position)) {
        return position;
      } else {
        throw new Error("Failed conditional test");
      }
    });
  }
  function getClickLocation() {
    return new Promise((resolve) => {
      document.getElementById("error").innerText = "Click the map to set location";
      mapView.on("click", (e) => {
        const clickPosition = {
          coords: {
            latitude: e.latlng.lat,
            longitude: e.latlng.lng
          }
        };
        document.getElementById("error").innerText = "";
        resolve(clickPosition);
      });
    });
  }
  function getLocationOnMap() {
    return getLocationIf((position) => {
      const userLatLng = L2.latLng(position.coords.latitude, position.coords.longitude);
      return mapView.getBounds().contains(userLatLng);
    }).catch(getClickLocation);
  }
  function currentPositionRead() {
    return currentPosition;
  }
  function mapViewCreate(mapid) {
    var mapContainer = document.getElementById(mapid);
    var availableHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    var mapHeight = 0.8 * availableHeight;
    mapContainer.style.height = mapHeight + "px";
    mapView = L2.map(mapid).setView([36.567383, -121.947729], 18);
    L2.tileLayer("https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}", {
      attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery &copy; <a href="https://www.mapbox.com/">Mapbox</a>',
      maxZoom: 22,
      maxNativeZoom: 19,
      id: "mapbox/satellite-v9",
      tileSize: 512,
      zoomOffset: -1,
      accessToken: "pk.eyJ1IjoicnlhbmxjaGFuIiwiYSI6ImNsamwyb2JwcDBuYzMzbHBpb2l0dHg2ODIifQ.vkFG7K0DrbHs5O1W0CIvzw"
      // replace with your Mapbox access token
    }).addTo(mapView);
  }
  function mapRecenter(key) {
    let flyoptions = {
      animate: true,
      duration: 0.33
    };
    if (key == "course") {
      let bbox3 = getGolfCourseBbox(roundCourseParams(round));
      if (bbox3) {
        console.debug("Recentering on course");
        mapView.flyToBounds(bbox3, flyoptions);
      }
    } else if (key == "currentHole") {
      let bbox3 = getGolfHoleBbox(roundCourseParams(round), currentHole.number);
      if (bbox3) {
        console.debug("Recentering on current hole");
        mapView.flyToBounds(bbox3, flyoptions);
      } else if (currentHole.pin) {
        console.debug("Recentering on current pin");
        mapView.flyTo([currentHole.pin.y, currentHole.pin.x], 18, flyoptions);
      }
    } else if (!key || key == "currentPosition") {
      if (currentPositionEnabled && currentPosition) {
        console.debug("Recentering on current position");
        mapView.flyTo([currentPosition.coords.latitude, currentPosition.coords.longitude], 20, flyoptions);
      }
    }
  }
  function holeViewCreate(hole) {
    console.debug(`Rendering layers for hole ${hole.number}`);
    hole.strokes.forEach(function(stroke) {
      strokeMarkerCreate(stroke);
    });
    if (hole.pin) {
      pinMarkerCreate(hole);
    }
    strokelineCreate(hole);
    holeLineCreate(hole);
  }
  function holeViewDelete() {
    strokeMarkerDeactivate();
    const allLayers = layerReadAll();
    for (let id in allLayers) {
      if (id.includes("hole_") || id.includes("active_")) {
        layerDelete(id);
      }
    }
  }
  function holeSelectViewCreate(element) {
    holeSelector = element;
    holeSelectViewUpdate();
    element.addEventListener("change", function() {
      let selectedHoleNumber = parseInt(this.value, 10);
      holeSelect(selectedHoleNumber);
    });
  }
  function holeSelectViewUpdate() {
    if (!holeSelector) {
      return;
    }
    if (!(holeSelector instanceof HTMLSelectElement)) {
      return;
    }
    while (holeSelector.firstChild) {
      holeSelector.removeChild(holeSelector.firstChild);
    }
    for (let hole of round.holes) {
      if (!hole) {
        break;
      }
      let option = document.createElement("option");
      option.value = hole.number.toString();
      option.text = `Hole ${hole.number}`;
      holeSelector.appendChild(option);
    }
    holeSelector.value = currentHole.number.toString();
  }
  function currentPositionUpdate() {
    currentPositionEnabled = true;
    navigator.geolocation.watchPosition((position) => {
      const markerID = "currentPosition";
      currentPosition = position;
      let latlong = [position.coords.latitude, position.coords.longitude];
      let currentPositionMarker = layerRead(markerID);
      if (currentPositionMarker) {
        currentPositionMarker.setLatLng(latlong);
      } else {
        currentPositionMarker = L2.circleMarker(
          latlong,
          { radius: 10, fillColor: "#4A89F3", color: "#FFF", weight: 1, opacity: 0.8, fillOpacity: 0.8 }
        );
        layerCreate(markerID, currentPositionMarker);
      }
    }, showError, {
      enableHighAccuracy: true,
      timeout: 5e3,
      maximumAge: 1e3
    });
  }
  function roundViewUpdate() {
    const locationData = document.getElementById("locationData");
    locationData.textContent = JSON.stringify(
      { ...round },
      null,
      2
    );
  }
  function holeStatsUpdate() {
    const holeElement = document.getElementById("holeStats");
    const strokeElement = document.getElementById("strokeStats");
    if (currentHole) {
      let text = `| ${currentHole.strokes.length} Strokes`;
      if (currentHole.par) {
        text += ` | Par ${currentHole.par}`;
      }
      if (currentHole.handicap) {
        text += ` | Hcp ${currentHole.handicap}`;
      }
      holeElement.innerText = text;
      strokeElement.innerHTML = "";
      currentHole.strokes.forEach(function(stroke) {
        strokeElement.appendChild(strokeStatsListItem(stroke));
      });
    } else {
      holeElement.innerText = "";
      strokeElement.innerHTML = "";
    }
  }
  function strokeStatsListItem(stroke) {
    let distance2 = 0;
    if (currentHole.strokes[stroke.index + 1]) {
      distance2 = getDistance(stroke.start, currentHole.strokes[stroke.index + 1].start);
    } else if (currentHole.pin) {
      distance2 = getDistance(stroke.start, currentHole.pin);
    }
    const listItem = document.createElement("li");
    const container = document.createElement("div");
    container.classList.add("strokeStatContainer");
    const text = document.createElement("div");
    const dispersionLink = document.createElement("a");
    text.classList.add("strokeDetails");
    text.innerHTML = `${stroke.club} (${Math.round(distance2)}m) | &#xb1;`;
    dispersionLink.setAttribute("href", `#stroke_${stroke.index}_dispersion`);
    dispersionLink.innerText = `${stroke.dispersion}m`;
    dispersionLink.addEventListener("click", () => {
      let disp = prompt("Enter a dispersion:");
      if (disp != null) {
        stroke.dispersion = disp;
        rerender("full");
      }
    });
    text.appendChild(dispersionLink);
    const buttons = document.createElement("div");
    buttons.classList.add("strokeControls");
    buttons.append(
      strokeSelectViewCreate(stroke),
      strokeMoveViewCreate(stroke, -1),
      strokeMoveViewCreate(stroke, 1),
      strokeDeleteViewCreate(stroke)
    );
    container.append(text);
    container.append(buttons);
    listItem.append(container);
    return listItem;
  }
  function aimStatsUpdate() {
    const el = document.getElementById("aimStats");
    const layer = layerRead("active_grid");
    if (!layer) {
      return;
    }
    const grid = layer.options.grid;
    const stroke = activeStroke;
    const hole = round.holes[stroke.hole - 1];
    const wsg = grid.properties.weightedStrokesGained;
    const sr = grid.properties.strokesRemainingStart;
    const sa = currentHole.strokes.length - stroke.index - 1;
    let srn = 0;
    if (sa > 0) {
      let nextStart = currentHole.strokes[stroke.index + 1].start;
      let startPoint = point([nextStart.x, nextStart.y]);
      let pinCoord = [hole.pin.x, hole.pin.y];
      srn = strokesRemainingFrom(startPoint, pinCoord, roundCourseParams(round));
    }
    const sga = sr - srn - 1;
    let text = `SG Aim: ${wsg.toFixed(3)} | SG Actual: ${sga.toFixed(3)} | SR: ${sr.toFixed(3)}`;
    text += "<hr/>";
    el.innerHTML = text;
  }
  function activeStrokeStatsCreate() {
    const el = document.getElementById("activeStrokeControls");
    el.classList.remove("inactive");
    aimStatsUpdate();
  }
  function activeStrokeStatsDelete() {
    const el = document.getElementById("activeStrokeControls");
    el.classList.add("inactive");
  }
  function aimStatsCreate() {
    const el = document.getElementById("aimStats");
    el.classList.remove("inactive");
    aimStatsUpdate();
  }
  function aimStatsDelete() {
    const el = document.getElementById("aimStats");
    el.classList.add("inactive");
  }
  function gridTypeSelectCreate() {
    let selector = document.getElementById("gridTypeSelect");
    if (!(selector instanceof HTMLSelectElement)) {
      return;
    }
    while (selector.firstChild) {
      selector.removeChild(selector.firstChild);
    }
    for (let type in gridTypes) {
      let opt = document.createElement("option");
      opt.value = gridTypes[type];
      opt.innerText = gridTypes[type];
      selector.appendChild(opt);
    }
    let activeGrid = layerRead("active_grid");
    if (activeGrid) {
      let type = activeGrid.options.grid.properties.type;
      selector.value = type;
    }
    selector.addEventListener("change", handleGridTypeSelection);
  }
  function handleGridTypeSelection() {
    gridDelete();
    wait(10).then(() => gridCreate(this.value));
  }
  function strokeDeleteViewCreate(stroke) {
    let link2 = document.createElement("button");
    link2.innerHTML = "&#215;";
    link2.id = `stroke_${stroke.index}_delete`;
    link2.classList.add("danger");
    link2.addEventListener("click", () => {
      strokeDelete(stroke.hole, stroke.index);
    });
    return link2;
  }
  function strokeSelectViewCreate(stroke) {
    let link2 = document.createElement("button");
    let icon2;
    let state;
    let cls;
    let func;
    let arg;
    if (stroke == activeStroke) {
      icon2 = "&#x26AC;";
      state = "deactivate";
      cls = "secondary";
      func = strokeMarkerDeactivate;
      arg = null;
    } else {
      icon2 = "&#x2609;";
      state = "activate";
      cls = "success";
      func = strokeMarkerActivate;
      arg = layerRead(strokeMarkerID(stroke));
    }
    link2.innerHTML = icon2;
    link2.id = `stroke_${stroke.index}_${state}`;
    link2.classList.add(cls);
    link2.addEventListener("click", () => {
      func(arg);
      rerender();
    });
    return link2;
  }
  function strokeMoveViewCreate(stroke, offset) {
    let link2 = document.createElement("button");
    let icon2 = offset > 0 ? "&#8595;" : "&#8593;";
    link2.innerHTML = icon2;
    link2.id = `stroke_${stroke.index}_move_${offset}`;
    link2.addEventListener("click", () => {
      strokeMove(stroke.hole, stroke.index, offset);
    });
    return link2;
  }
  function rerender(type) {
    if (!type || type == "full") {
      roundViewUpdate();
      strokelineUpdate();
      strokeMarkerUpdate();
      strokeMarkerAimUpdate();
      holeStatsUpdate();
      saveData();
    }
    if ((type == "dragend" || type == "full") && activeStroke) {
      gridUpdate().then(() => {
        aimStatsUpdate();
        strokeMarkerAimUpdate();
      }, (error) => console.error(error));
    }
    if (type == "full") {
      strokeMarkerAimDelete();
      strokeMarkerAimCreate();
    }
  }
  var clubDataFields = ["dispersion"];
  function clubStrokeViewCreate(clubs, targetElement) {
    clubs.forEach((clubData) => {
      const button = document.createElement("button");
      button.textContent = clubData.name;
      button.id = clubData.id;
      if (clubDataFields) {
        clubDataFields.forEach((field) => {
          if (clubData[field]) {
            button.setAttribute(`data-${field}`, clubData[field]);
          }
        });
      }
      if (clubData.style) {
        Object.assign(button.style, clubData.style);
      }
      if (clubData.class) {
        button.classList.add(clubData.class);
      }
      button.addEventListener("click", clubStrokeCreateCallback(clubData));
      targetElement.appendChild(button);
    });
  }
  function clubStrokeCreateCallback(club) {
    return () => {
      clubStrokeViewToggle();
      getLocationOnMap().then((position) => {
        clubStrokeCreate(position, club);
      });
    };
  }
  function clubStrokeViewToggle() {
    const el = document.getElementById("clubStrokeCreateContainer");
    el.classList.toggle("inactive");
    if (!currentPositionEnabled) {
      currentPositionUpdate();
    }
  }
  function courseSearchViewUpdate(results) {
    let resultList = document.getElementById("courseSearchResults");
    resultList.innerHTML = "";
    results.forEach((result) => {
      let listItem = document.createElement("li");
      let link2 = document.createElement("a");
      let courseParams = { "name": result.namedetails.name, "id": osmCourseID(result.osm_type, result.osm_id) };
      link2.innerText = result.display_name;
      link2.setAttribute("href", `#${result.osm_id}`);
      link2.addEventListener("click", handleRoundCreateClickCallback(courseParams));
      listItem.appendChild(link2);
      resultList.appendChild(listItem);
    });
  }
  function osmCourseID(type, id) {
    return `osm-${type}-${id}`;
  }
  function handleLoad() {
    mapViewCreate("mapid");
    clubStrokeViewCreate(clubReadAll(), document.getElementById("clubStrokeCreateContainer"));
    loadData();
    let courseData = { "name": round.course, "id": round.courseId };
    fetchGolfCourseData(courseData).then(() => mapRecenter("currentHole"));
    holeSelectViewCreate(document.getElementById("holeSelector"));
    gridTypeSelectCreate();
  }
  function handleStrokeAddClick() {
    clubStrokeViewToggle();
    strokeMarkerDeactivate();
  }
  function handleRoundCreateClickCallback(courseParams) {
    return () => {
      let courseName;
      let courseId;
      if (courseParams) {
        courseName = courseParams["name"];
        courseId = courseParams["id"];
      } else {
        let el = document.getElementById("courseName");
        if (!(el instanceof HTMLInputElement)) {
          return;
        }
        courseName = el.value;
      }
      if (!courseName && !courseId) {
        alert("Course name cannot be blank!");
        return;
      }
      if (confirm("Are you sure you want to start a new round? All current data will be lost.")) {
        roundCreate(courseParams);
        holeSelectViewUpdate();
        rerender();
      }
    };
  }
  function handleStrokeMarkerAimCreateClick() {
    mapView.on("click", strokeMarkerAimCreate);
    mapView.off("click", strokeMarkerDeactivate);
  }
  function handleToggleRoundClick() {
    const roundDiv = document.getElementById("roundInfo");
    roundDiv.classList.toggle("inactive");
  }
  function handleCopyToClipboardClick() {
    navigator.clipboard.writeText(document.getElementById("locationData").textContent);
  }
  function handleRecenterClick() {
    mapRecenter("currentHole");
  }
  var timeoutId;
  function handleCourseSearchInput() {
    let query = this.value;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      if (query.length >= 3) {
        return courseSearch(query).then(courseSearchViewUpdate);
      } else {
        document.getElementById("courseSearchResults").innerHTML = "";
      }
    }, 500);
  }
  function showError(error) {
    switch (error.code) {
      case error.PERMISSION_DENIED:
        document.getElementById("error").innerText = "User denied the request for Geolocation.";
        break;
      case error.POSITION_UNAVAILABLE:
        document.getElementById("error").innerText = "Location information is unavailable.";
        break;
      case error.TIMEOUT:
        document.getElementById("error").innerText = "The request to get user location timed out.";
        break;
      case error.UNKNOWN_ERROR:
        document.getElementById("error").innerText = "An unknown error occurred.";
        break;
      default:
        document.getElementById("error").innerText = error.text;
        break;
    }
  }
  var strokeMarkerAimCreateButton = document.getElementById("strokeMarkerAimCreate");
  window.onload = handleLoad;
  document.getElementById("strokeAdd").addEventListener("click", handleStrokeAddClick);
  document.getElementById("clubStrokeCreateContainerClose").addEventListener("click", clubStrokeViewToggle);
  document.getElementById("roundCreate").addEventListener("click", handleRoundCreateClickCallback());
  document.getElementById("toggleRound").addEventListener("click", handleToggleRoundClick);
  document.getElementById("copyToClipboard").addEventListener("click", handleCopyToClipboardClick);
  document.getElementById("undoAction").addEventListener("click", handleUndoActionClick);
  document.getElementById("recenter").addEventListener("click", handleRecenterClick);
  strokeMarkerAimCreateButton.addEventListener("click", handleStrokeMarkerAimCreateClick);
  document.getElementById("courseName").addEventListener("input", handleCourseSearchInput);
})();
/*! Bundled license information:

leaflet/dist/leaflet-src.js:
  (* @preserve
   * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
   * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

polygon-clipping/dist/polygon-clipping.umd.js:
  (**
   * splaytree v3.1.0
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   *)

osmtogeojson/lodash.custom.js:
  (**
   * @license
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash exports="node" include="clone,merge,isEmpty,isArray,compact,each" -d`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

chroma-js/chroma.js:
  (**
   * chroma.js - JavaScript library for color conversions
   *
   * Copyright (c) 2011-2019, Gregor Aisch
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   * list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. The name Gregor Aisch may not be used to endorse or promote products
   * derived from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
   * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
   * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * -------------------------------------------------------
   *
   * chroma.js includes colors from colorbrewer2.org, which are released under
   * the following license:
   *
   * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
   * and The Pennsylvania State University.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing,
   * software distributed under the License is distributed on an
   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
   * either express or implied. See the License for the specific
   * language governing permissions and limitations under the License.
   *
   * ------------------------------------------------------
   *
   * Named colors are taken from X11 Color Names.
   * http://www.w3.org/TR/css3-color/#svg-color
   *
   * @preserve
   *)

@turf/isolines/dist/es/index.js:
  (**
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   *)

@turf/isobands/dist/es/index.js:
  (*!
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   *)
*/
